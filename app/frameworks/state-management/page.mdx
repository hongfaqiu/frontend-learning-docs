import { Callout } from 'nextra/components'

# 10. çŠ¶æ€ç®¡ç†æ·±å…¥

## ğŸ“‹ ç›®å½•

- [çŠ¶æ€ç®¡ç†æ¦‚å¿µå’Œæ¨¡å¼](#çŠ¶æ€ç®¡ç†æ¦‚å¿µå’Œæ¨¡å¼)
- [Reduxç”Ÿæ€ç³»ç»Ÿ](#reduxç”Ÿæ€ç³»ç»Ÿ)
- [ç°ä»£çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ](#ç°ä»£çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ)
- [çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”](#çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”)
- [æœ€ä½³å®è·µå’Œé€‰æ‹©æŒ‡å—](#æœ€ä½³å®è·µå’Œé€‰æ‹©æŒ‡å—)
- [æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†](#æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†)

## çŠ¶æ€ç®¡ç†æ¦‚å¿µå’Œæ¨¡å¼

<Callout type="info">
çŠ¶æ€ç®¡ç†æ˜¯ç°ä»£å‰ç«¯åº”ç”¨çš„æ ¸å¿ƒé—®é¢˜ï¼Œé€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆèƒ½å¤Ÿæ˜¾è‘—æå‡å¼€å‘æ•ˆç‡å’Œåº”ç”¨æ€§èƒ½ã€‚
</Callout>

### çŠ¶æ€ç®¡ç†çš„æ ¸å¿ƒæ¦‚å¿µ

```javascript
// çŠ¶æ€ç®¡ç†çš„åŸºæœ¬æ¨¡å¼

// 1. å•å‘æ•°æ®æµ
/*
Action â†’ Dispatcher â†’ Store â†’ View â†’ Action
*/

// 2. çŠ¶æ€çš„åˆ†ç±»
const stateTypes = {
  // æœ¬åœ°çŠ¶æ€ï¼ˆç»„ä»¶å†…éƒ¨çŠ¶æ€ï¼‰
  local: {
    formData: {},
    isModalOpen: false,
    inputValue: ''
  },
  
  // å…¨å±€çŠ¶æ€ï¼ˆåº”ç”¨çº§çŠ¶æ€ï¼‰
  global: {
    user: null,
    theme: 'light',
    language: 'zh-CN'
  },
  
  // æœåŠ¡ç«¯çŠ¶æ€ï¼ˆè¿œç¨‹æ•°æ®ï¼‰
  server: {
    users: [],
    posts: [],
    loading: false,
    error: null
  },
  
  // URLçŠ¶æ€ï¼ˆè·¯ç”±çŠ¶æ€ï¼‰
  url: {
    pathname: '/users',
    search: '?page=1&limit=10',
    hash: '#section1'
  }
};

// 3. çŠ¶æ€ç®¡ç†çš„æŒ‘æˆ˜
const challenges = {
  // çŠ¶æ€åŒæ­¥
  synchronization: 'å¤šä¸ªç»„ä»¶éœ€è¦è®¿é—®åŒä¸€çŠ¶æ€',
  
  // çŠ¶æ€æŒä¹…åŒ–
  persistence: 'çŠ¶æ€éœ€è¦åœ¨é¡µé¢åˆ·æ–°åä¿æŒ',
  
  // çŠ¶æ€é¢„æµ‹æ€§
  predictability: 'çŠ¶æ€å˜åŒ–éœ€è¦å¯é¢„æµ‹å’Œå¯è°ƒè¯•',
  
  // æ€§èƒ½ä¼˜åŒ–
  performance: 'é¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“',
  
  // å¼€å‘ä½“éªŒ
  devExperience: 'è‰¯å¥½çš„è°ƒè¯•å·¥å…·å’Œå¼€å‘ä½“éªŒ'
};
```

### çŠ¶æ€ç®¡ç†æ¨¡å¼

```javascript
// 1. Fluxæ¨¡å¼
class FluxStore {
  constructor() {
    this.state = {};
    this.listeners = [];
  }
  
  getState() {
    return this.state;
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  emit() {
    this.listeners.forEach(listener => listener());
  }
  
  reduce(action) {
    // å­ç±»å®ç°
    throw new Error('reduce method must be implemented');
  }
}

class UserStore extends FluxStore {
  constructor() {
    super();
    this.state = {
      users: [],
      loading: false,
      error: null
    };
  }
  
  reduce(action) {
    switch (action.type) {
      case 'FETCH_USERS_START':
        this.state = {
          ...this.state,
          loading: true,
          error: null
        };
        break;
        
      case 'FETCH_USERS_SUCCESS':
        this.state = {
          ...this.state,
          users: action.payload,
          loading: false
        };
        break;
        
      case 'FETCH_USERS_ERROR':
        this.state = {
          ...this.state,
          loading: false,
          error: action.payload
        };
        break;
    }
    
    this.emit();
  }
}

// 2. è§‚å¯Ÿè€…æ¨¡å¼
class Observable {
  constructor(initialValue) {
    this.value = initialValue;
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  }
  
  next(newValue) {
    this.value = newValue;
    this.observers.forEach(observer => observer(newValue));
  }
  
  map(fn) {
    const mapped = new Observable(fn(this.value));
    this.subscribe(value => mapped.next(fn(value)));
    return mapped;
  }
  
  filter(predicate) {
    const filtered = new Observable(
      predicate(this.value) ? this.value : undefined
    );
    this.subscribe(value => {
      if (predicate(value)) {
        filtered.next(value);
      }
    });
    return filtered;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const userCount$ = new Observable(0);
const evenUserCount$ = userCount$.filter(count => count % 2 === 0);

userCount$.subscribe(count => console.log('ç”¨æˆ·æ•°é‡:', count));
evenUserCount$.subscribe(count => console.log('å¶æ•°ç”¨æˆ·æ•°é‡:', count));

userCount$.next(1); // è¾“å‡º: ç”¨æˆ·æ•°é‡: 1
userCount$.next(2); // è¾“å‡º: ç”¨æˆ·æ•°é‡: 2, å¶æ•°ç”¨æˆ·æ•°é‡: 2
```

## Reduxç”Ÿæ€ç³»ç»Ÿ

### Redux Toolkitç°ä»£åŒ–å®è·µ

<Callout type="warning">
Redux Toolkitæ˜¯Reduxå®˜æ–¹æ¨èçš„ç°ä»£åŒ–å·¥å…·é›†ï¼Œå¤§å¤§ç®€åŒ–äº†Reduxçš„ä½¿ç”¨å¤æ‚åº¦ã€‚
</Callout>

```javascript
// 1. ä½¿ç”¨createSliceåˆ›å»ºçŠ¶æ€åˆ‡ç‰‡
import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';

// å¼‚æ­¥thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (params, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users?${new URLSearchParams(params)}`);
      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const createUser = createAsyncThunk(
  'users/createUser',
  async (userData, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      
      if (!response.ok) {
        throw new Error('Failed to create user');
      }
      
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// çŠ¶æ€åˆ‡ç‰‡
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    loading: false,
    error: null,
    filters: {
      search: '',
      role: 'all',
      status: 'all'
    },
    pagination: {
      page: 1,
      limit: 10,
      total: 0
    }
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      state.pagination.page = 1; // é‡ç½®é¡µç 
    },
    
    setPagination: (state, action) => {
      state.pagination = { ...state.pagination, ...action.payload };
    },
    
    clearError: (state) => {
      state.error = null;
    },
    
    updateUser: (state, action) => {
      const { id, updates } = action.payload;
      const userIndex = state.items.findIndex(user => user.id === id);
      if (userIndex !== -1) {
        state.items[userIndex] = { ...state.items[userIndex], ...updates };
      }
    },
    
    removeUser: (state, action) => {
      state.items = state.items.filter(user => user.id !== action.payload);
    }
  },
  extraReducers: (builder) => {
    builder
      // fetchUsers
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.data;
        state.pagination.total = action.payload.total;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // createUser
      .addCase(createUser.fulfilled, (state, action) => {
        state.items.unshift(action.payload);
        state.pagination.total += 1;
      });
  }
});

export const { setFilters, setPagination, clearError, updateUser, removeUser } = usersSlice.actions;
export default usersSlice.reducer;

// 2. Selectors
export const selectUsers = (state) => state.users.items;
export const selectUsersLoading = (state) => state.users.loading;
export const selectUsersError = (state) => state.users.error;
export const selectUsersFilters = (state) => state.users.filters;
export const selectUsersPagination = (state) => state.users.pagination;

// è®°å¿†åŒ–é€‰æ‹©å™¨
export const selectFilteredUsers = createSelector(
  [selectUsers, selectUsersFilters],
  (users, filters) => {
    return users.filter(user => {
      const matchesSearch = !filters.search || 
        user.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        user.email.toLowerCase().includes(filters.search.toLowerCase());
      
      const matchesRole = filters.role === 'all' || user.role === filters.role;
      const matchesStatus = filters.status === 'all' || user.status === filters.status;
      
      return matchesSearch && matchesRole && matchesStatus;
    });
  }
);

export const selectUserById = createSelector(
  [selectUsers, (state, userId) => userId],
  (users, userId) => users.find(user => user.id === userId)
);

export const selectUsersStats = createSelector(
  [selectUsers],
  (users) => ({
    total: users.length,
    active: users.filter(user => user.status === 'active').length,
    inactive: users.filter(user => user.status === 'inactive').length,
    admins: users.filter(user => user.role === 'admin').length
  })
);

// 3. Storeé…ç½®
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'settings'] // åªæŒä¹…åŒ–è¿™äº›reducer
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    }).concat(
      // è‡ªå®šä¹‰ä¸­é—´ä»¶
      loggerMiddleware,
      errorMiddleware
    ),
  devTools: process.env.NODE_ENV !== 'production'
});

export const persistor = persistStore(store);

// 4. è‡ªå®šä¹‰ä¸­é—´ä»¶
const loggerMiddleware = (store) => (next) => (action) => {
  console.group(action.type);
  console.info('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  console.groupEnd();
  return result;
};

const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Redux error:', error);
    // å¯ä»¥å‘é€é”™è¯¯åˆ°ç›‘æ§æœåŠ¡
    throw error;
  }
};

// 5. Reactç»„ä»¶ä¸­ä½¿ç”¨
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

function UserList() {
  const dispatch = useDispatch();
  const users = useSelector(selectFilteredUsers);
  const loading = useSelector(selectUsersLoading);
  const error = useSelector(selectUsersError);
  const filters = useSelector(selectUsersFilters);
  const pagination = useSelector(selectUsersPagination);
  const stats = useSelector(selectUsersStats);
  
  useEffect(() => {
    dispatch(fetchUsers({ 
      page: pagination.page, 
      limit: pagination.limit,
      ...filters 
    }));
  }, [dispatch, pagination.page, pagination.limit, filters]);
  
  const handleFilterChange = (newFilters) => {
    dispatch(setFilters(newFilters));
  };
  
  const handlePageChange = (page) => {
    dispatch(setPagination({ page }));
  };
  
  const handleCreateUser = (userData) => {
    dispatch(createUser(userData));
  };
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <UserStats stats={stats} />
      <UserFilters filters={filters} onChange={handleFilterChange} />
      <UserTable users={users} />
      <Pagination 
        current={pagination.page}
        total={pagination.total}
        pageSize={pagination.limit}
        onChange={handlePageChange}
      />
    </div>
  );
}
```

## ç°ä»£çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ

### Zustand - è½»é‡çº§çŠ¶æ€ç®¡ç†

```javascript
// 1. åŸºç¡€Zustand store
import { create } from 'zustand';
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

const useUserStore = create()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // çŠ¶æ€
          users: [],
          loading: false,
          error: null,
          filters: {
            search: '',
            role: 'all'
          },
          
          // åŠ¨ä½œ
          setUsers: (users) => set((state) => {
            state.users = users;
          }),
          
          addUser: (user) => set((state) => {
            state.users.push(user);
          }),
          
          updateUser: (id, updates) => set((state) => {
            const userIndex = state.users.findIndex(u => u.id === id);
            if (userIndex !== -1) {
              Object.assign(state.users[userIndex], updates);
            }
          }),
          
          removeUser: (id) => set((state) => {
            state.users = state.users.filter(u => u.id !== id);
          }),
          
          setFilters: (filters) => set((state) => {
            Object.assign(state.filters, filters);
          }),
          
          setLoading: (loading) => set({ loading }),
          setError: (error) => set({ error }),
          
          // å¼‚æ­¥åŠ¨ä½œ
          fetchUsers: async () => {
            const { setLoading, setError, setUsers } = get();
            
            setLoading(true);
            setError(null);
            
            try {
              const response = await fetch('/api/users');
              const users = await response.json();
              setUsers(users);
            } catch (error) {
              setError(error.message);
            } finally {
              setLoading(false);
            }
          },
          
          // è®¡ç®—å±æ€§
          get filteredUsers() {
            const { users, filters } = get();
            return users.filter(user => {
              const matchesSearch = !filters.search || 
                user.name.toLowerCase().includes(filters.search.toLowerCase());
              const matchesRole = filters.role === 'all' || user.role === filters.role;
              return matchesSearch && matchesRole;
            });
          }
        }))
      ),
      {
        name: 'user-store',
        partialize: (state) => ({ 
          filters: state.filters 
        })
      }
    ),
    {
      name: 'user-store'
    }
  )
);

// 2. åˆ†ç‰‡storeæ¨¡å¼
const createUserSlice = (set, get) => ({
  users: [],
  addUser: (user) => set((state) => ({ 
    users: [...state.users, user] 
  })),
  removeUser: (id) => set((state) => ({ 
    users: state.users.filter(u => u.id !== id) 
  }))
});

const createAuthSlice = (set, get) => ({
  user: null,
  token: null,
  login: async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    const { user, token } = await response.json();
    set({ user, token });
  },
  logout: () => set({ user: null, token: null })
});

const useAppStore = create()(
  devtools(
    (...args) => ({
      ...createUserSlice(...args),
      ...createAuthSlice(...args)
    })
  )
);

// 3. é€‰æ‹©å™¨å’Œè®¢é˜…
import { useShallow } from 'zustand/react/shallow';

function UserComponent() {
  // æµ…æ¯”è¾ƒé€‰æ‹©å™¨
  const { users, addUser, removeUser } = useUserStore(
    useShallow((state) => ({
      users: state.users,
      addUser: state.addUser,
      removeUser: state.removeUser
    }))
  );
  
  // è®¢é˜…ç‰¹å®šçŠ¶æ€å˜åŒ–
  useEffect(() => {
    const unsubscribe = useUserStore.subscribe(
      (state) => state.users.length,
      (userCount) => {
        console.log('ç”¨æˆ·æ•°é‡å˜åŒ–:', userCount);
      }
    );
    
    return unsubscribe;
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onRemove={() => removeUser(user.id)}
        />
      ))}
    </div>
  );
}
```

### Jotai - åŸå­åŒ–çŠ¶æ€ç®¡ç†

```javascript
// 1. åŸå­å®šä¹‰
import { atom, selector } from 'jotai';

// åŸºç¡€åŸå­
export const usersAtom = atom([]);
export const loadingAtom = atom(false);
export const errorAtom = atom(null);
export const searchAtom = atom('');
export const roleFilterAtom = atom('all');

// æ´¾ç”ŸåŸå­
export const filteredUsersAtom = atom((get) => {
  const users = get(usersAtom);
  const search = get(searchAtom);
  const roleFilter = get(roleFilterAtom);
  
  return users.filter(user => {
    const matchesSearch = !search || 
      user.name.toLowerCase().includes(search.toLowerCase());
    const matchesRole = roleFilter === 'all' || user.role === roleFilter;
    return matchesSearch && matchesRole;
  });
});

export const userStatsAtom = atom((get) => {
  const users = get(usersAtom);
  return {
    total: users.length,
    active: users.filter(u => u.status === 'active').length,
    admins: users.filter(u => u.role === 'admin').length
  };
});

// å¼‚æ­¥åŸå­
export const fetchUsersAtom = atom(
  null,
  async (get, set) => {
    set(loadingAtom, true);
    set(errorAtom, null);
    
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      set(usersAtom, users);
    } catch (error) {
      set(errorAtom, error.message);
    } finally {
      set(loadingAtom, false);
    }
  }
);

export const addUserAtom = atom(
  null,
  async (get, set, newUser) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      });
      const user = await response.json();
      
      const currentUsers = get(usersAtom);
      set(usersAtom, [...currentUsers, user]);
      
      return user;
    } catch (error) {
      set(errorAtom, error.message);
      throw error;
    }
  }
);

// 2. ç»„ä»¶ä¸­ä½¿ç”¨
import { useAtom, useAtomValue, useSetAtom } from 'jotai';

function UserList() {
  const [users, setUsers] = useAtom(usersAtom);
  const filteredUsers = useAtomValue(filteredUsersAtom);
  const loading = useAtomValue(loadingAtom);
  const error = useAtomValue(errorAtom);
  const stats = useAtomValue(userStatsAtom);
  
  const fetchUsers = useSetAtom(fetchUsersAtom);
  const addUser = useSetAtom(addUserAtom);
  
  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);
  
  const handleAddUser = async (userData) => {
    try {
      await addUser(userData);
      console.log('ç”¨æˆ·æ·»åŠ æˆåŠŸ');
    } catch (error) {
      console.error('æ·»åŠ ç”¨æˆ·å¤±è´¥:', error);
    }
  };
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <UserStats stats={stats} />
      <UserFilters />
      <div>
        {filteredUsers.map(user => (
          <UserCard key={user.id} user={user} />
        ))}
      </div>
    </div>
  );
}

function UserFilters() {
  const [search, setSearch] = useAtom(searchAtom);
  const [roleFilter, setRoleFilter] = useAtom(roleFilterAtom);
  
  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="æœç´¢ç”¨æˆ·..."
      />
      <select
        value={roleFilter}
        onChange={(e) => setRoleFilter(e.target.value)}
      >
        <option value="all">æ‰€æœ‰è§’è‰²</option>
        <option value="admin">ç®¡ç†å‘˜</option>
        <option value="user">æ™®é€šç”¨æˆ·</option>
      </select>
    </div>
  );
}

// 3. åŸå­çš„æŒä¹…åŒ–
import { atomWithStorage } from 'jotai/utils';

export const themeAtom = atomWithStorage('theme', 'light');
export const settingsAtom = atomWithStorage('settings', {
  language: 'zh-CN',
  notifications: true
});

// 4. åŸå­çš„é‡ç½®
import { RESET } from 'jotai/utils';

export const resetUsersAtom = atom(null, (get, set) => {
  set(usersAtom, RESET);
  set(searchAtom, RESET);
  set(roleFilterAtom, RESET);
  set(errorAtom, RESET);
});
```

## çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”

### æ–¹æ¡ˆé€‰æ‹©çŸ©é˜µ

| ç‰¹æ€§ | Redux Toolkit | Zustand | Jotai | Context API | Valtio |
|------|---------------|---------|-------|-------------|--------|
| **å­¦ä¹ æ›²çº¿** | ä¸­ç­‰ | ç®€å• | ä¸­ç­‰ | ç®€å• | ç®€å• |
| **åŒ…å¤§å°** | å¤§ | å° | å° | æ—  | å° |
| **TypeScriptæ”¯æŒ** | ä¼˜ç§€ | ä¼˜ç§€ | ä¼˜ç§€ | è‰¯å¥½ | ä¼˜ç§€ |
| **å¼€å‘å·¥å…·** | ä¼˜ç§€ | è‰¯å¥½ | è‰¯å¥½ | æ—  | è‰¯å¥½ |
| **æ€§èƒ½** | è‰¯å¥½ | ä¼˜ç§€ | ä¼˜ç§€ | å·® | ä¼˜ç§€ |
| **ç”Ÿæ€ç³»ç»Ÿ** | ä¸°å¯Œ | ä¸­ç­‰ | ä¸­ç­‰ | ä¸°å¯Œ | å° |
| **é€‚ç”¨åœºæ™¯** | å¤§å‹åº”ç”¨ | ä¸­å°å‹åº”ç”¨ | å¤æ‚çŠ¶æ€ | ç®€å•çŠ¶æ€ | å“åº”å¼åº”ç”¨ |

### é€‰æ‹©æŒ‡å—

```javascript
// é€‰æ‹©å†³ç­–æ ‘
const stateManagementDecision = {
  // 1. åº”ç”¨è§„æ¨¡
  applicationSize: {
    small: {
      recommendation: 'useState + useContext',
      reason: 'ç®€å•çŠ¶æ€ç®¡ç†è¶³å¤Ÿï¼Œé¿å…è¿‡åº¦å·¥ç¨‹åŒ–'
    },
    medium: {
      recommendation: 'Zustand',
      reason: 'è½»é‡çº§ï¼Œæ˜“äºä½¿ç”¨ï¼Œæ€§èƒ½è‰¯å¥½'
    },
    large: {
      recommendation: 'Redux Toolkit',
      reason: 'æˆç†Ÿçš„ç”Ÿæ€ç³»ç»Ÿï¼Œå¼ºå¤§çš„å¼€å‘å·¥å…·'
    }
  },
  
  // 2. å›¢é˜Ÿç»éªŒ
  teamExperience: {
    beginner: {
      recommendation: 'Zustand',
      reason: 'å­¦ä¹ æ›²çº¿å¹³ç¼“ï¼Œæ¦‚å¿µç®€å•'
    },
    intermediate: {
      recommendation: 'Jotai æˆ– Zustand',
      reason: 'å¯ä»¥å¤„ç†æ›´å¤æ‚çš„çŠ¶æ€é€»è¾‘'
    },
    expert: {
      recommendation: 'Redux Toolkit',
      reason: 'å¯ä»¥å……åˆ†åˆ©ç”¨Reduxçš„å¼ºå¤§åŠŸèƒ½'
    }
  },
  
  // 3. çŠ¶æ€å¤æ‚åº¦
  stateComplexity: {
    simple: {
      recommendation: 'useState + useContext',
      reason: 'å†…ç½®è§£å†³æ–¹æ¡ˆè¶³å¤Ÿ'
    },
    moderate: {
      recommendation: 'Zustand',
      reason: 'å¹³è¡¡äº†ç®€å•æ€§å’ŒåŠŸèƒ½æ€§'
    },
    complex: {
      recommendation: 'Redux Toolkit æˆ– Jotai',
      reason: 'å¼ºå¤§çš„çŠ¶æ€ç®¡ç†èƒ½åŠ›'
    }
  },
  
  // 4. æ€§èƒ½è¦æ±‚
  performanceRequirements: {
    low: {
      recommendation: 'ä»»ä½•æ–¹æ¡ˆ',
      reason: 'æ€§èƒ½ä¸æ˜¯ä¸»è¦è€ƒè™‘å› ç´ '
    },
    high: {
      recommendation: 'Jotai æˆ– Valtio',
      reason: 'ç»†ç²’åº¦æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“'
    }
  }
};

// å®é™…é€‰æ‹©ç¤ºä¾‹
function chooseStateManagement(requirements) {
  const {
    appSize,
    teamSize,
    complexity,
    performance,
    timeline
  } = requirements;
  
  // å¿«é€ŸåŸå‹æˆ–å°é¡¹ç›®
  if (timeline === 'short' && appSize === 'small') {
    return {
      solution: 'useState + useContext',
      reason: 'å¿«é€Ÿå¼€å‘ï¼Œæ— éœ€é¢å¤–ä¾èµ–'
    };
  }
  
  // ä¸­å‹é¡¹ç›®ï¼Œæ³¨é‡å¼€å‘ä½“éªŒ
  if (appSize === 'medium' && teamSize <= 5) {
    return {
      solution: 'Zustand',
      reason: 'ç®€å•æ˜“ç”¨ï¼Œæ€§èƒ½è‰¯å¥½ï¼Œå­¦ä¹ æˆæœ¬ä½'
    };
  }
  
  // å¤§å‹ä¼ä¸šåº”ç”¨
  if (appSize === 'large' && teamSize > 5) {
    return {
      solution: 'Redux Toolkit',
      reason: 'æˆç†Ÿç¨³å®šï¼Œå·¥å…·é“¾å®Œå–„ï¼Œå›¢é˜Ÿåä½œå‹å¥½'
    };
  }
  
  // é«˜æ€§èƒ½è¦æ±‚
  if (performance === 'critical') {
    return {
      solution: 'Jotai',
      reason: 'åŸå­åŒ–çŠ¶æ€ï¼Œç²¾ç¡®æ§åˆ¶é‡æ¸²æŸ“'
    };
  }
  
  // é»˜è®¤æ¨è
  return {
    solution: 'Zustand',
    reason: 'å¹³è¡¡äº†æ‰€æœ‰æ–¹é¢çš„éœ€æ±‚'
  };
}
```

## æœ€ä½³å®è·µå’Œé€‰æ‹©æŒ‡å—

<Callout type="info">
é€‰æ‹©çŠ¶æ€ç®¡ç†æ–¹æ¡ˆéœ€è¦è€ƒè™‘åº”ç”¨è§„æ¨¡ã€å›¢é˜Ÿç»éªŒã€æ€§èƒ½è¦æ±‚ç­‰å¤šä¸ªç»´åº¦ã€‚
</Callout>

### é€‰æ‹©å†³ç­–æ ‘

```javascript
// çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©æŒ‡å—
function chooseStateManagement(appContext) {
  const {
    teamSize,
    appComplexity,
    performanceRequirements,
    teamExperience,
    framework
  } = appContext;

  // å°å‹åº”ç”¨
  if (appComplexity === 'simple' && teamSize <= 3) {
    return framework === 'react'
      ? 'useState + useContext'
      : 'Vue reactive + provide/inject';
  }

  // ä¸­å‹åº”ç”¨
  if (appComplexity === 'medium' && teamSize <= 10) {
    return framework === 'react'
      ? ['Zustand', 'Jotai', 'Valtio']
      : ['Pinia', 'Vuex'];
  }

  // å¤§å‹åº”ç”¨
  if (appComplexity === 'complex' || teamSize > 10) {
    return framework === 'react'
      ? ['Redux Toolkit', 'MobX']
      : ['Pinia', 'Vuex'];
  }

  // é«˜æ€§èƒ½è¦æ±‚
  if (performanceRequirements === 'high') {
    return ['Valtio', 'Jotai', 'MobX'];
  }
}
```

### æœ€ä½³å®è·µåŸåˆ™

```javascript
// 1. çŠ¶æ€ç»“æ„è®¾è®¡
const goodStateStructure = {
  // æ‰å¹³åŒ–ç»“æ„
  users: {
    byId: {
      '1': { id: '1', name: 'John' },
      '2': { id: '2', name: 'Jane' }
    },
    allIds: ['1', '2']
  },

  // åˆ†ç¦»UIçŠ¶æ€å’Œä¸šåŠ¡çŠ¶æ€
  ui: {
    loading: false,
    selectedUserId: '1',
    filters: {
      status: 'active',
      role: 'admin'
    }
  }
};

// 2. é¿å…æ·±åº¦åµŒå¥—
const badStateStructure = {
  users: [
    {
      id: '1',
      profile: {
        personal: {
          name: 'John',
          address: {
            street: '123 Main St',
            city: 'New York'
          }
        }
      }
    }
  ]
};

// 3. ä½¿ç”¨é€‰æ‹©å™¨ä¼˜åŒ–æ€§èƒ½
import { createSelector } from '@reduxjs/toolkit';

const selectUsers = (state) => state.users.byId;
const selectUserIds = (state) => state.users.allIds;
const selectActiveFilter = (state) => state.ui.filters.status;

const selectActiveUsers = createSelector(
  [selectUsers, selectUserIds, selectActiveFilter],
  (users, userIds, activeFilter) => {
    return userIds
      .map(id => users[id])
      .filter(user => user.status === activeFilter);
  }
);
```

## æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†

<Callout type="info">
æœåŠ¡ç«¯çŠ¶æ€ç®¡ç†ä¸“æ³¨äºå¤„ç†å¼‚æ­¥æ•°æ®è·å–ã€ç¼“å­˜ã€åŒæ­¥ç­‰é—®é¢˜ï¼Œä¸å®¢æˆ·ç«¯çŠ¶æ€ç®¡ç†æœ‰ä¸åŒçš„å…³æ³¨ç‚¹ã€‚
</Callout>

### React Query / TanStack Query

```javascript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// æ•°æ®è·å–
function UserProfile({ userId }) {
  const {
    data: user,
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿå†…æ•°æ®è¢«è®¤ä¸ºæ˜¯æ–°é²œçš„
    cacheTime: 10 * 60 * 1000, // 10åˆ†é’Ÿåæ¸…é™¤ç¼“å­˜
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{user.name}</div>;
}

// æ•°æ®å˜æ›´
function UpdateUserForm({ userId }) {
  const queryClient = useQueryClient();

  const updateUserMutation = useMutation({
    mutationFn: updateUser,
    onSuccess: (data) => {
      // æ›´æ–°ç¼“å­˜
      queryClient.setQueryData(['user', userId], data);

      // æˆ–è€…é‡æ–°è·å–
      queryClient.invalidateQueries(['user', userId]);

      // ä¹è§‚æ›´æ–°
      queryClient.setQueryData(['users'], (oldData) => {
        return oldData.map(user =>
          user.id === userId ? { ...user, ...data } : user
        );
      });
    },
    onError: (error) => {
      console.error('Update failed:', error);
    }
  });

  const handleSubmit = (formData) => {
    updateUserMutation.mutate({ userId, ...formData });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* è¡¨å•å†…å®¹ */}
      <button
        type="submit"
        disabled={updateUserMutation.isLoading}
      >
        {updateUserMutation.isLoading ? 'Updating...' : 'Update'}
      </button>
    </form>
  );
}
```

### SWR

```javascript
import useSWR, { mutate } from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserList() {
  const { data: users, error, isLoading } = useSWR('/api/users', fetcher, {
    refreshInterval: 30000, // 30ç§’è‡ªåŠ¨åˆ·æ–°
    revalidateOnFocus: true, // çª—å£è·å¾—ç„¦ç‚¹æ—¶é‡æ–°éªŒè¯
    revalidateOnReconnect: true, // ç½‘ç»œé‡è¿æ—¶é‡æ–°éªŒè¯
    dedupingInterval: 2000, // 2ç§’å†…çš„é‡å¤è¯·æ±‚ä¼šè¢«å»é‡
  });

  const deleteUser = async (userId) => {
    // ä¹è§‚æ›´æ–°
    const updatedUsers = users.filter(user => user.id !== userId);
    mutate('/api/users', updatedUsers, false);

    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      // é‡æ–°éªŒè¯æ•°æ®
      mutate('/api/users');
    } catch (error) {
      // å›æ»šä¹è§‚æ›´æ–°
      mutate('/api/users');
      console.error('Delete failed:', error);
    }
  };

  if (error) return <div>Failed to load users</div>;
  if (isLoading) return <div>Loading...</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => deleteUser(user.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Apollo Client (GraphQL)

```javascript
import { useQuery, useMutation, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers($filter: UserFilter) {
    users(filter: $filter) {
      id
      name
      email
      status
    }
  }
`;

const UPDATE_USER = gql`
  mutation UpdateUser($id: ID!, $input: UserInput!) {
    updateUser(id: $id, input: $input) {
      id
      name
      email
      status
    }
  }
`;

function UserManagement() {
  const { loading, error, data, refetch } = useQuery(GET_USERS, {
    variables: { filter: { status: 'ACTIVE' } },
    pollInterval: 30000, // 30ç§’è½®è¯¢
    errorPolicy: 'partial', // éƒ¨åˆ†æ•°æ®ä¹Ÿæ˜¾ç¤º
    fetchPolicy: 'cache-and-network' // å…ˆæ˜¾ç¤ºç¼“å­˜ï¼Œç„¶åç½‘ç»œè¯·æ±‚
  });

  const [updateUser] = useMutation(UPDATE_USER, {
    update(cache, { data: { updateUser } }) {
      // æ›´æ–°Apolloç¼“å­˜
      cache.modify({
        fields: {
          users(existingUsers = []) {
            return existingUsers.map(user =>
              user.__ref === cache.identify(updateUser)
                ? updateUser
                : user
            );
          }
        }
      });
    },
    optimisticResponse: (variables) => ({
      updateUser: {
        __typename: 'User',
        id: variables.id,
        ...variables.input
      }
    })
  });

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {data.users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onUpdate={updateUser}
        />
      ))}
    </div>
  );
}
```

---

<Callout type="success">
é€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆéœ€è¦ç»¼åˆè€ƒè™‘åº”ç”¨è§„æ¨¡ã€å›¢é˜Ÿç»éªŒã€æ€§èƒ½è¦æ±‚ç­‰å¤šä¸ªå› ç´ ã€‚æ²¡æœ‰é“¶å¼¹ï¼Œåªæœ‰æœ€é€‚åˆçš„è§£å†³æ–¹æ¡ˆã€‚
</Callout>

import { Callout } from 'nextra/components'

# 10. 状态管理深入

## 📋 目录

- [状态管理概念和模式](#状态管理概念和模式)
- [Redux生态系统](#redux生态系统)
- [现代状态管理方案](#现代状态管理方案)
- [状态管理方案对比](#状态管理方案对比)
- [最佳实践和选择指南](#最佳实践和选择指南)
- [服务端状态管理](#服务端状态管理)

## 状态管理概念和模式

<Callout type="info">
状态管理是现代前端应用的核心问题，选择合适的状态管理方案能够显著提升开发效率和应用性能。
</Callout>

### 状态管理的核心概念

#### 状态分类

| 状态类型 | 作用域 | 示例 | 管理方式 |
|----------|--------|------|----------|
| **本地状态** | 组件内部 | 表单数据、模态框状态 | useState, useReducer |
| **全局状态** | 应用级别 | 用户信息、主题设置 | Redux, Zustand, Context |
| **服务端状态** | 远程数据 | API数据、缓存 | React Query, SWR |
| **URL状态** | 路由相关 | 页面参数、查询条件 | React Router, Next.js |

#### 状态管理挑战

| 挑战 | 问题描述 | 解决方案 |
|------|----------|----------|
| **状态同步** | 多组件共享状态 | 全局状态管理 |
| **状态持久化** | 页面刷新后保持状态 | localStorage, sessionStorage |
| **状态预测性** | 状态变化可追踪 | 不可变更新、时间旅行调试 |
| **性能优化** | 避免不必要重渲染 | 选择器、记忆化 |
| **开发体验** | 调试和开发工具 | DevTools、类型安全 |

#### 单向数据流模式

```
Action → Dispatcher → Store → View → Action
```

这是现代状态管理的核心模式，确保数据流向可预测。

### 状态管理模式

#### 常见状态管理模式

| 模式 | 特点 | 适用场景 | 代表方案 |
|------|------|----------|----------|
| **Flux模式** | 单向数据流，可预测 | 复杂应用状态管理 | Redux, Zustand |
| **Observer模式** | 观察者订阅状态变化 | 响应式更新 | MobX, Vue |
| **发布订阅模式** | 事件驱动的状态更新 | 松耦合组件通信 | EventBus |
| **原子化模式** | 状态拆分为最小单位 | 细粒度状态管理 | Jotai, Recoil |

#### 简化的状态管理实现

```javascript
// 简单的状态管理器
class SimpleStateManager {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = [];
  }

  getState() {
    return this.state;
  }

  setState(updates) {
    this.state = { ...this.state, ...updates };
    this.listeners.forEach(listener => listener(this.state));
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
}

// 使用示例
const store = new SimpleStateManager({ count: 0 });

store.subscribe((state) => {
  console.log('State updated:', state);
});

store.setState({ count: 1 }); // 触发更新
```

## Redux生态系统

### Redux Toolkit现代化实践

<Callout type="warning">
Redux Toolkit是Redux官方推荐的现代化工具集，大大简化了Redux的使用复杂度。
</Callout>

#### Redux Toolkit核心特性

| 特性 | 说明 | 优势 |
|------|------|------|
| **createSlice** | 自动生成actions和reducers | 减少样板代码 |
| **createAsyncThunk** | 处理异步逻辑 | 统一异步状态管理 |
| **Immer集成** | 支持"可变"更新语法 | 简化状态更新 |
| **RTK Query** | 数据获取和缓存 | 替代手写API逻辑 |

#### 简化的Redux Toolkit示例

```javascript
// 1. 创建状态切片
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// 异步thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (params) => {
    const response = await fetch(`/api/users?${new URLSearchParams(params)}`);
    return response.json();
  }
);

// 状态切片
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export const { clearError } = usersSlice.actions;
export default usersSlice.reducer;
```

#### Redux Toolkit最佳实践

| 实践 | 说明 | 示例 |
|------|------|------|
| **状态规范化** | 使用扁平化结构存储数据 | `{ byId: {}, allIds: [] }` |
| **选择器复用** | 使用createSelector创建记忆化选择器 | `selectFilteredUsers` |
| **异步处理** | 使用createAsyncThunk处理异步逻辑 | API调用、数据获取 |
| **中间件配置** | 合理配置开发和生产环境中间件 | logger、devTools |

#### Store配置示例

```javascript
// 完整的store配置
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';

const store = configureStore({
  reducer: {
    users: usersReducer,
    auth: authReducer,
    settings: settingsReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    }),
  devTools: process.env.NODE_ENV !== 'production'
});

const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Redux error:', error);
    // 可以发送错误到监控服务
    throw error;
  }
};

// 5. React组件中使用
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

function UserList() {
  const dispatch = useDispatch();
  const users = useSelector(selectFilteredUsers);
  const loading = useSelector(selectUsersLoading);
  const error = useSelector(selectUsersError);
  const filters = useSelector(selectUsersFilters);
  const pagination = useSelector(selectUsersPagination);
  const stats = useSelector(selectUsersStats);
  
  useEffect(() => {
    dispatch(fetchUsers({ 
      page: pagination.page, 
      limit: pagination.limit,
      ...filters 
    }));
  }, [dispatch, pagination.page, pagination.limit, filters]);
  
  const handleFilterChange = (newFilters) => {
    dispatch(setFilters(newFilters));
  };
  
  const handlePageChange = (page) => {
    dispatch(setPagination({ page }));
  };
  
  const handleCreateUser = (userData) => {
    dispatch(createUser(userData));
  };
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <UserStats stats={stats} />
      <UserFilters filters={filters} onChange={handleFilterChange} />
      <UserTable users={users} />
      <Pagination 
        current={pagination.page}
        total={pagination.total}
        pageSize={pagination.limit}
        onChange={handlePageChange}
      />
    </div>
  );
}
```

## 现代状态管理方案

### Zustand - 轻量级状态管理

#### Zustand核心特性

| 特性 | 说明 | 优势 |
|------|------|------|
| **轻量级** | 包体积小，API简洁 | 学习成本低，性能好 |
| **TypeScript友好** | 原生TypeScript支持 | 类型安全，开发体验好 |
| **中间件丰富** | persist、devtools、immer等 | 功能扩展灵活 |
| **无样板代码** | 不需要providers和reducers | 代码简洁 |

#### 基础用法示例

```javascript
// 1. 创建简单store
import { create } from 'zustand';

const useUserStore = create((set, get) => ({
  // 状态
  users: [],
  loading: false,

  // 动作
  addUser: (user) => set((state) => ({
    users: [...state.users, user]
  })),

  removeUser: (id) => set((state) => ({
    users: state.users.filter(u => u.id !== id)
  })),

  // 异步动作
  fetchUsers: async () => {
    set({ loading: true });
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      set({ users, loading: false });
    } catch (error) {
      set({ loading: false });
    }
  }
}));
```

#### 中间件使用

```javascript
// 2. 使用中间件增强store
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

const useUserStore = create()(
  devtools(
    persist(
      immer((set) => ({
        users: [],
        addUser: (user) => set((state) => {
          state.users.push(user); // 使用immer可以直接"修改"
        }),
        setFilters: (filters) => set((state) => {
          Object.assign(state.filters, filters);
        })
      })),
      { name: 'user-store' } // 持久化配置
    ),
    { name: 'user-store' } // devtools配置
  )
);
```

#### 分片store模式

```javascript
// 3. 大型应用的分片模式
const createUserSlice = (set, get) => ({
  users: [],
  addUser: (user) => set((state) => ({ users: [...state.users, user] }))
});

const createAuthSlice = (set, get) => ({
  user: null,
  login: async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    const { user, token } = await response.json();
    set({ user, token });
  }
});

const useAppStore = create()(
  devtools((...args) => ({
    ...createUserSlice(...args),
    ...createAuthSlice(...args)
  }))
);
```

#### 组件中使用

```javascript
// 4. 在React组件中使用
import { useShallow } from 'zustand/react/shallow';

function UserComponent() {
  // 选择特定状态，避免不必要的重渲染
  const { users, addUser } = useUserStore(
    useShallow((state) => ({
      users: state.users,
      addUser: state.addUser
    }))
  );

  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
      <button onClick={() => addUser({ id: Date.now(), name: 'New User' })}>
        Add User
      </button>
    </div>
  );
}
    }))
  );
  
  // 订阅特定状态变化
  useEffect(() => {
    const unsubscribe = useUserStore.subscribe(
      (state) => state.users.length,
      (userCount) => {
        console.log('用户数量变化:', userCount);
      }
    );
    
    return unsubscribe;
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onRemove={() => removeUser(user.id)}
        />
      ))}
    </div>
  );
}
```

### Jotai - 原子化状态管理

#### Jotai核心概念

| 概念 | 说明 | 特点 |
|------|------|------|
| **Atom** | 状态的最小单位 | 可读可写，自动依赖追踪 |
| **Derived Atom** | 派生状态 | 基于其他atom计算得出 |
| **Write-only Atom** | 只写原子 | 用于处理副作用和异步操作 |
| **Provider** | 状态作用域 | 可选，用于隔离状态 |

#### 基础用法示例

```javascript
// 1. 定义原子
import { atom } from 'jotai';

// 基础原子
export const usersAtom = atom([]);
export const loadingAtom = atom(false);
export const searchAtom = atom('');

// 派生原子
export const filteredUsersAtom = atom((get) => {
  const users = get(usersAtom);
  const search = get(searchAtom);

  return users.filter(user =>
    user.name.toLowerCase().includes(search.toLowerCase())
  );
});

// 异步原子
export const fetchUsersAtom = atom(
  null, // 读取值（不使用）
  async (get, set) => { // 写入函数
    set(loadingAtom, true);
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      set(usersAtom, users);
    } finally {
      set(loadingAtom, false);
    }
  }
);
```

#### 组件中使用

```javascript
// 2. 在组件中使用原子
import { useAtom, useAtomValue, useSetAtom } from 'jotai';

function UserList() {
  // 只读取值
  const filteredUsers = useAtomValue(filteredUsersAtom);
  const loading = useAtomValue(loadingAtom);

  // 只设置值
  const fetchUsers = useSetAtom(fetchUsersAtom);

  // 读取和设置
  const [search, setSearch] = useAtom(searchAtom);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="搜索用户..."
      />
      {loading ? (
        <div>Loading...</div>
      ) : (
        filteredUsers.map(user => (
          <div key={user.id}>{user.name}</div>
        ))
      )}
    </div>
  );
}
```

#### 高级特性

```javascript
// 3. 持久化和工具函数
import { atomWithStorage, RESET } from 'jotai/utils';

// 持久化原子
export const themeAtom = atomWithStorage('theme', 'light');

// 重置原子
export const resetUsersAtom = atom(null, (get, set) => {
  set(usersAtom, RESET);
  set(searchAtom, RESET);
});
```

#### Jotai vs 其他方案

| 特性 | Jotai | Zustand | Redux |
|------|-------|---------|-------|
| **心智模型** | 原子化 | 单一store | 单一store |
| **样板代码** | 最少 | 少 | 多 |
| **性能** | 优秀 | 优秀 | 良好 |
| **适用场景** | 复杂状态依赖 | 简单全局状态 | 大型应用 |

## 状态管理方案对比

### 方案选择矩阵

| 特性 | Redux Toolkit | Zustand | Jotai | Context API | Valtio |
|------|---------------|---------|-------|-------------|--------|
| **学习曲线** | 中等 | 简单 | 中等 | 简单 | 简单 |
| **包大小** | 大 | 小 | 小 | 无 | 小 |
| **TypeScript支持** | 优秀 | 优秀 | 优秀 | 良好 | 优秀 |
| **开发工具** | 优秀 | 良好 | 良好 | 无 | 良好 |
| **性能** | 良好 | 优秀 | 优秀 | 差 | 优秀 |
| **生态系统** | 丰富 | 中等 | 中等 | 丰富 | 小 |
| **适用场景** | 大型应用 | 中小型应用 | 复杂状态 | 简单状态 | 响应式应用 |

### 选择指南

#### 基于应用规模的选择

| 应用规模 | 推荐方案 | 理由 | 适用场景 |
|----------|----------|------|----------|
| **小型** | useState + useContext | 简单够用，避免过度工程化 | 个人项目、原型开发 |
| **中型** | Zustand | 轻量级，易于使用，性能良好 | 初创公司、中小团队 |
| **大型** | Redux Toolkit | 成熟生态，强大开发工具 | 企业级应用、大团队 |

#### 基于团队经验的选择

| 团队经验 | 推荐方案 | 学习成本 | 上手时间 |
|----------|----------|----------|----------|
| **初级** | Zustand | 低 | 1-2天 |
| **中级** | Jotai 或 Zustand | 中等 | 3-5天 |
| **高级** | Redux Toolkit | 高 | 1-2周 |

#### 基于性能要求的选择

| 性能要求 | 推荐方案 | 特点 | 适用场景 |
|----------|----------|------|----------|
| **一般** | 任何方案 | 满足基本需求 | 常规业务应用 |
| **高性能** | Jotai 或 Valtio | 细粒度更新，精确控制重渲染 | 数据密集型应用 |

#### 快速决策指南

**选择流程**：
1. **项目规模小** → useState + useContext
2. **团队新手多** → Zustand
3. **需要高性能** → Jotai
4. **大型企业项目** → Redux Toolkit
5. **不确定时** → Zustand（平衡选择）

## 最佳实践和选择指南

<Callout type="info">
选择状态管理方案需要考虑应用规模、团队经验、性能要求等多个维度。
</Callout>

### 选择决策树

#### 基于团队和项目特征的选择

| 项目特征 | 团队规模 | 推荐方案 | 备选方案 |
|----------|----------|----------|----------|
| **简单应用** | ≤3人 | useState + useContext | Zustand |
| **中型应用** | 4-10人 | Zustand | Jotai, Valtio |
| **复杂应用** | >10人 | Redux Toolkit | MobX |
| **高性能要求** | 任意 | Jotai, Valtio | MobX |

### 最佳实践原则

#### 状态结构设计原则

| 原则 | 说明 | 示例 |
|------|------|------|
| **扁平化结构** | 避免深度嵌套，便于更新和查询 | `{ byId: {}, allIds: [] }` |
| **状态分离** | 区分UI状态和业务状态 | `{ data: {}, ui: {} }` |
| **规范化数据** | 使用ID作为键值，避免重复数据 | `users.byId['123']` |
| **单一职责** | 每个状态片段只负责一个功能域 | 用户状态、认证状态分离 |

#### 性能优化技巧

```javascript
// ✅ 好的做法：使用选择器
const selectActiveUsers = createSelector(
  [selectUsers, selectFilters],
  (users, filters) => users.filter(u => u.status === filters.status)
);

// ❌ 避免：在组件中直接计算
function UserList() {
  const users = useSelector(state => state.users);
  const filters = useSelector(state => state.filters);

  // 每次渲染都会重新计算
  const activeUsers = users.filter(u => u.status === filters.status);
}
```

#### 状态更新模式

| 模式 | 适用场景 | 示例 |
|------|----------|------|
| **不可变更新** | Redux, 纯函数组件 | `{ ...state, users: [...state.users, newUser] }` |
| **可变更新** | Immer, MobX | `state.users.push(newUser)` |
| **原子更新** | Jotai, Recoil | `set(usersAtom, [...users, newUser])` |

## 服务端状态管理

<Callout type="info">
服务端状态管理专注于处理异步数据获取、缓存、同步等问题，与客户端状态管理有不同的关注点。
</Callout>

### React Query / TanStack Query

#### 核心特性

| 特性 | 说明 | 优势 |
|------|------|------|
| **自动缓存** | 智能缓存管理，减少重复请求 | 提升性能，减少网络开销 |
| **后台更新** | 数据过期时自动重新获取 | 保持数据新鲜度 |
| **乐观更新** | 先更新UI，再同步服务器 | 提升用户体验 |
| **错误重试** | 自动重试失败的请求 | 提高可靠性 |

#### 基础用法

```javascript
// 数据查询
import { useQuery } from '@tanstack/react-query';

function UserProfile({ userId }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5分钟缓存
    retry: 3
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user.name}</div>;
}

// 数据变更
import { useMutation, useQueryClient } from '@tanstack/react-query';

function UpdateUserForm({ userId }) {
  const queryClient = useQueryClient();

  const updateUser = useMutation({
    mutationFn: (userData) => updateUserAPI(userData),
    onSuccess: (data) => {
      // 更新缓存
      queryClient.setQueryData(['user', userId], data);
      // 重新获取相关数据
      queryClient.invalidateQueries(['users']);
    }
  });

  return (
    <button
      onClick={() => updateUser.mutate({ name: 'New Name' })}
      disabled={updateUser.isLoading}
    >
      {updateUser.isLoading ? 'Updating...' : 'Update'}
    </button>
  );
}
```

#### 配置选项

| 选项 | 默认值 | 说明 |
|------|--------|------|
| `staleTime` | 0 | 数据被认为过期的时间 |
| `cacheTime` | 5分钟 | 缓存保留时间 |
| `retry` | 3 | 失败重试次数 |
| `refetchOnWindowFocus` | true | 窗口聚焦时重新获取 |

### SWR

#### SWR特性对比

| 特性 | SWR | React Query | 说明 |
|------|-----|-------------|------|
| **包大小** | 更小 | 较大 | SWR更轻量 |
| **API设计** | 简洁 | 功能丰富 | SWR更易上手 |
| **缓存策略** | 基础 | 高级 | React Query更灵活 |
| **开发工具** | 基础 | 完善 | React Query工具更强 |

#### 基础用法

```javascript
import useSWR, { mutate } from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserList() {
  const { data: users, error, isLoading } = useSWR('/api/users', fetcher, {
    refreshInterval: 30000, // 30秒自动刷新
    revalidateOnFocus: true, // 窗口聚焦时重新验证
    dedupingInterval: 2000, // 去重间隔
  });

  const deleteUser = async (userId) => {
    // 乐观更新
    const updatedUsers = users.filter(user => user.id !== userId);
    mutate('/api/users', updatedUsers, false);

    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      mutate('/api/users'); // 重新验证
    } catch (error) {
      mutate('/api/users'); // 回滚
    }
  };

  if (error) return <div>Failed to load</div>;
  if (isLoading) return <div>Loading...</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => deleteUser(user.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Apollo Client (GraphQL)

#### Apollo Client优势

| 特性 | 说明 | 适用场景 |
|------|------|----------|
| **GraphQL原生支持** | 完整的GraphQL客户端解决方案 | GraphQL API项目 |
| **智能缓存** | 基于字段级别的缓存系统 | 复杂数据关系 |
| **实时订阅** | 支持GraphQL订阅 | 实时数据更新 |
| **开发工具** | 强大的Apollo DevTools | 调试和性能分析 |

#### 基础用法

```javascript
import { useQuery, useMutation, gql } from '@apollo/client';

// 定义查询
const GET_USERS = gql`
  query GetUsers($filter: UserFilter) {
    users(filter: $filter) {
      id
      name
      email
      status
    }
  }
`;

// 定义变更
const UPDATE_USER = gql`
  mutation UpdateUser($id: ID!, $input: UserInput!) {
    updateUser(id: $id, input: $input) {
      id
      name
      email
      status
    }
  }
`;

function UserManagement() {
  // 查询数据
  const { loading, error, data } = useQuery(GET_USERS, {
    variables: { filter: { status: 'ACTIVE' } },
    pollInterval: 30000, // 轮询
    fetchPolicy: 'cache-and-network'
  });

  // 变更数据
  const [updateUser] = useMutation(UPDATE_USER, {
    update(cache, { data: { updateUser } }) {
      // 更新缓存
      cache.modify({
        fields: {
          users(existingUsers = []) {
            return existingUsers.map(user =>
              user.__ref === cache.identify(updateUser) ? updateUser : user
            );
          }
        }
      });
    }
  });

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {data.users.map(user => (
        <UserCard key={user.id} user={user} onUpdate={updateUser} />
      ))}
    </div>
  );
}
```

#### 服务端状态管理方案对比

| 方案 | 适用场景 | 学习成本 | 生态系统 |
|------|----------|----------|----------|
| **React Query** | REST API，复杂缓存需求 | 中等 | 丰富 |
| **SWR** | 简单数据获取，轻量级项目 | 低 | 中等 |
| **Apollo Client** | GraphQL项目 | 高 | 完善 |
| **Relay** | 大型GraphQL应用 | 很高 | Facebook生态 |

---

<Callout type="success">
选择合适的状态管理方案需要综合考虑应用规模、团队经验、性能要求等多个因素。没有银弹，只有最适合的解决方案。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [Redux 官方文档](https://redux.js.org/) - Redux状态管理库
- [MobX 官方文档](https://mobx.js.org/) - MobX响应式状态管理
- [Zustand 文档](https://github.com/pmndrs/zustand) - 轻量级状态管理
- [Recoil 官方文档](https://recoiljs.org/) - Facebook实验性状态管理

### 🎓 优质教程
- [Redux 官方教程](https://redux.js.org/tutorials/essentials/part-1-overview-concepts) - Redux基础教程
- [MobX 入门指南](https://mobx.js.org/getting-started) - MobX快速入门
- [状态管理模式](https://vuex.vuejs.org/zh/guide/) - Vuex状态管理模式

### 🛠️ 实践项目
- [Redux Examples](https://github.com/reduxjs/redux/tree/master/examples) - Redux官方示例
- [MobX Examples](https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite/examples) - MobX示例项目
- [State Management Patterns](https://github.com/topics/state-management) - 状态管理模式集合

### 🔧 开发工具
- [Redux DevTools](https://github.com/reduxjs/redux-devtools) - Redux调试工具
- [MobX DevTools](https://github.com/mobxjs/mobx-devtools) - MobX开发工具
- [React Developer Tools](https://react.dev/learn/react-developer-tools) - React状态调试
- [Vue DevTools](https://devtools.vuejs.org/) - Vue状态调试工具

### 📝 深入阅读
- [You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) - Redux使用场景思考
- [State Management Patterns](https://blog.logrocket.com/state-management-patterns-in-react-ecosystem/) - React状态管理模式
- [Modern State Management](https://kentcdodds.com/blog/application-state-management-with-react) - 现代状态管理思考

<Callout type="tip">
💡 **学习建议**：建议从React内置状态管理开始，然后学习Redux理解状态管理原理，接着探索MobX等其他方案，最后根据项目需求选择合适的方案。
</Callout>

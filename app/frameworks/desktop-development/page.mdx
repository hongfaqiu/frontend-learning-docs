import { Callout } from 'nextra/components'

# 13. 桌面应用开发

## 📋 目录

- [桌面应用开发概览](#桌面应用开发概览)
- [Electron深入开发](#electron深入开发)
- [Tauri现代化方案](#tauri现代化方案)
- [性能优化策略](#性能优化策略)
- [安全性和最佳实践](#安全性和最佳实践)
- [打包和分发](#打包和分发)

## 🖥️ 桌面应用开发概览

<Callout type="info">
桌面应用开发让Web技术能够创建原生桌面应用，为前端开发者提供了更广阔的应用场景。
</Callout>

### 桌面应用技术栈对比

```javascript
// 桌面应用开发技术对比
const desktopTechnologies = {
  // Electron
  electron: {
    技术栈: 'Chromium + Node.js',
    开发语言: 'JavaScript/TypeScript + HTML/CSS',
    优势: [
      '成熟稳定的生态系统',
      '丰富的API和插件',
      '跨平台支持完善',
      '大量成功案例'
    ],
    劣势: [
      '应用体积较大',
      '内存占用高',
      '性能相对较差'
    ],
    适用场景: '复杂的桌面应用',
    知名应用: ['VS Code', 'Discord', 'Slack', 'WhatsApp']
  },
  
  // Tauri
  tauri: {
    技术栈: 'Rust + WebView',
    开发语言: 'Rust + JavaScript/TypeScript',
    优势: [
      '应用体积小',
      '内存占用低',
      '性能优秀',
      '安全性高'
    ],
    劣势: [
      '生态相对较新',
      '需要学习Rust',
      'WebView兼容性问题'
    ],
    适用场景: '轻量级高性能应用',
    知名应用: ['Clash Verge', 'Pake']
  },
  
  // Flutter Desktop
  flutter: {
    技术栈: 'Flutter + Dart',
    开发语言: 'Dart',
    优势: [
      '统一的UI框架',
      '高性能渲染',
      '跨平台一致性'
    ],
    劣势: [
      '学习成本高',
      '生态相对较小',
      'Web集成复杂'
    ],
    适用场景: '需要统一UI的跨平台应用'
  },
  
  // .NET MAUI
  maui: {
    技术栈: '.NET + C#',
    开发语言: 'C#/F#',
    优势: [
      '微软生态支持',
      '企业级开发',
      '性能优秀'
    ],
    劣势: [
      '主要面向Windows',
      '学习成本高'
    ],
    适用场景: '企业级Windows应用'
  }
};

// 技术选择决策树
function chooseDesktopTechnology(requirements) {
  const {
    teamSkills,
    performanceRequirements,
    appComplexity,
    targetPlatforms,
    developmentTime,
    appSize
  } = requirements;
  
  // Web技术栈团队
  if (teamSkills.includes('web')) {
    // 性能要求高且应用体积敏感
    if (performanceRequirements === 'high' && appSize === 'small') {
      return {
        recommendation: 'Tauri',
        reason: '高性能、小体积，但需要学习Rust'
      };
    }
    
    // 复杂应用或快速开发
    if (appComplexity === 'high' || developmentTime === 'short') {
      return {
        recommendation: 'Electron',
        reason: '成熟生态，开发效率高'
      };
    }
  }
  
  // 移动端经验丰富
  if (teamSkills.includes('flutter')) {
    return {
      recommendation: 'Flutter Desktop',
      reason: '统一技术栈，跨平台一致性'
    };
  }
  
  // 企业级.NET团队
  if (teamSkills.includes('dotnet')) {
    return {
      recommendation: '.NET MAUI',
      reason: '企业级支持，Windows生态优势'
    };
  }
  
  // 默认推荐
  return {
    recommendation: 'Electron',
    reason: '最成熟的Web到桌面解决方案'
  };
}
```

## ⚡ Electron深入开发

### Electron架构和进程通信

```javascript
// 1. 主进程 (main.js)
const { app, BrowserWindow, ipcMain, Menu, dialog, shell } = require('electron');
const path = require('path');
const isDev = process.env.NODE_ENV === 'development';

class ElectronApp {
  constructor() {
    this.mainWindow = null;
    this.setupApp();
  }
  
  setupApp() {
    // 应用准备就绪
    app.whenReady().then(() => {
      this.createMainWindow();
      this.setupMenu();
      this.setupIPC();
      
      // macOS特殊处理
      app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
          this.createMainWindow();
        }
      });
    });
    
    // 所有窗口关闭
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });
    
    // 应用退出前
    app.on('before-quit', (event) => {
      // 保存应用状态
      this.saveAppState();
    });
  }
  
  createMainWindow() {
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false, // 安全考虑
        contextIsolation: true, // 启用上下文隔离
        enableRemoteModule: false, // 禁用remote模块
        preload: path.join(__dirname, 'preload.js') // 预加载脚本
      },
      titleBarStyle: 'hiddenInset', // macOS样式
      show: false // 先隐藏，加载完成后显示
    });
    
    // 加载应用
    if (isDev) {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, '../build/index.html'));
    }
    
    // 窗口事件
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow.show();
      
      // 恢复窗口状态
      this.restoreWindowState();
    });
    
    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
    
    // 阻止新窗口打开
    this.mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: 'deny' };
    });
  }
  
  setupMenu() {
    const template = [
      {
        label: '文件',
        submenu: [
          {
            label: '新建',
            accelerator: 'CmdOrCtrl+N',
            click: () => {
              this.mainWindow.webContents.send('menu-new-file');
            }
          },
          {
            label: '打开',
            accelerator: 'CmdOrCtrl+O',
            click: async () => {
              const result = await dialog.showOpenDialog(this.mainWindow, {
                properties: ['openFile'],
                filters: [
                  { name: 'Text Files', extensions: ['txt', 'md'] },
                  { name: 'All Files', extensions: ['*'] }
                ]
              });
              
              if (!result.canceled) {
                this.mainWindow.webContents.send('menu-open-file', result.filePaths[0]);
              }
            }
          },
          { type: 'separator' },
          {
            label: '退出',
            accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
            click: () => {
              app.quit();
            }
          }
        ]
      },
      {
        label: '编辑',
        submenu: [
          { role: 'undo', label: '撤销' },
          { role: 'redo', label: '重做' },
          { type: 'separator' },
          { role: 'cut', label: '剪切' },
          { role: 'copy', label: '复制' },
          { role: 'paste', label: '粘贴' }
        ]
      },
      {
        label: '视图',
        submenu: [
          { role: 'reload', label: '重新加载' },
          { role: 'forceReload', label: '强制重新加载' },
          { role: 'toggleDevTools', label: '开发者工具' },
          { type: 'separator' },
          { role: 'resetZoom', label: '实际大小' },
          { role: 'zoomIn', label: '放大' },
          { role: 'zoomOut', label: '缩小' },
          { type: 'separator' },
          { role: 'togglefullscreen', label: '全屏' }
        ]
      }
    ];
    
    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
  }
  
  setupIPC() {
    // 文件操作
    ipcMain.handle('read-file', async (event, filePath) => {
      try {
        const fs = require('fs').promises;
        const content = await fs.readFile(filePath, 'utf8');
        return { success: true, content };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
    
    ipcMain.handle('write-file', async (event, filePath, content) => {
      try {
        const fs = require('fs').promises;
        await fs.writeFile(filePath, content, 'utf8');
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
    
    // 系统信息
    ipcMain.handle('get-system-info', () => {
      const os = require('os');
      return {
        platform: process.platform,
        arch: process.arch,
        version: process.getSystemVersion(),
        memory: os.totalmem(),
        cpus: os.cpus().length
      };
    });
    
    // 应用信息
    ipcMain.handle('get-app-info', () => {
      return {
        name: app.getName(),
        version: app.getVersion(),
        path: app.getAppPath()
      };
    });
    
    // 窗口控制
    ipcMain.handle('window-minimize', () => {
      this.mainWindow.minimize();
    });
    
    ipcMain.handle('window-maximize', () => {
      if (this.mainWindow.isMaximized()) {
        this.mainWindow.unmaximize();
      } else {
        this.mainWindow.maximize();
      }
    });
    
    ipcMain.handle('window-close', () => {
      this.mainWindow.close();
    });
  }
  
  saveAppState() {
    const bounds = this.mainWindow.getBounds();
    const isMaximized = this.mainWindow.isMaximized();
    
    // 保存到用户数据目录
    const Store = require('electron-store');
    const store = new Store();
    
    store.set('windowBounds', bounds);
    store.set('windowMaximized', isMaximized);
  }
  
  restoreWindowState() {
    const Store = require('electron-store');
    const store = new Store();
    
    const bounds = store.get('windowBounds');
    const isMaximized = store.get('windowMaximized');
    
    if (bounds) {
      this.mainWindow.setBounds(bounds);
    }
    
    if (isMaximized) {
      this.mainWindow.maximize();
    }
  }
}

// 启动应用
new ElectronApp();

// 2. 预加载脚本 (preload.js)
const { contextBridge, ipcRenderer } = require('electron');

// 暴露安全的API到渲染进程
contextBridge.exposeInMainWorld('electronAPI', {
  // 文件操作
  readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
  writeFile: (filePath, content) => ipcRenderer.invoke('write-file', filePath, content),
  
  // 系统信息
  getSystemInfo: () => ipcRenderer.invoke('get-system-info'),
  getAppInfo: () => ipcRenderer.invoke('get-app-info'),
  
  // 窗口控制
  minimizeWindow: () => ipcRenderer.invoke('window-minimize'),
  maximizeWindow: () => ipcRenderer.invoke('window-maximize'),
  closeWindow: () => ipcRenderer.invoke('window-close'),
  
  // 事件监听
  onMenuAction: (callback) => {
    ipcRenderer.on('menu-new-file', callback);
    ipcRenderer.on('menu-open-file', callback);
  },
  
  // 移除监听器
  removeAllListeners: (channel) => {
    ipcRenderer.removeAllListeners(channel);
  }
});

// 3. 渲染进程 (React组件)
import React, { useState, useEffect } from 'react';

function App() {
  const [systemInfo, setSystemInfo] = useState(null);
  const [appInfo, setAppInfo] = useState(null);
  const [fileContent, setFileContent] = useState('');
  
  useEffect(() => {
    // 获取系统信息
    window.electronAPI.getSystemInfo().then(setSystemInfo);
    window.electronAPI.getAppInfo().then(setAppInfo);
    
    // 监听菜单事件
    window.electronAPI.onMenuAction((event, data) => {
      if (event.type === 'menu-new-file') {
        setFileContent('');
      } else if (event.type === 'menu-open-file') {
        handleOpenFile(data);
      }
    });
    
    return () => {
      window.electronAPI.removeAllListeners('menu-new-file');
      window.electronAPI.removeAllListeners('menu-open-file');
    };
  }, []);
  
  const handleOpenFile = async (filePath) => {
    const result = await window.electronAPI.readFile(filePath);
    if (result.success) {
      setFileContent(result.content);
    } else {
      alert(`打开文件失败: ${result.error}`);
    }
  };
  
  const handleSaveFile = async () => {
    // 这里应该有文件路径选择逻辑
    const filePath = '/path/to/file.txt';
    const result = await window.electronAPI.writeFile(filePath, fileContent);
    
    if (result.success) {
      alert('文件保存成功');
    } else {
      alert(`保存文件失败: ${result.error}`);
    }
  };
  
  return (
    <div className="app">
      <header className="title-bar">
        <div className="title">我的Electron应用</div>
        <div className="window-controls">
          <button onClick={() => window.electronAPI.minimizeWindow()}>
            −
          </button>
          <button onClick={() => window.electronAPI.maximizeWindow()}>
            □
          </button>
          <button onClick={() => window.electronAPI.closeWindow()}>
            ×
          </button>
        </div>
      </header>
      
      <main className="content">
        <div className="info-panel">
          {systemInfo && (
            <div>
              <h3>系统信息</h3>
              <p>平台: {systemInfo.platform}</p>
              <p>架构: {systemInfo.arch}</p>
              <p>CPU核心: {systemInfo.cpus}</p>
            </div>
          )}
          
          {appInfo && (
            <div>
              <h3>应用信息</h3>
              <p>名称: {appInfo.name}</p>
              <p>版本: {appInfo.version}</p>
            </div>
          )}
        </div>
        
        <div className="editor">
          <textarea
            value={fileContent}
            onChange={(e) => setFileContent(e.target.value)}
            placeholder="在这里输入内容..."
          />
          <button onClick={handleSaveFile}>保存文件</button>
        </div>
      </main>
    </div>
  );
}

export default App;
```

### Electron性能优化

```javascript
// 1. 进程管理优化
class ProcessManager {
  constructor() {
    this.workers = new Map();
    this.maxWorkers = require('os').cpus().length;
  }
  
  // 创建工作进程
  createWorker(name, scriptPath) {
    if (this.workers.size >= this.maxWorkers) {
      throw new Error('已达到最大工作进程数');
    }
    
    const { fork } = require('child_process');
    const worker = fork(scriptPath);
    
    worker.on('message', (message) => {
      this.handleWorkerMessage(name, message);
    });
    
    worker.on('error', (error) => {
      console.error(`工作进程 ${name} 错误:`, error);
      this.restartWorker(name, scriptPath);
    });
    
    worker.on('exit', (code) => {
      console.log(`工作进程 ${name} 退出，代码: ${code}`);
      this.workers.delete(name);
    });
    
    this.workers.set(name, worker);
    return worker;
  }
  
  // 发送任务到工作进程
  sendTask(workerName, task) {
    const worker = this.workers.get(workerName);
    if (worker) {
      worker.send(task);
    }
  }
  
  // 重启工作进程
  restartWorker(name, scriptPath) {
    const worker = this.workers.get(name);
    if (worker) {
      worker.kill();
      this.workers.delete(name);
    }
    
    setTimeout(() => {
      this.createWorker(name, scriptPath);
    }, 1000);
  }
  
  // 清理所有工作进程
  cleanup() {
    for (const [name, worker] of this.workers) {
      worker.kill();
    }
    this.workers.clear();
  }
}

// 2. 内存管理
class MemoryManager {
  constructor() {
    this.memoryThreshold = 500 * 1024 * 1024; // 500MB
    this.checkInterval = 30000; // 30秒
    this.startMonitoring();
  }
  
  startMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage();
    }, this.checkInterval);
  }
  
  checkMemoryUsage() {
    const usage = process.memoryUsage();
    
    console.log('内存使用情况:', {
      rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,
      external: `${Math.round(usage.external / 1024 / 1024)}MB`
    });
    
    if (usage.heapUsed > this.memoryThreshold) {
      console.warn('内存使用过高，触发垃圾回收');
      this.forceGarbageCollection();
    }
  }
  
  forceGarbageCollection() {
    if (global.gc) {
      global.gc();
    } else {
      console.warn('垃圾回收不可用，请使用 --expose-gc 启动');
    }
  }
  
  // 清理大对象
  clearLargeObjects() {
    // 清理缓存
    if (global.imageCache) {
      global.imageCache.clear();
    }
    
    // 清理临时数据
    if (global.tempData) {
      global.tempData = null;
    }
  }
}

// 3. 渲染优化
class RenderOptimizer {
  constructor(webContents) {
    this.webContents = webContents;
    this.setupOptimizations();
  }
  
  setupOptimizations() {
    // 禁用不必要的功能
    this.webContents.session.setPermissionRequestHandler((webContents, permission, callback) => {
      const allowedPermissions = ['notifications', 'clipboard-read'];
      callback(allowedPermissions.includes(permission));
    });
    
    // 预加载关键资源
    this.preloadCriticalResources();
    
    // 设置缓存策略
    this.setupCacheStrategy();
  }
  
  preloadCriticalResources() {
    // 预加载字体
    this.webContents.executeJavaScript(`
      const fonts = [
        'Arial',
        'Helvetica',
        'Times New Roman'
      ];
      
      fonts.forEach(font => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'font';
        link.href = font;
        document.head.appendChild(link);
      });
    `);
  }
  
  setupCacheStrategy() {
    const { session } = this.webContents;
    
    // 设置缓存大小
    session.setCacheSize(100 * 1024 * 1024); // 100MB
    
    // 清理过期缓存
    setInterval(() => {
      session.clearCache();
    }, 24 * 60 * 60 * 1000); // 24小时
  }
  
  // 优化图片加载
  optimizeImageLoading() {
    this.webContents.executeJavaScript(`
      // 懒加载图片
      const images = document.querySelectorAll('img[data-src]');
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            imageObserver.unobserve(img);
          }
        });
      });
      
      images.forEach(img => imageObserver.observe(img));
    `);
  }
}

// 使用示例
const processManager = new ProcessManager();
const memoryManager = new MemoryManager();

// 在主进程中使用
app.whenReady().then(() => {
  const mainWindow = new BrowserWindow({
    // ... 窗口配置
  });
  
  const renderOptimizer = new RenderOptimizer(mainWindow.webContents);
  
  // 创建工作进程处理重任务
  processManager.createWorker('imageProcessor', './workers/imageProcessor.js');
  processManager.createWorker('dataProcessor', './workers/dataProcessor.js');
});

// 应用退出时清理
app.on('before-quit', () => {
  processManager.cleanup();
});
```

---

<Callout type="success">
桌面应用开发为Web技术提供了新的应用场景，通过合理的架构设计和性能优化，可以创建出媲美原生应用的桌面软件。
</Callout>

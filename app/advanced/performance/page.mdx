import { Callout } from 'nextra/components'

# 16. æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

## ğŸ“‹ ç›®å½•

- [æ€§èƒ½æŒ‡æ ‡å’ŒCore Web Vitals](#æ€§èƒ½æŒ‡æ ‡å’Œcore-web-vitals)
- [åŠ è½½æ€§èƒ½ä¼˜åŒ–](#åŠ è½½æ€§èƒ½ä¼˜åŒ–)
- [è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–](#è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–)
- [æ€§èƒ½ç›‘æ§å’Œåˆ†æ](#æ€§èƒ½ç›‘æ§å’Œåˆ†æ)
- [è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•](#è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•)
- [æ€§èƒ½é¢„ç®—å’ŒæŒç»­ä¼˜åŒ–](#æ€§èƒ½é¢„ç®—å’ŒæŒç»­ä¼˜åŒ–)

## æ€§èƒ½æŒ‡æ ‡å’ŒCore Web Vitals

<Callout type="info">
[Core Web Vitals](https://web.dev/vitals/)æ˜¯[Google](https://developers.google.com/web)æå‡ºçš„ç”¨æˆ·ä½“éªŒæ ¸å¿ƒæŒ‡æ ‡ï¼Œç›´æ¥å½±å“SEOæ’åå’Œç”¨æˆ·æ»¡æ„åº¦ã€‚
</Callout>

### Core Web Vitalsè¯¦è§£

```javascript
// 1. Core Web Vitalsç›‘æ§
class WebVitalsMonitor {
  constructor() {
    this.metrics = {
      LCP: null, // Largest Contentful Paint
      FID: null, // First Input Delay
      CLS: null, // Cumulative Layout Shift
      FCP: null, // First Contentful Paint
      TTFB: null // Time to First Byte
    };
    
    this.thresholds = {
      LCP: { good: 2500, poor: 4000 },
      FID: { good: 100, poor: 300 },
      CLS: { good: 0.1, poor: 0.25 },
      FCP: { good: 1800, poor: 3000 },
      TTFB: { good: 800, poor: 1800 }
    };
    
    this.initializeMonitoring();
  }
  
  initializeMonitoring() {
    // ä½¿ç”¨web-vitalsåº“ç›‘æ§
    import('web-vitals').then(({ onLCP, onFID, onCLS, onFCP, onTTFB }) => {
      onLCP(this.handleMetric.bind(this, 'LCP'));
      onFID(this.handleMetric.bind(this, 'FID'));
      onCLS(this.handleMetric.bind(this, 'CLS'));
      onFCP(this.handleMetric.bind(this, 'FCP'));
      onTTFB(this.handleMetric.bind(this, 'TTFB'));
    });
    
    // è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§
    this.monitorCustomMetrics();
  }
  
  handleMetric(name, metric) {
    this.metrics[name] = metric.value;
    
    const threshold = this.thresholds[name];
    const rating = this.getRating(metric.value, threshold);
    
    console.log(`${name}: ${metric.value}ms (${rating})`);
    
    // å‘é€åˆ°åˆ†ææœåŠ¡
    this.sendToAnalytics({
      name,
      value: metric.value,
      rating,
      id: metric.id,
      delta: metric.delta
    });
  }
  
  getRating(value, threshold) {
    if (value <= threshold.good) return 'good';
    if (value <= threshold.poor) return 'needs-improvement';
    return 'poor';
  }
  
  monitorCustomMetrics() {
    // ç›‘æ§èµ„æºåŠ è½½æ—¶é—´
    this.monitorResourceTiming();
    
    // ç›‘æ§é•¿ä»»åŠ¡
    this.monitorLongTasks();
    
    // ç›‘æ§å†…å­˜ä½¿ç”¨
    this.monitorMemoryUsage();
    
    // ç›‘æ§ç”¨æˆ·äº¤äº’
    this.monitorUserInteractions();
  }
  
  monitorResourceTiming() {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 1000) { // è¶…è¿‡1ç§’çš„èµ„æº
          console.warn('æ…¢èµ„æº:', {
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize
          });
          
          this.sendToAnalytics({
            type: 'slow-resource',
            name: entry.name,
            duration: entry.duration,
            size: entry.transferSize
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['resource'] });
  }
  
  monitorLongTasks() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          console.warn('é•¿ä»»åŠ¡æ£€æµ‹:', {
            duration: entry.duration,
            startTime: entry.startTime
          });
          
          this.sendToAnalytics({
            type: 'long-task',
            duration: entry.duration,
            startTime: entry.startTime
          });
        });
      });
      
      observer.observe({ entryTypes: ['longtask'] });
    }
  }
  
  monitorMemoryUsage() {
    if ('memory' in performance) {
      setInterval(() => {
        const memory = performance.memory;
        const usage = {
          used: memory.usedJSHeapSize,
          total: memory.totalJSHeapSize,
          limit: memory.jsHeapSizeLimit
        };
        
        // å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡80%æ—¶è­¦å‘Š
        if (usage.used / usage.limit > 0.8) {
          console.warn('å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜:', usage);
          
          this.sendToAnalytics({
            type: 'high-memory-usage',
            ...usage
          });
        }
      }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    }
  }
  
  monitorUserInteractions() {
    let interactionCount = 0;
    
    ['click', 'keydown', 'scroll'].forEach(eventType => {
      document.addEventListener(eventType, () => {
        interactionCount++;
      }, { passive: true });
    });
    
    // æ¯åˆ†é’ŸæŠ¥å‘Šäº¤äº’æ¬¡æ•°
    setInterval(() => {
      if (interactionCount > 0) {
        this.sendToAnalytics({
          type: 'user-interactions',
          count: interactionCount
        });
        interactionCount = 0;
      }
    }, 60000);
  }
  
  sendToAnalytics(data) {
    // å‘é€åˆ°Google Analytics
    if (typeof gtag !== 'undefined') {
      gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: data.name || data.type,
        value: Math.round(data.value || data.duration || 0)
      });
    }
    
    // å‘é€åˆ°è‡ªå®šä¹‰åˆ†ææœåŠ¡
    fetch('/api/analytics/performance', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...data,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent
      })
    }).catch(console.error);
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport() {
    return {
      metrics: this.metrics,
      timestamp: Date.now(),
      url: window.location.href,
      connection: this.getConnectionInfo(),
      device: this.getDeviceInfo()
    };
  }
  
  getConnectionInfo() {
    if ('connection' in navigator) {
      const conn = navigator.connection;
      return {
        effectiveType: conn.effectiveType,
        downlink: conn.downlink,
        rtt: conn.rtt,
        saveData: conn.saveData
      };
    }
    return null;
  }
  
  getDeviceInfo() {
    return {
      deviceMemory: navigator.deviceMemory || 'unknown',
      hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
      platform: navigator.platform,
      userAgent: navigator.userAgent
    };
  }
}

// 2. æ€§èƒ½é¢„ç®—ç®¡ç†
class PerformanceBudget {
  constructor() {
    this.budgets = {
      // èµ„æºå¤§å°é¢„ç®— (KB)
      javascript: 200,
      css: 100,
      images: 500,
      fonts: 100,
      total: 1000,
      
      // æ€§èƒ½æŒ‡æ ‡é¢„ç®— (ms)
      LCP: 2500,
      FID: 100,
      CLS: 0.1,
      
      // ç½‘ç»œè¯·æ±‚é¢„ç®—
      requests: 50
    };
    
    this.violations = [];
  }
  
  checkBudgets() {
    this.checkResourceBudgets();
    this.checkMetricBudgets();
    this.checkRequestBudgets();
    
    return this.violations;
  }
  
  checkResourceBudgets() {
    const resources = performance.getEntriesByType('resource');
    const sizes = {
      javascript: 0,
      css: 0,
      images: 0,
      fonts: 0,
      total: 0
    };
    
    resources.forEach(resource => {
      const size = resource.transferSize || 0;
      sizes.total += size;
      
      if (resource.name.includes('.js')) {
        sizes.javascript += size;
      } else if (resource.name.includes('.css')) {
        sizes.css += size;
      } else if (/\.(jpg|jpeg|png|gif|webp|svg)/.test(resource.name)) {
        sizes.images += size;
      } else if (/\.(woff|woff2|ttf|otf)/.test(resource.name)) {
        sizes.fonts += size;
      }
    });
    
    // æ£€æŸ¥é¢„ç®—è¿è§„
    Object.entries(sizes).forEach(([type, size]) => {
      const budget = this.budgets[type] * 1024; // è½¬æ¢ä¸ºå­—èŠ‚
      if (size > budget) {
        this.violations.push({
          type: 'resource-budget',
          category: type,
          actual: Math.round(size / 1024),
          budget: this.budgets[type],
          excess: Math.round((size - budget) / 1024)
        });
      }
    });
  }
  
  checkMetricBudgets() {
    const webVitalsMonitor = new WebVitalsMonitor();
    const metrics = webVitalsMonitor.metrics;
    
    Object.entries(metrics).forEach(([metric, value]) => {
      if (value && this.budgets[metric] && value > this.budgets[metric]) {
        this.violations.push({
          type: 'metric-budget',
          metric,
          actual: value,
          budget: this.budgets[metric],
          excess: value - this.budgets[metric]
        });
      }
    });
  }
  
  checkRequestBudgets() {
    const resources = performance.getEntriesByType('resource');
    const requestCount = resources.length;
    
    if (requestCount > this.budgets.requests) {
      this.violations.push({
        type: 'request-budget',
        actual: requestCount,
        budget: this.budgets.requests,
        excess: requestCount - this.budgets.requests
      });
    }
  }
  
  generateBudgetReport() {
    const violations = this.checkBudgets();
    
    return {
      passed: violations.length === 0,
      violations,
      summary: {
        totalViolations: violations.length,
        resourceViolations: violations.filter(v => v.type === 'resource-budget').length,
        metricViolations: violations.filter(v => v.type === 'metric-budget').length,
        requestViolations: violations.filter(v => v.type === 'request-budget').length
      }
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const webVitalsMonitor = new WebVitalsMonitor();
const performanceBudget = new PerformanceBudget();

// é¡µé¢åŠ è½½å®Œæˆåæ£€æŸ¥é¢„ç®—
window.addEventListener('load', () => {
  setTimeout(() => {
    const budgetReport = performanceBudget.generateBudgetReport();
    console.log('æ€§èƒ½é¢„ç®—æŠ¥å‘Š:', budgetReport);
    
    if (!budgetReport.passed) {
      console.warn('æ€§èƒ½é¢„ç®—è¿è§„:', budgetReport.violations);
    }
  }, 5000); // ç­‰å¾…5ç§’ç¡®ä¿æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ
});
```

## åŠ è½½æ€§èƒ½ä¼˜åŒ–

### èµ„æºä¼˜åŒ–ç­–ç•¥

```javascript
// 1. å›¾ç‰‡ä¼˜åŒ–ç®¡ç†å™¨
class ImageOptimizer {
  constructor() {
    this.lazyImages = new Set();
    this.imageCache = new Map();
    this.setupLazyLoading();
    this.setupImageFormats();
  }
  
  setupLazyLoading() {
    // Intersection Observeræ‡’åŠ è½½
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.loadImage(entry.target);
          this.observer.unobserve(entry.target);
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.01
    });
    
    // ç›‘å¬æ‰€æœ‰æ‡’åŠ è½½å›¾ç‰‡
    document.querySelectorAll('img[data-src]').forEach(img => {
      this.observer.observe(img);
    });
  }
  
  async loadImage(img) {
    const src = img.dataset.src;
    if (!src) return;
    
    try {
      // æ˜¾ç¤ºåŠ è½½å ä½ç¬¦
      img.style.filter = 'blur(5px)';
      
      // é¢„åŠ è½½å›¾ç‰‡
      const image = new Image();
      image.onload = () => {
        img.src = src;
        img.style.filter = 'none';
        img.classList.add('loaded');
      };
      
      image.onerror = () => {
        img.src = '/images/placeholder.jpg'; // é”™è¯¯å ä½å›¾
        img.classList.add('error');
      };
      
      // é€‰æ‹©æœ€ä½³æ ¼å¼
      const optimizedSrc = await this.getOptimizedImageSrc(src);
      image.src = optimizedSrc;
      
    } catch (error) {
      console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', error);
      img.src = '/images/placeholder.jpg';
    }
  }
  
  async getOptimizedImageSrc(originalSrc) {
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒçš„å›¾ç‰‡æ ¼å¼
    const supportedFormats = await this.getSupportedFormats();
    
    // æ ¹æ®è®¾å¤‡åƒç´ æ¯”é€‰æ‹©åˆé€‚å°ºå¯¸
    const devicePixelRatio = window.devicePixelRatio || 1;
    const width = Math.round(300 * devicePixelRatio); // å‡è®¾åŸºç¡€å®½åº¦300px
    
    // æ„å»ºä¼˜åŒ–åçš„å›¾ç‰‡URL
    let optimizedSrc = originalSrc;
    
    if (supportedFormats.webp) {
      optimizedSrc = originalSrc.replace(/\.(jpg|jpeg|png)$/, '.webp');
    } else if (supportedFormats.avif) {
      optimizedSrc = originalSrc.replace(/\.(jpg|jpeg|png)$/, '.avif');
    }
    
    // æ·»åŠ å°ºå¯¸å‚æ•°ï¼ˆå¦‚æœæ”¯æŒï¼‰
    if (optimizedSrc.includes('cloudinary') || optimizedSrc.includes('imagekit')) {
      optimizedSrc += `?w=${width}&q=auto&f=auto`;
    }
    
    return optimizedSrc;
  }
  
  async getSupportedFormats() {
    if (this.supportedFormats) {
      return this.supportedFormats;
    }
    
    const formats = {
      webp: false,
      avif: false,
      jpeg2000: false
    };
    
    // æ£€æµ‹WebPæ”¯æŒ
    formats.webp = await this.canUseFormat('data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA');
    
    // æ£€æµ‹AVIFæ”¯æŒ
    formats.avif = await this.canUseFormat('data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgABogQEAwgMg8f8D///8WfhwB8+ErK42A=');
    
    this.supportedFormats = formats;
    return formats;
  }
  
  canUseFormat(dataUri) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = dataUri;
    });
  }
  
  // é¢„åŠ è½½å…³é”®å›¾ç‰‡
  preloadCriticalImages(imageUrls) {
    imageUrls.forEach(url => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'image';
      link.href = url;
      document.head.appendChild(link);
    });
  }
  
  // å›¾ç‰‡å‹ç¼©ï¼ˆå®¢æˆ·ç«¯ï¼‰
  async compressImage(file, quality = 0.8, maxWidth = 1920) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = () => {
        // è®¡ç®—æ–°å°ºå¯¸
        let { width, height } = img;
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        // ç»˜åˆ¶å¹¶å‹ç¼©
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob(resolve, 'image/jpeg', quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }
}

// 2. ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
class CodeSplittingManager {
  constructor() {
    this.loadedModules = new Set();
    this.loadingPromises = new Map();
  }
  
  // åŠ¨æ€å¯¼å…¥æ¨¡å—
  async loadModule(modulePath) {
    if (this.loadedModules.has(modulePath)) {
      return;
    }
    
    if (this.loadingPromises.has(modulePath)) {
      return this.loadingPromises.get(modulePath);
    }
    
    const loadPromise = import(modulePath)
      .then(module => {
        this.loadedModules.add(modulePath);
        this.loadingPromises.delete(modulePath);
        return module;
      })
      .catch(error => {
        this.loadingPromises.delete(modulePath);
        console.error(`åŠ è½½æ¨¡å—å¤±è´¥: ${modulePath}`, error);
        throw error;
      });
    
    this.loadingPromises.set(modulePath, loadPromise);
    return loadPromise;
  }
  
  // é¢„åŠ è½½æ¨¡å—
  preloadModule(modulePath) {
    const link = document.createElement('link');
    link.rel = 'modulepreload';
    link.href = modulePath;
    document.head.appendChild(link);
  }
  
  // åŸºäºè·¯ç”±çš„ä»£ç åˆ†å‰²
  setupRouteBasedSplitting() {
    const routes = {
      '/dashboard': () => import('./pages/Dashboard'),
      '/profile': () => import('./pages/Profile'),
      '/settings': () => import('./pages/Settings')
    };
    
    // é¢„åŠ è½½å¯èƒ½è®¿é—®çš„è·¯ç”±
    const currentPath = window.location.pathname;
    const likelyNextRoutes = this.predictNextRoutes(currentPath);
    
    likelyNextRoutes.forEach(route => {
      if (routes[route]) {
        setTimeout(() => {
          routes[route]().catch(console.error);
        }, 2000); // 2ç§’åé¢„åŠ è½½
      }
    });
  }
  
  predictNextRoutes(currentPath) {
    // åŸºäºç”¨æˆ·è¡Œä¸ºé¢„æµ‹ä¸‹ä¸€ä¸ªå¯èƒ½è®¿é—®çš„è·¯ç”±
    const predictions = {
      '/': ['/dashboard', '/profile'],
      '/dashboard': ['/profile', '/settings'],
      '/profile': ['/settings', '/dashboard']
    };
    
    return predictions[currentPath] || [];
  }
  
  // ç»„ä»¶çº§æ‡’åŠ è½½
  createLazyComponent(importFn) {
    return React.lazy(() => {
      return importFn().catch(error => {
        console.error('ç»„ä»¶åŠ è½½å¤±è´¥:', error);
        // è¿”å›é”™è¯¯ç»„ä»¶
        return { default: () => React.createElement('div', null, 'ç»„ä»¶åŠ è½½å¤±è´¥') };
      });
    });
  }
}

// 3. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
class CacheOptimizer {
  constructor() {
    this.setupServiceWorker();
    this.setupHTTPCache();
  }
  
  async setupServiceWorker() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('Service Workeræ³¨å†ŒæˆåŠŸ:', registration);
        
        // ç›‘å¬æ›´æ–°
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // æœ‰æ–°ç‰ˆæœ¬å¯ç”¨
              this.notifyUpdate();
            }
          });
        });
      } catch (error) {
        console.error('Service Workeræ³¨å†Œå¤±è´¥:', error);
      }
    }
  }
  
  setupHTTPCache() {
    // è®¾ç½®èµ„æºç¼“å­˜ç­–ç•¥
    const cacheStrategies = {
      // é™æ€èµ„æºï¼šé•¿æœŸç¼“å­˜
      static: {
        pattern: /\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2)$/,
        strategy: 'cache-first',
        maxAge: 31536000 // 1å¹´
      },
      
      // APIæ•°æ®ï¼šç½‘ç»œä¼˜å…ˆ
      api: {
        pattern: /\/api\//,
        strategy: 'network-first',
        maxAge: 300 // 5åˆ†é’Ÿ
      },
      
      // HTMLé¡µé¢ï¼šç½‘ç»œä¼˜å…ˆï¼Œç¦»çº¿å›é€€
      pages: {
        pattern: /\.html$/,
        strategy: 'network-first',
        maxAge: 3600 // 1å°æ—¶
      }
    };
    
    // åœ¨Service Workerä¸­å®ç°è¿™äº›ç­–ç•¥
    this.sendMessageToSW('SET_CACHE_STRATEGIES', cacheStrategies);
  }
  
  sendMessageToSW(type, data) {
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({ type, data });
    }
  }
  
  notifyUpdate() {
    // é€šçŸ¥ç”¨æˆ·æœ‰æ–°ç‰ˆæœ¬
    if (confirm('å‘ç°æ–°ç‰ˆæœ¬ï¼Œæ˜¯å¦ç«‹å³æ›´æ–°ï¼Ÿ')) {
      window.location.reload();
    }
  }
  
  // é¢„ç¼“å­˜å…³é”®èµ„æº
  precacheResources(urls) {
    this.sendMessageToSW('PRECACHE_RESOURCES', urls);
  }
  
  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanupCache() {
    this.sendMessageToSW('CLEANUP_CACHE');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const imageOptimizer = new ImageOptimizer();
const codeSplittingManager = new CodeSplittingManager();
const cacheOptimizer = new CacheOptimizer();

// åˆå§‹åŒ–ä¼˜åŒ–
document.addEventListener('DOMContentLoaded', () => {
  // é¢„åŠ è½½å…³é”®å›¾ç‰‡
  imageOptimizer.preloadCriticalImages([
    '/images/hero.jpg',
    '/images/logo.png'
  ]);
  
  // è®¾ç½®è·¯ç”±åˆ†å‰²
  codeSplittingManager.setupRouteBasedSplitting();
  
  // é¢„ç¼“å­˜å…³é”®èµ„æº
  cacheOptimizer.precacheResources([
    '/',
    '/dashboard',
    '/offline.html'
  ]);
});
```

## è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

<Callout type="warning">
è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–å…³æ³¨åº”ç”¨è¿è¡Œè¿‡ç¨‹ä¸­çš„æ€§èƒ½è¡¨ç°ï¼ŒåŒ…æ‹¬æ¸²æŸ“æ€§èƒ½ã€å†…å­˜ç®¡ç†ã€äº¤äº’å“åº”ç­‰æ–¹é¢ã€‚
</Callout>

### Reactæ€§èƒ½ä¼˜åŒ–

```javascript
// 1. ç»„ä»¶ä¼˜åŒ–ç­–ç•¥
import React, { memo, useMemo, useCallback, useState, useEffect } from 'react';
import { debounce } from 'lodash';

// ä½¿ç”¨memoé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
const UserCard = memo(({ user, onEdit, onDelete }) => {
  const handleEdit = useCallback(() => {
    onEdit(user.id);
  }, [user.id, onEdit]);

  const handleDelete = useCallback(() => {
    onDelete(user.id);
  }, [user.id, onDelete]);

  // è®¡ç®—å±æ€§ä½¿ç”¨useMemo
  const displayName = useMemo(() => {
    return `${user.firstName} ${user.lastName}`.trim();
  }, [user.firstName, user.lastName]);

  const userStats = useMemo(() => {
    return {
      totalPosts: user.posts?.length || 0,
      totalComments: user.comments?.length || 0,
      joinDate: new Date(user.createdAt).toLocaleDateString()
    };
  }, [user.posts, user.comments, user.createdAt]);

  return (
    <div className="user-card">
      <h3>{displayName}</h3>
      <p>Posts: {userStats.totalPosts}</p>
      <p>Comments: {userStats.totalComments}</p>
      <p>Joined: {userStats.joinDate}</p>
      <button onClick={handleEdit}>Edit</button>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
});

// 2. è™šæ‹Ÿæ»šåŠ¨å®ç°
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items, height = 400 }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <UserCard user={items[index]} />
    </div>
  );

  return (
    <List
      height={height}
      itemCount={items.length}
      itemSize={100}
      width="100%"
    >
      {Row}
    </List>
  );
};

// 3. é˜²æŠ–æœç´¢ä¼˜åŒ–
const SearchInput = ({ onSearch }) => {
  const [value, setValue] = useState('');

  const debouncedSearch = useCallback(
    debounce((searchTerm) => {
      onSearch(searchTerm);
    }, 300),
    [onSearch]
  );

  useEffect(() => {
    debouncedSearch(value);
    return () => {
      debouncedSearch.cancel();
    };
  }, [value, debouncedSearch]);

  return (
    <input
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
      placeholder="æœç´¢ç”¨æˆ·..."
    />
  );
};

// 4. å†…å­˜æ³„æ¼é˜²æŠ¤
const DataFetcher = ({ userId }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    let cancelled = false;
    const controller = new AbortController();

    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal
        });
        const result = await response.json();

        if (!cancelled) {
          setData(result);
        }
      } catch (error) {
        if (!cancelled && error.name !== 'AbortError') {
          console.error('Fetch error:', error);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>{data ? JSON.stringify(data) : 'No data'}</div>;
};

// 5. é•¿åˆ—è¡¨ä¼˜åŒ–
class VirtualScrollList {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.scrollTop = 0;
    this.visibleStart = 0;
    this.visibleEnd = 0;
    this.items = [];

    this.init();
  }

  init() {
    this.container.addEventListener('scroll', this.handleScroll.bind(this));
    this.update();
  }

  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.update();
  }

  update() {
    const containerHeight = this.container.clientHeight;
    const totalHeight = this.items.length * this.itemHeight;

    // è®¡ç®—å¯è§èŒƒå›´
    this.visibleStart = Math.floor(this.scrollTop / this.itemHeight);
    this.visibleEnd = Math.min(
      this.visibleStart + Math.ceil(containerHeight / this.itemHeight) + 1,
      this.items.length
    );

    // æ¸²æŸ“å¯è§é¡¹ç›®
    this.render();
  }

  render() {
    const fragment = document.createDocumentFragment();

    // åˆ›å»ºå ä½ç©ºé—´
    const topSpacer = document.createElement('div');
    topSpacer.style.height = `${this.visibleStart * this.itemHeight}px`;
    fragment.appendChild(topSpacer);

    // æ¸²æŸ“å¯è§é¡¹ç›®
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      const item = this.renderItem(this.items[i], i);
      fragment.appendChild(item);
    }

    // åˆ›å»ºåº•éƒ¨å ä½ç©ºé—´
    const bottomSpacer = document.createElement('div');
    const remainingHeight = (this.items.length - this.visibleEnd) * this.itemHeight;
    bottomSpacer.style.height = `${remainingHeight}px`;
    fragment.appendChild(bottomSpacer);

    // æ›´æ–°å®¹å™¨å†…å®¹
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }

  setItems(items) {
    this.items = items;
    this.update();
  }
}
```

## æ€§èƒ½ç›‘æ§å’Œåˆ†æ

<Callout type="info">
æ€§èƒ½ç›‘æ§å¸®åŠ©æˆ‘ä»¬äº†è§£åº”ç”¨åœ¨çœŸå®ç¯å¢ƒä¸­çš„è¡¨ç°ï¼ŒåŠæ—¶å‘ç°å’Œè§£å†³æ€§èƒ½é—®é¢˜ã€‚
</Callout>

### Web Vitalsç›‘æ§

```javascript
// 1. Web Vitalsæ•°æ®æ”¶é›†
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.setupWebVitals();
    this.setupCustomMetrics();
  }

  setupWebVitals() {
    // æ”¶é›†Core Web Vitals
    getCLS(this.handleMetric.bind(this, 'CLS'));
    getFID(this.handleMetric.bind(this, 'FID'));
    getFCP(this.handleMetric.bind(this, 'FCP'));
    getLCP(this.handleMetric.bind(this, 'LCP'));
    getTTFB(this.handleMetric.bind(this, 'TTFB'));
  }

  handleMetric(name, metric) {
    this.metrics.set(name, metric);

    // è®¡ç®—è¯„åˆ†
    const rating = this.getRating(name, metric.value);

    // å‘é€åˆ°åˆ†ææœåŠ¡
    this.sendToAnalytics({
      name,
      value: metric.value,
      rating,
      id: metric.id,
      delta: metric.delta,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    });
  }

  getRating(name, value) {
    const thresholds = {
      CLS: { good: 0.1, poor: 0.25 },
      FID: { good: 100, poor: 300 },
      FCP: { good: 1800, poor: 3000 },
      LCP: { good: 2500, poor: 4000 },
      TTFB: { good: 800, poor: 1800 }
    };

    const threshold = thresholds[name];
    if (!threshold) return 'unknown';

    if (value <= threshold.good) return 'good';
    if (value <= threshold.poor) return 'needs-improvement';
    return 'poor';
  }

  setupCustomMetrics() {
    // ç›‘æ§é¡µé¢åŠ è½½æ—¶é—´
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      this.sendToAnalytics({
        name: 'page-load',
        value: navigation.loadEventEnd - navigation.fetchStart,
        timestamp: Date.now()
      });
    });

    // ç›‘æ§èµ„æºåŠ è½½
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'resource') {
          this.analyzeResource(entry);
        }
      });
    });
    observer.observe({ entryTypes: ['resource'] });
  }

  analyzeResource(entry) {
    const resourceData = {
      name: entry.name,
      type: this.getResourceType(entry.name),
      size: entry.transferSize,
      duration: entry.duration,
      startTime: entry.startTime,
      timestamp: Date.now()
    };

    // æ£€æŸ¥æ…¢èµ„æº
    if (entry.duration > 1000) {
      this.sendToAnalytics({
        ...resourceData,
        alert: 'slow-resource'
      });
    }

    // æ£€æŸ¥å¤§æ–‡ä»¶
    if (entry.transferSize > 1024 * 1024) { // 1MB
      this.sendToAnalytics({
        ...resourceData,
        alert: 'large-resource'
      });
    }
  }

  getResourceType(url) {
    if (url.match(/\.(js|mjs)$/)) return 'script';
    if (url.match(/\.css$/)) return 'stylesheet';
    if (url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|otf)$/)) return 'font';
    return 'other';
  }

  async sendToAnalytics(data) {
    try {
      await fetch('/api/analytics/performance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
    } catch (error) {
      console.warn('Failed to send analytics:', error);
    }
  }
}

// 2. é”™è¯¯ç›‘æ§
class ErrorMonitor {
  constructor() {
    this.setupErrorHandlers();
    this.setupUnhandledRejectionHandler();
  }

  setupErrorHandlers() {
    window.addEventListener('error', (event) => {
      this.handleError({
        type: 'javascript',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
        timestamp: Date.now()
      });
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.handleError({
        type: 'promise',
        message: event.reason?.message || 'Unhandled Promise Rejection',
        stack: event.reason?.stack,
        timestamp: Date.now()
      });
    });
  }

  setupUnhandledRejectionHandler() {
    // Reacté”™è¯¯è¾¹ç•Œ
    const originalConsoleError = console.error;
    console.error = (...args) => {
      if (args[0]?.includes?.('React')) {
        this.handleError({
          type: 'react',
          message: args.join(' '),
          timestamp: Date.now()
        });
      }
      originalConsoleError.apply(console, args);
    };
  }

  handleError(errorData) {
    // è¿‡æ»¤æ‰ä¸€äº›å·²çŸ¥çš„æ— å®³é”™è¯¯
    if (this.shouldIgnoreError(errorData)) {
      return;
    }

    // å‘é€é”™è¯¯æŠ¥å‘Š
    this.sendErrorReport(errorData);
  }

  shouldIgnoreError(errorData) {
    const ignoredMessages = [
      'Script error',
      'Non-Error promise rejection captured',
      'ResizeObserver loop limit exceeded'
    ];

    return ignoredMessages.some(msg =>
      errorData.message?.includes(msg)
    );
  }

  async sendErrorReport(errorData) {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...errorData,
          url: window.location.href,
          userAgent: navigator.userAgent,
          timestamp: Date.now()
        })
      });
    } catch (error) {
      console.warn('Failed to send error report:', error);
    }
  }
}

// 3. ç”¨æˆ·è¡Œä¸ºåˆ†æ
class UserBehaviorTracker {
  constructor() {
    this.sessionStart = Date.now();
    this.interactions = [];
    this.setupTracking();
  }

  setupTracking() {
    // ç‚¹å‡»äº‹ä»¶è¿½è¸ª
    document.addEventListener('click', (event) => {
      this.trackInteraction('click', {
        target: this.getElementSelector(event.target),
        timestamp: Date.now()
      });
    });

    // é¡µé¢åœç•™æ—¶é—´
    window.addEventListener('beforeunload', () => {
      this.trackInteraction('session-end', {
        duration: Date.now() - this.sessionStart,
        interactions: this.interactions.length
      });
    });

    // æ»šåŠ¨æ·±åº¦
    let maxScrollDepth = 0;
    window.addEventListener('scroll', debounce(() => {
      const scrollDepth = Math.round(
        (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100
      );
      if (scrollDepth > maxScrollDepth) {
        maxScrollDepth = scrollDepth;
        this.trackInteraction('scroll-depth', {
          depth: scrollDepth,
          timestamp: Date.now()
        });
      }
    }, 100));
  }

  getElementSelector(element) {
    if (element.id) return `#${element.id}`;
    if (element.className) return `.${element.className.split(' ')[0]}`;
    return element.tagName.toLowerCase();
  }

  trackInteraction(type, data) {
    this.interactions.push({ type, ...data });

    // æ‰¹é‡å‘é€ï¼Œé¿å…è¿‡å¤šè¯·æ±‚
    if (this.interactions.length >= 10) {
      this.flushInteractions();
    }
  }

  async flushInteractions() {
    if (this.interactions.length === 0) return;

    try {
      await fetch('/api/analytics/interactions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          interactions: this.interactions,
          sessionId: this.getSessionId(),
          timestamp: Date.now()
        })
      });
      this.interactions = [];
    } catch (error) {
      console.warn('Failed to send interactions:', error);
    }
  }

  getSessionId() {
    let sessionId = sessionStorage.getItem('sessionId');
    if (!sessionId) {
      sessionId = Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('sessionId', sessionId);
    }
    return sessionId;
  }
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
```

## è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•

<Callout type="warning">
è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•ç¡®ä¿åº”ç”¨åœ¨æŒç»­å¼€å‘è¿‡ç¨‹ä¸­ä¿æŒè‰¯å¥½çš„æ€§èƒ½è¡¨ç°ï¼ŒåŠæ—©å‘ç°æ€§èƒ½å›å½’é—®é¢˜ã€‚
</Callout>

### Lighthouse CIé›†æˆ

```yaml
# .github/workflows/performance.yml
name: Performance Testing

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Start server
        run: npm start &

      - name: Wait for server
        run: npx wait-on http://localhost:3000

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.12.x
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
```

```javascript
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      url: [
        'http://localhost:3000',
        'http://localhost:3000/products',
        'http://localhost:3000/about'
      ],
      numberOfRuns: 3,
      settings: {
        chromeFlags: '--no-sandbox --headless'
      }
    },
    assert: {
      assertions: {
        'categories:performance': ['warn', { minScore: 0.8 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['warn', { minScore: 0.8 }],
        'categories:seo': ['warn', { minScore: 0.8 }],
        'first-contentful-paint': ['warn', { maxNumericValue: 2000 }],
        'largest-contentful-paint': ['error', { maxNumericValue: 4000 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
        'total-blocking-time': ['warn', { maxNumericValue: 300 }]
      }
    },
    upload: {
      target: 'temporary-public-storage'
    },
    server: {
      port: 9001,
      storage: './lighthouse-reports'
    }
  }
};

// 2. è‡ªå®šä¹‰æ€§èƒ½æµ‹è¯•è„šæœ¬
// scripts/performance-test.js
const puppeteer = require('puppeteer');
const lighthouse = require('lighthouse');

class PerformanceTester {
  constructor() {
    this.browser = null;
    this.results = [];
  }

  async init() {
    this.browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-dev-shm-usage']
    });
  }

  async testPage(url, options = {}) {
    const page = await this.browser.newPage();

    try {
      // è®¾ç½®ç½‘ç»œæ¡ä»¶
      if (options.networkConditions) {
        await page.emulateNetworkConditions(options.networkConditions);
      }

      // è®¾ç½®è®¾å¤‡
      if (options.device) {
        await page.emulate(options.device);
      }

      // å¼€å§‹æ€§èƒ½ç›‘æ§
      await page.tracing.start({ path: 'trace.json' });

      const startTime = Date.now();

      // å¯¼èˆªåˆ°é¡µé¢
      const response = await page.goto(url, {
        waitUntil: 'networkidle0',
        timeout: 30000
      });

      const loadTime = Date.now() - startTime;

      // åœæ­¢è¿½è¸ª
      await page.tracing.stop();

      // è¿è¡ŒLighthouse
      const lighthouseResult = await lighthouse(url, {
        port: new URL(this.browser.wsEndpoint()).port,
        output: 'json',
        logLevel: 'info'
      });

      // æ”¶é›†è‡ªå®šä¹‰æŒ‡æ ‡
      const metrics = await page.evaluate(() => {
        return new Promise((resolve) => {
          new PerformanceObserver((list) => {
            const entries = list.getEntries();
            const paintEntries = entries.filter(entry =>
              entry.entryType === 'paint'
            );
            resolve(paintEntries);
          }).observe({ entryTypes: ['paint'] });
        });
      });

      const result = {
        url,
        loadTime,
        lighthouse: lighthouseResult.lhr,
        customMetrics: metrics,
        networkConditions: options.networkConditions,
        device: options.device?.name,
        timestamp: new Date().toISOString()
      };

      this.results.push(result);
      return result;

    } finally {
      await page.close();
    }
  }

  async testMultiplePages(urls, options = {}) {
    const results = [];

    for (const url of urls) {
      console.log(`Testing ${url}...`);
      try {
        const result = await this.testPage(url, options);
        results.push(result);
        console.log(`âœ“ ${url} - Performance Score: ${result.lighthouse.categories.performance.score * 100}`);
      } catch (error) {
        console.error(`âœ— ${url} - Error: ${error.message}`);
        results.push({
          url,
          error: error.message,
          timestamp: new Date().toISOString()
        });
      }
    }

    return results;
  }

  async generateReport() {
    const report = {
      summary: {
        totalTests: this.results.length,
        passedTests: this.results.filter(r => !r.error).length,
        averagePerformanceScore: this.calculateAverageScore('performance'),
        averageAccessibilityScore: this.calculateAverageScore('accessibility'),
        timestamp: new Date().toISOString()
      },
      details: this.results,
      recommendations: this.generateRecommendations()
    };

    // ä¿å­˜æŠ¥å‘Š
    const fs = require('fs');
    fs.writeFileSync(
      `performance-report-${Date.now()}.json`,
      JSON.stringify(report, null, 2)
    );

    return report;
  }

  calculateAverageScore(category) {
    const validResults = this.results.filter(r => !r.error && r.lighthouse);
    if (validResults.length === 0) return 0;

    const totalScore = validResults.reduce((sum, result) => {
      return sum + (result.lighthouse.categories[category]?.score || 0);
    }, 0);

    return Math.round((totalScore / validResults.length) * 100);
  }

  generateRecommendations() {
    const recommendations = [];

    this.results.forEach(result => {
      if (result.error) return;

      const audits = result.lighthouse.audits;

      // æ£€æŸ¥å¸¸è§æ€§èƒ½é—®é¢˜
      if (audits['largest-contentful-paint']?.score < 0.5) {
        recommendations.push({
          url: result.url,
          type: 'LCP',
          message: 'Largest Contentful Paintéœ€è¦ä¼˜åŒ–',
          suggestions: [
            'ä¼˜åŒ–å›¾ç‰‡å¤§å°å’Œæ ¼å¼',
            'å‡å°‘æœåŠ¡å™¨å“åº”æ—¶é—´',
            'ç§»é™¤é˜»å¡æ¸²æŸ“çš„èµ„æº'
          ]
        });
      }

      if (audits['cumulative-layout-shift']?.score < 0.5) {
        recommendations.push({
          url: result.url,
          type: 'CLS',
          message: 'Cumulative Layout Shiftéœ€è¦ä¼˜åŒ–',
          suggestions: [
            'ä¸ºå›¾ç‰‡å’Œè§†é¢‘è®¾ç½®å°ºå¯¸å±æ€§',
            'é¿å…åœ¨ç°æœ‰å†…å®¹ä¸Šæ–¹æ’å…¥å†…å®¹',
            'ä½¿ç”¨transformåŠ¨ç”»è€Œä¸æ˜¯æ”¹å˜å¸ƒå±€çš„å±æ€§'
          ]
        });
      }

      if (audits['unused-javascript']?.score < 0.5) {
        recommendations.push({
          url: result.url,
          type: 'JavaScript',
          message: 'å­˜åœ¨æœªä½¿ç”¨çš„JavaScriptä»£ç ',
          suggestions: [
            'ç§»é™¤æœªä½¿ç”¨çš„ä»£ç ',
            'å®ç°ä»£ç åˆ†å‰²',
            'å»¶è¿ŸåŠ è½½éå…³é”®JavaScript'
          ]
        });
      }
    });

    return recommendations;
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function runPerformanceTests() {
  const tester = new PerformanceTester();
  await tester.init();

  const urls = [
    'http://localhost:3000',
    'http://localhost:3000/products',
    'http://localhost:3000/about'
  ];

  // æµ‹è¯•ä¸åŒç½‘ç»œæ¡ä»¶
  const networkConditions = [
    { name: 'Fast 3G', downloadThroughput: 1.6 * 1024 * 1024 / 8, uploadThroughput: 750 * 1024 / 8, latency: 150 },
    { name: 'Slow 3G', downloadThroughput: 500 * 1024 / 8, uploadThroughput: 500 * 1024 / 8, latency: 400 }
  ];

  for (const condition of networkConditions) {
    console.log(`\nTesting with ${condition.name} network...`);
    await tester.testMultiplePages(urls, { networkConditions: condition });
  }

  const report = await tester.generateReport();
  console.log('\nPerformance Test Summary:');
  console.log(`Total Tests: ${report.summary.totalTests}`);
  console.log(`Passed Tests: ${report.summary.passedTests}`);
  console.log(`Average Performance Score: ${report.summary.averagePerformanceScore}`);

  await tester.close();
  return report;
}

module.exports = { PerformanceTester, runPerformanceTests };
```

## æ€§èƒ½é¢„ç®—å’ŒæŒç»­ä¼˜åŒ–

<Callout type="info">
æ€§èƒ½é¢„ç®—å¸®åŠ©å›¢é˜Ÿåœ¨å¼€å‘è¿‡ç¨‹ä¸­ä¿æŒæ€§èƒ½æ„è¯†ï¼Œç¡®ä¿æ–°åŠŸèƒ½ä¸ä¼šå½±å“åº”ç”¨çš„æ•´ä½“æ€§èƒ½è¡¨ç°ã€‚
</Callout>

### æ€§èƒ½é¢„ç®—é…ç½®

```javascript
// performance-budget.config.js
module.exports = {
  // èµ„æºå¤§å°é¢„ç®—
  resourceBudgets: {
    javascript: {
      total: 500 * 1024, // 500KB
      individual: 100 * 1024, // å•ä¸ªæ–‡ä»¶100KB
      warning: 400 * 1024,
      error: 600 * 1024
    },
    css: {
      total: 100 * 1024, // 100KB
      individual: 50 * 1024,
      warning: 80 * 1024,
      error: 120 * 1024
    },
    images: {
      total: 2 * 1024 * 1024, // 2MB
      individual: 500 * 1024,
      warning: 1.5 * 1024 * 1024,
      error: 2.5 * 1024 * 1024
    },
    fonts: {
      total: 200 * 1024, // 200KB
      individual: 100 * 1024,
      warning: 150 * 1024,
      error: 250 * 1024
    }
  },

  // æ€§èƒ½æŒ‡æ ‡é¢„ç®—
  performanceBudgets: {
    'first-contentful-paint': {
      target: 1500,
      warning: 2000,
      error: 3000
    },
    'largest-contentful-paint': {
      target: 2500,
      warning: 3000,
      error: 4000
    },
    'cumulative-layout-shift': {
      target: 0.05,
      warning: 0.1,
      error: 0.25
    },
    'total-blocking-time': {
      target: 200,
      warning: 300,
      error: 600
    },
    'speed-index': {
      target: 3000,
      warning: 4000,
      error: 5500
    }
  },

  // ç½‘ç»œæ¡ä»¶
  networkConditions: {
    '3g': {
      downloadThroughput: 1.6 * 1024 * 1024 / 8,
      uploadThroughput: 750 * 1024 / 8,
      latency: 150
    },
    'slow-3g': {
      downloadThroughput: 500 * 1024 / 8,
      uploadThroughput: 500 * 1024 / 8,
      latency: 400
    }
  }
};

// 2. æ€§èƒ½é¢„ç®—æ£€æŸ¥å™¨
class PerformanceBudgetChecker {
  constructor(config) {
    this.config = config;
    this.violations = [];
  }

  async checkResourceBudgets(buildStats) {
    const { resourceBudgets } = this.config;

    Object.entries(resourceBudgets).forEach(([type, budget]) => {
      const resources = this.getResourcesByType(buildStats, type);
      const totalSize = resources.reduce((sum, resource) => sum + resource.size, 0);

      // æ£€æŸ¥æ€»å¤§å°
      if (totalSize > budget.error) {
        this.violations.push({
          type: 'resource-budget',
          severity: 'error',
          resourceType: type,
          message: `${type} total size (${this.formatBytes(totalSize)}) exceeds error threshold (${this.formatBytes(budget.error)})`,
          actual: totalSize,
          threshold: budget.error
        });
      } else if (totalSize > budget.warning) {
        this.violations.push({
          type: 'resource-budget',
          severity: 'warning',
          resourceType: type,
          message: `${type} total size (${this.formatBytes(totalSize)}) exceeds warning threshold (${this.formatBytes(budget.warning)})`,
          actual: totalSize,
          threshold: budget.warning
        });
      }

      // æ£€æŸ¥å•ä¸ªæ–‡ä»¶å¤§å°
      resources.forEach(resource => {
        if (resource.size > budget.individual) {
          this.violations.push({
            type: 'individual-resource',
            severity: 'warning',
            resourceType: type,
            fileName: resource.name,
            message: `${resource.name} size (${this.formatBytes(resource.size)}) exceeds individual limit (${this.formatBytes(budget.individual)})`,
            actual: resource.size,
            threshold: budget.individual
          });
        }
      });
    });
  }

  async checkPerformanceBudgets(lighthouseResults) {
    const { performanceBudgets } = this.config;

    Object.entries(performanceBudgets).forEach(([metric, budget]) => {
      const audit = lighthouseResults.audits[metric];
      if (!audit) return;

      const value = audit.numericValue;

      if (value > budget.error) {
        this.violations.push({
          type: 'performance-budget',
          severity: 'error',
          metric,
          message: `${metric} (${Math.round(value)}ms) exceeds error threshold (${budget.error}ms)`,
          actual: value,
          threshold: budget.error
        });
      } else if (value > budget.warning) {
        this.violations.push({
          type: 'performance-budget',
          severity: 'warning',
          metric,
          message: `${metric} (${Math.round(value)}ms) exceeds warning threshold (${budget.warning}ms)`,
          actual: value,
          threshold: budget.warning
        });
      }
    });
  }

  getResourcesByType(buildStats, type) {
    const extensions = {
      javascript: ['.js', '.mjs', '.jsx', '.ts', '.tsx'],
      css: ['.css', '.scss', '.sass', '.less'],
      images: ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'],
      fonts: ['.woff', '.woff2', '.ttf', '.otf', '.eot']
    };

    return buildStats.assets
      .filter(asset => {
        const ext = asset.name.substring(asset.name.lastIndexOf('.'));
        return extensions[type]?.includes(ext);
      })
      .map(asset => ({
        name: asset.name,
        size: asset.size
      }));
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  generateReport() {
    const errorCount = this.violations.filter(v => v.severity === 'error').length;
    const warningCount = this.violations.filter(v => v.severity === 'warning').length;

    return {
      passed: errorCount === 0,
      summary: {
        total: this.violations.length,
        errors: errorCount,
        warnings: warningCount
      },
      violations: this.violations,
      recommendations: this.generateRecommendations()
    };
  }

  generateRecommendations() {
    const recommendations = [];

    // èµ„æºä¼˜åŒ–å»ºè®®
    const resourceViolations = this.violations.filter(v => v.type === 'resource-budget');
    if (resourceViolations.length > 0) {
      recommendations.push({
        category: 'Resource Optimization',
        suggestions: [
          'å¯ç”¨Gzip/Brotliå‹ç¼©',
          'ä½¿ç”¨ä»£ç åˆ†å‰²å‡å°‘åˆå§‹åŒ…å¤§å°',
          'ç§»é™¤æœªä½¿ç”¨çš„ä»£ç ',
          'ä¼˜åŒ–å›¾ç‰‡æ ¼å¼å’Œå¤§å°',
          'ä½¿ç”¨CDNåŠ é€Ÿèµ„æºåŠ è½½'
        ]
      });
    }

    // æ€§èƒ½ä¼˜åŒ–å»ºè®®
    const performanceViolations = this.violations.filter(v => v.type === 'performance-budget');
    if (performanceViolations.length > 0) {
      recommendations.push({
        category: 'Performance Optimization',
        suggestions: [
          'ä¼˜åŒ–å…³é”®æ¸²æŸ“è·¯å¾„',
          'å®ç°èµ„æºé¢„åŠ è½½',
          'å‡å°‘ä¸»çº¿ç¨‹å·¥ä½œ',
          'ä¼˜åŒ–ç¬¬ä¸‰æ–¹è„šæœ¬',
          'ä½¿ç”¨Service Workerç¼“å­˜'
        ]
      });
    }

    return recommendations;
  }
}

// 3. æŒç»­ä¼˜åŒ–å·¥ä½œæµ
class ContinuousOptimization {
  constructor() {
    this.metrics = new Map();
    this.trends = new Map();
  }

  recordMetrics(url, metrics) {
    const key = `${url}-${new Date().toDateString()}`;
    this.metrics.set(key, {
      ...metrics,
      timestamp: Date.now()
    });

    this.updateTrends(url, metrics);
  }

  updateTrends(url, metrics) {
    if (!this.trends.has(url)) {
      this.trends.set(url, []);
    }

    const trend = this.trends.get(url);
    trend.push({
      ...metrics,
      timestamp: Date.now()
    });

    // ä¿ç•™æœ€è¿‘30å¤©çš„æ•°æ®
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
    this.trends.set(url, trend.filter(m => m.timestamp > thirtyDaysAgo));
  }

  analyzePerformanceTrends(url) {
    const trend = this.trends.get(url) || [];
    if (trend.length < 2) return null;

    const recent = trend.slice(-7); // æœ€è¿‘7æ¬¡æµ‹é‡
    const previous = trend.slice(-14, -7); // ä¹‹å‰7æ¬¡æµ‹é‡

    const analysis = {};

    ['fcp', 'lcp', 'cls', 'fid', 'ttfb'].forEach(metric => {
      const recentAvg = recent.reduce((sum, m) => sum + (m[metric] || 0), 0) / recent.length;
      const previousAvg = previous.reduce((sum, m) => sum + (m[metric] || 0), 0) / previous.length;

      const change = ((recentAvg - previousAvg) / previousAvg) * 100;

      analysis[metric] = {
        current: recentAvg,
        previous: previousAvg,
        change: change,
        trend: change > 5 ? 'degrading' : change < -5 ? 'improving' : 'stable'
      };
    });

    return analysis;
  }

  generateOptimizationPlan(trendAnalysis) {
    const plan = {
      priority: 'medium',
      actions: [],
      timeline: '2 weeks'
    };

    Object.entries(trendAnalysis).forEach(([metric, data]) => {
      if (data.trend === 'degrading') {
        plan.priority = 'high';
        plan.timeline = '1 week';

        switch (metric) {
          case 'fcp':
          case 'lcp':
            plan.actions.push({
              metric,
              action: 'ä¼˜åŒ–å…³é”®èµ„æºåŠ è½½',
              details: [
                'æ£€æŸ¥å¹¶ä¼˜åŒ–å…³é”®CSS',
                'å‹ç¼©å’Œä¼˜åŒ–å›¾ç‰‡',
                'å®ç°èµ„æºé¢„åŠ è½½'
              ]
            });
            break;
          case 'cls':
            plan.actions.push({
              metric,
              action: 'ä¿®å¤å¸ƒå±€åç§»é—®é¢˜',
              details: [
                'ä¸ºå›¾ç‰‡å’Œå¹¿å‘Šè®¾ç½®å°ºå¯¸',
                'é¿å…åœ¨ç°æœ‰å†…å®¹ä¸Šæ–¹æ’å…¥å†…å®¹',
                'ä½¿ç”¨CSS transformè¿›è¡ŒåŠ¨ç”»'
              ]
            });
            break;
          case 'fid':
            plan.actions.push({
              metric,
              action: 'å‡å°‘ä¸»çº¿ç¨‹é˜»å¡',
              details: [
                'æ‹†åˆ†é•¿ä»»åŠ¡',
                'å»¶è¿Ÿéå…³é”®JavaScript',
                'ä¼˜åŒ–ç¬¬ä¸‰æ–¹è„šæœ¬'
              ]
            });
            break;
          case 'ttfb':
            plan.actions.push({
              metric,
              action: 'ä¼˜åŒ–æœåŠ¡å™¨å“åº”æ—¶é—´',
              details: [
                'ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢',
                'å®ç°æœåŠ¡å™¨ç«¯ç¼“å­˜',
                'ä½¿ç”¨CDN'
              ]
            });
            break;
        }
      }
    });

    return plan;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const budgetConfig = require('./performance-budget.config.js');
const checker = new PerformanceBudgetChecker(budgetConfig);

// åœ¨CI/CDä¸­ä½¿ç”¨
async function checkPerformanceBudget(buildStats, lighthouseResults) {
  await checker.checkResourceBudgets(buildStats);
  await checker.checkPerformanceBudgets(lighthouseResults);

  const report = checker.generateReport();

  if (!report.passed) {
    console.error('Performance budget violations detected:');
    report.violations.forEach(violation => {
      console.error(`${violation.severity.toUpperCase()}: ${violation.message}`);
    });

    if (report.summary.errors > 0) {
      process.exit(1); // å¤±è´¥CIæ„å»º
    }
  }

  return report;
}
```

---

<Callout type="success">
æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦ç»“åˆç›‘æ§æ•°æ®ã€ç”¨æˆ·åé¦ˆå’Œä¸šåŠ¡éœ€æ±‚æ¥åˆ¶å®šåˆé€‚çš„ä¼˜åŒ–ç­–ç•¥ã€‚
</Callout>

---

## ğŸ“š å‚è€ƒå­¦ä¹ èµ„æ–™

### ğŸ“– å®˜æ–¹æ–‡æ¡£
- [Web.dev Performance](https://web.dev/performance/) - Google Webæ€§èƒ½æŒ‡å—
- [Core Web Vitals](https://web.dev/vitals/) - æ ¸å¿ƒWebæŒ‡æ ‡
- [MDN Performance](https://developer.mozilla.org/en-US/docs/Web/Performance) - MDNæ€§èƒ½æ–‡æ¡£
- [Chrome DevTools](https://developer.chrome.com/docs/devtools/performance/) - Chromeæ€§èƒ½è°ƒè¯•å·¥å…·

### ğŸ“ ä¼˜è´¨æ•™ç¨‹
- [Frontend Performance](https://frontendmasters.com/courses/web-performance/) - Frontend Mastersæ€§èƒ½è¯¾ç¨‹
- [Performance Budget](https://web.dev/performance-budgets-101/) - æ€§èƒ½é¢„ç®—æŒ‡å—
- [Image Optimization](https://web.dev/fast/#optimize-your-images) - å›¾ç‰‡ä¼˜åŒ–æŒ‡å—

### ğŸ› ï¸ å®è·µé¡¹ç›®
- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - Googleæ€§èƒ½å®¡è®¡å·¥å…·
- [WebPageTest](https://www.webpagetest.org/) - Webæ€§èƒ½æµ‹è¯•å·¥å…·
- [Performance Monitoring](https://github.com/GoogleChrome/web-vitals) - Web Vitalsç›‘æ§åº“

### ğŸ”§ å¼€å‘å·¥å…·
- [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci) - æŒç»­é›†æˆæ€§èƒ½æµ‹è¯•
- [Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) - WebpackåŒ…åˆ†æ
- [Perfume.js](https://zizzamia.github.io/perfume/) - æ€§èƒ½ç›‘æ§åº“
- [SpeedCurve](https://speedcurve.com/) - æ€§èƒ½ç›‘æ§å¹³å°

### ğŸ“ æ·±å…¥é˜…è¯»
- [High Performance Browser Networking](https://hpbn.co/) - é«˜æ€§èƒ½æµè§ˆå™¨ç½‘ç»œ
- [Performance Patterns](https://web.dev/patterns/performance/) - æ€§èƒ½ä¼˜åŒ–æ¨¡å¼
- [Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path) - å…³é”®æ¸²æŸ“è·¯å¾„

<Callout type="tip">
ğŸ’¡ **å­¦ä¹ å»ºè®®**ï¼šå»ºè®®ä»Core Web Vitalså¼€å§‹äº†è§£æ€§èƒ½æŒ‡æ ‡ï¼Œå­¦ä¹ ä½¿ç”¨Lighthouseè¿›è¡Œæ€§èƒ½å®¡è®¡ï¼Œç„¶åæŒæ¡å„ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œæœ€åå»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»ã€‚
</Callout>

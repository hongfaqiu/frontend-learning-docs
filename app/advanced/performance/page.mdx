import { Callout } from 'nextra/components'

# 16. 性能优化和监控

## 📋 目录

- [性能指标和Core Web Vitals](#性能指标和core-web-vitals)
- [加载性能优化](#加载性能优化)
- [运行时性能优化](#运行时性能优化)
- [性能监控和分析](#性能监控和分析)
- [自动化性能测试](#自动化性能测试)
- [性能预算和持续优化](#性能预算和持续优化)

## 性能指标和Core Web Vitals

<Callout type="info">
[Core Web Vitals](https://web.dev/vitals/)是[Google](https://developers.google.com/web)提出的用户体验核心指标，直接影响SEO排名和用户满意度。
</Callout>

### Core Web Vitals详解

#### 核心性能指标

| 指标 | 含义 | 优秀 | 需改进 | 较差 | 影响因素 |
|------|------|------|--------|------|----------|
| **LCP** | 最大内容绘制 | ≤2.5s | 2.5s-4.0s | >4.0s | 图片大小、服务器响应 |
| **FID** | 首次输入延迟 | ≤100ms | 100ms-300ms | >300ms | JavaScript执行时间 |
| **CLS** | 累积布局偏移 | ≤0.1 | 0.1-0.25 | >0.25 | 动态内容、字体加载 |
| **FCP** | 首次内容绘制 | ≤1.8s | 1.8s-3.0s | >3.0s | 关键资源加载 |
| **TTFB** | 首字节时间 | ≤800ms | 800ms-1.8s | >1.8s | 服务器性能、网络 |

#### 性能监控实现

```javascript
// 简化的性能监控
import { onLCP, onFID, onCLS } from 'web-vitals';

class SimpleWebVitalsMonitor {
  constructor() {
    this.initMonitoring();
  }

  initMonitoring() {
    onLCP(this.sendMetric);
    onFID(this.sendMetric);
    onCLS(this.sendMetric);
  }

  sendMetric(metric) {
    // 发送到分析服务
    console.log(`${metric.name}: ${metric.value}`);

    // 集成Google Analytics
    if (window.gtag) {
      window.gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: metric.name,
        value: Math.round(metric.value)
      });
    }
  }
}
```

#### 性能预算策略

性能预算是设定资源大小和性能指标的限制，确保应用保持良好性能。

| 资源类型 | 推荐预算 | 说明 |
|----------|----------|------|
| **JavaScript** | ≤200KB | 包含所有JS文件压缩后大小 |
| **CSS** | ≤100KB | 包含所有样式文件 |
| **图片** | ≤500KB | 首屏图片总大小 |
| **字体** | ≤100KB | Web字体文件大小 |
| **总资源** | ≤1MB | 首屏所有资源总和 |

```javascript
// 简化的性能预算检查
class PerformanceBudget {
  constructor() {
    this.budgets = {
      javascript: 200, // KB
      css: 100,
      images: 500,
      total: 1000
    };
  }

  checkBudgets() {
    const resources = performance.getEntriesByType('resource');
    const sizes = { javascript: 0, css: 0, images: 0, total: 0 };

    resources.forEach(resource => {
      const size = resource.transferSize || 0;
      sizes.total += size;

      if (resource.name.includes('.js')) sizes.javascript += size;
      else if (resource.name.includes('.css')) sizes.css += size;
      else if (/\.(jpg|jpeg|png|gif|webp)/.test(resource.name)) sizes.images += size;
    });

    // 检查预算违规
    const violations = [];
    Object.entries(sizes).forEach(([type, size]) => {
      const budgetKB = this.budgets[type];
      const actualKB = Math.round(size / 1024);

      if (actualKB > budgetKB) {
        violations.push({
          type,
          actual: actualKB,
          budget: budgetKB,
          excess: actualKB - budgetKB
        });
      }
    });

    return violations;
  }
}
```

## 加载性能优化

### 资源优化策略

#### 图片优化最佳实践

| 优化策略 | 实施方法 | 性能提升 |
|----------|----------|----------|
| **格式选择** | WebP > AVIF > JPEG | 减少30-50%文件大小 |
| **懒加载** | Intersection Observer | 减少初始加载时间 |
| **响应式图片** | srcset + sizes | 适配不同设备 |
| **预加载** | `<link rel="preload">` | 关键图片优先加载 |
| **压缩** | 质量80-90% | 平衡质量与大小 |

```javascript
// 简化的图片懒加载
class SimpleImageLazyLoader {
  constructor() {
    this.setupLazyLoading();
  }

  setupLazyLoading() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.add('loaded');
          observer.unobserve(img);
        }
      });
    }, { rootMargin: '50px' });

    // 监听所有懒加载图片
    document.querySelectorAll('img[data-src]').forEach(img => {
      observer.observe(img);
    });
  }

  // 预加载关键图片
  preloadImages(urls) {
    urls.forEach(url => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'image';
      link.href = url;
      document.head.appendChild(link);
    });
  }
}
```

#### 代码分割策略

| 分割类型 | 实施方法 | 适用场景 |
|----------|----------|----------|
| **路由分割** | React.lazy + Suspense | 不同页面组件 |
| **组件分割** | 动态import | 大型组件库 |
| **第三方库分割** | Webpack splitChunks | 独立的vendor包 |
| **按需加载** | 条件import | 功能模块 |

```javascript
// 简化的代码分割实现
class SimpleCodeSplitting {
  // 路由级懒加载
  static createLazyRoute(importFn) {
    return React.lazy(() => import(importFn));
  }

  // 动态导入模块
  static async loadModule(modulePath) {
    try {
      const module = await import(modulePath);
      return module;
    } catch (error) {
      console.error(`模块加载失败: ${modulePath}`, error);
      throw error;
    }
  }

  // 预加载关键模块
  static preloadModule(modulePath) {
    const link = document.createElement('link');
    link.rel = 'modulepreload';
    link.href = modulePath;
    document.head.appendChild(link);
  }
}

// React组件懒加载示例
const LazyDashboard = React.lazy(() => import('./Dashboard'));
const LazyProfile = React.lazy(() => import('./Profile'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/dashboard" element={<LazyDashboard />} />
        <Route path="/profile" element={<LazyProfile />} />
      </Routes>
    </Suspense>
  );
}
```

#### 缓存策略

| 资源类型 | 缓存策略 | 缓存时间 | 说明 |
|----------|----------|----------|------|
| **静态资源** | Cache First | 1年 | JS、CSS、图片、字体 |
| **API数据** | Network First | 5分钟 | 动态数据，网络优先 |
| **HTML页面** | Network First | 1小时 | 页面内容，支持离线 |
| **用户数据** | No Cache | - | 敏感数据不缓存 |

```javascript
// 简化的缓存实现
class SimpleCacheManager {
  // 注册Service Worker
  static async registerSW() {
    if ('serviceWorker' in navigator) {
      try {
        await navigator.serviceWorker.register('/sw.js');
        console.log('Service Worker注册成功');
      } catch (error) {
        console.error('Service Worker注册失败:', error);
      }
    }
  }

  // 预缓存关键资源
  static precacheResources(urls) {
    urls.forEach(url => {
      const link = document.createElement('link');
      link.rel = 'prefetch';
      link.href = url;
      document.head.appendChild(link);
    });
  }
}
```

## 运行时性能优化

<Callout type="warning">
运行时性能优化关注应用运行过程中的性能表现，包括渲染性能、内存管理、交互响应等方面。
</Callout>

### React性能优化

#### React性能优化策略

| 优化技术 | 使用场景 | 性能提升 |
|----------|----------|----------|
| **React.memo** | 避免不必要重渲染 | 减少渲染次数 |
| **useMemo** | 缓存计算结果 | 避免重复计算 |
| **useCallback** | 缓存函数引用 | 避免子组件重渲染 |
| **虚拟滚动** | 长列表渲染 | 减少DOM节点 |
| **代码分割** | 按需加载组件 | 减少初始包大小 |

```javascript
// 简化的React性能优化示例
import React, { memo, useMemo, useCallback, useState } from 'react';

// 1. 使用memo避免不必要的重渲染
const UserCard = memo(({ user, onEdit }) => {
  const handleEdit = useCallback(() => {
    onEdit(user.id);
  }, [user.id, onEdit]);

  const displayName = useMemo(() => {
    return `${user.firstName} ${user.lastName}`.trim();
  }, [user.firstName, user.lastName]);

  return (
    <div className="user-card">
      <h3>{displayName}</h3>
      <button onClick={handleEdit}>Edit</button>
    </div>
  );
});

// 2. 防抖搜索优化
const SearchInput = ({ onSearch }) => {
  const [value, setValue] = useState('');

  const debouncedSearch = useCallback(
    debounce((searchTerm) => onSearch(searchTerm), 300),
    [onSearch]
  );

  useEffect(() => {
    debouncedSearch(value);
  }, [value, debouncedSearch]);

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
      placeholder="搜索用户..."
    />
  );
};

// 3. 内存泄漏防护
const DataFetcher = ({ userId }) => {
  const [data, setData] = useState(null);

  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const result = await response.json();

        if (!cancelled) {
          setData(result);
        }
      } catch (error) {
        console.error('Fetch error:', error);
      }
    };

    fetchData();

    return () => {
      cancelled = true; // 防止内存泄漏
    };
  }, [userId]);

  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
};

// 4. 虚拟滚动（使用react-window）
import { FixedSizeList as List } from 'react-window';

const VirtualList = ({ items }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={50}
    >
      {Row}
    </List>
  );
};
```

## 性能监控和分析

<Callout type="info">
性能监控帮助我们了解应用在真实环境中的表现，及时发现和解决性能问题。
</Callout>

### 性能监控实施

#### 监控指标体系

| 监控层面 | 关键指标 | 监控工具 |
|----------|----------|----------|
| **用户体验** | Core Web Vitals | web-vitals库 |
| **资源加载** | 资源大小、加载时间 | Performance API |
| **错误监控** | JavaScript错误 | Sentry, Bugsnag |
| **业务指标** | 转化率、跳出率 | Google Analytics |

```javascript
// 简化的性能监控实现
import { onLCP, onFID, onCLS } from 'web-vitals';

class SimplePerformanceMonitor {
  constructor() {
    this.setupWebVitals();
  }

  setupWebVitals() {
    onLCP(this.sendMetric);
    onFID(this.sendMetric);
    onCLS(this.sendMetric);
  }

  sendMetric(metric) {
    // 发送到分析服务
    fetch('/api/analytics/performance', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: metric.name,
        value: metric.value,
        rating: metric.rating,
        timestamp: Date.now()
      })
    });
  }
}

```

### 性能优化工具链

#### 开发阶段工具

| 工具 | 用途 | 特点 |
|------|------|------|
| **Lighthouse** | 性能审计 | 全面的性能评估 |
| **Chrome DevTools** | 性能调试 | 实时性能分析 |
| **Webpack Bundle Analyzer** | 包分析 | 可视化包大小 |
| **React DevTools Profiler** | React性能 | 组件渲染分析 |

#### 生产环境监控

| 工具 | 用途 | 特点 |
|------|------|------|
| **Google Analytics** | 用户体验监控 | Core Web Vitals |
| **Sentry** | 错误监控 | 性能问题追踪 |
| **New Relic** | APM监控 | 全栈性能监控 |
| **DataDog** | 基础设施监控 | 服务器性能 |

```javascript
// 简化的性能监控初始化
class PerformanceTracker {
  static init() {
    // 初始化Web Vitals监控
    new SimplePerformanceMonitor();

    // 初始化错误监控
    window.addEventListener('error', (event) => {
      console.error('JavaScript Error:', event.error);
    });

    // 初始化资源监控
    new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 1000) {
          console.warn('Slow resource:', entry.name);
        }
      });
    }).observe({ entryTypes: ['resource'] });
  }
}

// 初始化性能监控
PerformanceTracker.init();
```

---

<Callout type="success">
性能优化是一个持续的过程，需要结合监控数据、用户反馈和业务需求来制定合适的优化策略。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [Web.dev Performance](https://web.dev/performance/) - Google Web性能指南
- [Core Web Vitals](https://web.dev/vitals/) - 核心Web指标
- [MDN Performance](https://developer.mozilla.org/en-US/docs/Web/Performance) - MDN性能文档
- [Chrome DevTools](https://developer.chrome.com/docs/devtools/performance/) - Chrome性能调试工具

### 🎓 优质教程
- [Frontend Performance](https://frontendmasters.com/courses/web-performance/) - Frontend Masters性能课程
- [Performance Budget](https://web.dev/performance-budgets-101/) - 性能预算指南
- [Image Optimization](https://web.dev/fast/#optimize-your-images) - 图片优化指南

### 🛠️ 实践项目
- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - Google性能审计工具
- [WebPageTest](https://www.webpagetest.org/) - Web性能测试工具
- [Performance Monitoring](https://github.com/GoogleChrome/web-vitals) - Web Vitals监控库

### 🔧 开发工具
- [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci) - 持续集成性能测试
- [Bundle Analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) - Webpack包分析
- [Perfume.js](https://zizzamia.github.io/perfume/) - 性能监控库
- [SpeedCurve](https://speedcurve.com/) - 性能监控平台

### 📝 深入阅读
- [High Performance Browser Networking](https://hpbn.co/) - 高性能浏览器网络
- [Performance Patterns](https://web.dev/patterns/performance/) - 性能优化模式
- [Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path) - 关键渲染路径

<Callout type="tip">
💡 **学习建议**：建议从Core Web Vitals开始了解性能指标，学习使用Lighthouse进行性能审计，然后掌握各种优化技术，最后建立性能监控体系。
</Callout>
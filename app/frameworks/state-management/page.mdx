import { Callout } from 'nextra/components'

# 10. 状态管理深入

## 📋 目录

- [状态管理概念和模式](#状态管理概念和模式)
- [Redux生态系统](#redux生态系统)
- [现代状态管理方案](#现代状态管理方案)
- [状态管理方案对比](#状态管理方案对比)
- [最佳实践和选择指南](#最佳实践和选择指南)
- [服务端状态管理](#服务端状态管理)

## 状态管理概念和模式

<Callout type="info">
状态管理是现代前端应用的核心问题，选择合适的状态管理方案能够显著提升开发效率和应用性能。
</Callout>

### 状态管理的核心概念

```javascript
// 状态管理的基本模式

// 1. 单向数据流
/*
Action → Dispatcher → Store → View → Action
*/

// 2. 状态的分类
const stateTypes = {
  // 本地状态（组件内部状态）
  local: {
    formData: {},
    isModalOpen: false,
    inputValue: ''
  },
  
  // 全局状态（应用级状态）
  global: {
    user: null,
    theme: 'light',
    language: 'zh-CN'
  },
  
  // 服务端状态（远程数据）
  server: {
    users: [],
    posts: [],
    loading: false,
    error: null
  },
  
  // URL状态（路由状态）
  url: {
    pathname: '/users',
    search: '?page=1&limit=10',
    hash: '#section1'
  }
};

// 3. 状态管理的挑战
const challenges = {
  // 状态同步
  synchronization: '多个组件需要访问同一状态',
  
  // 状态持久化
  persistence: '状态需要在页面刷新后保持',
  
  // 状态预测性
  predictability: '状态变化需要可预测和可调试',
  
  // 性能优化
  performance: '避免不必要的重新渲染',
  
  // 开发体验
  devExperience: '良好的调试工具和开发体验'
};
```

### 状态管理模式

```javascript
// 1. Flux模式
class FluxStore {
  constructor() {
    this.state = {};
    this.listeners = [];
  }
  
  getState() {
    return this.state;
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  emit() {
    this.listeners.forEach(listener => listener());
  }
  
  reduce(action) {
    // 子类实现
    throw new Error('reduce method must be implemented');
  }
}

class UserStore extends FluxStore {
  constructor() {
    super();
    this.state = {
      users: [],
      loading: false,
      error: null
    };
  }
  
  reduce(action) {
    switch (action.type) {
      case 'FETCH_USERS_START':
        this.state = {
          ...this.state,
          loading: true,
          error: null
        };
        break;
        
      case 'FETCH_USERS_SUCCESS':
        this.state = {
          ...this.state,
          users: action.payload,
          loading: false
        };
        break;
        
      case 'FETCH_USERS_ERROR':
        this.state = {
          ...this.state,
          loading: false,
          error: action.payload
        };
        break;
    }
    
    this.emit();
  }
}

// 2. 观察者模式
class Observable {
  constructor(initialValue) {
    this.value = initialValue;
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(obs => obs !== observer);
    };
  }
  
  next(newValue) {
    this.value = newValue;
    this.observers.forEach(observer => observer(newValue));
  }
  
  map(fn) {
    const mapped = new Observable(fn(this.value));
    this.subscribe(value => mapped.next(fn(value)));
    return mapped;
  }
  
  filter(predicate) {
    const filtered = new Observable(
      predicate(this.value) ? this.value : undefined
    );
    this.subscribe(value => {
      if (predicate(value)) {
        filtered.next(value);
      }
    });
    return filtered;
  }
}

// 使用示例
const userCount$ = new Observable(0);
const evenUserCount$ = userCount$.filter(count => count % 2 === 0);

userCount$.subscribe(count => console.log('用户数量:', count));
evenUserCount$.subscribe(count => console.log('偶数用户数量:', count));

userCount$.next(1); // 输出: 用户数量: 1
userCount$.next(2); // 输出: 用户数量: 2, 偶数用户数量: 2
```

## Redux生态系统

### Redux Toolkit现代化实践

<Callout type="warning">
Redux Toolkit是Redux官方推荐的现代化工具集，大大简化了Redux的使用复杂度。
</Callout>

```javascript
// 1. 使用createSlice创建状态切片
import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';

// 异步thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (params, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/users?${new URLSearchParams(params)}`);
      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const createUser = createAsyncThunk(
  'users/createUser',
  async (userData, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      
      if (!response.ok) {
        throw new Error('Failed to create user');
      }
      
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 状态切片
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    items: [],
    loading: false,
    error: null,
    filters: {
      search: '',
      role: 'all',
      status: 'all'
    },
    pagination: {
      page: 1,
      limit: 10,
      total: 0
    }
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      state.pagination.page = 1; // 重置页码
    },
    
    setPagination: (state, action) => {
      state.pagination = { ...state.pagination, ...action.payload };
    },
    
    clearError: (state) => {
      state.error = null;
    },
    
    updateUser: (state, action) => {
      const { id, updates } = action.payload;
      const userIndex = state.items.findIndex(user => user.id === id);
      if (userIndex !== -1) {
        state.items[userIndex] = { ...state.items[userIndex], ...updates };
      }
    },
    
    removeUser: (state, action) => {
      state.items = state.items.filter(user => user.id !== action.payload);
    }
  },
  extraReducers: (builder) => {
    builder
      // fetchUsers
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.data;
        state.pagination.total = action.payload.total;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      
      // createUser
      .addCase(createUser.fulfilled, (state, action) => {
        state.items.unshift(action.payload);
        state.pagination.total += 1;
      });
  }
});

export const { setFilters, setPagination, clearError, updateUser, removeUser } = usersSlice.actions;
export default usersSlice.reducer;

// 2. Selectors
export const selectUsers = (state) => state.users.items;
export const selectUsersLoading = (state) => state.users.loading;
export const selectUsersError = (state) => state.users.error;
export const selectUsersFilters = (state) => state.users.filters;
export const selectUsersPagination = (state) => state.users.pagination;

// 记忆化选择器
export const selectFilteredUsers = createSelector(
  [selectUsers, selectUsersFilters],
  (users, filters) => {
    return users.filter(user => {
      const matchesSearch = !filters.search || 
        user.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        user.email.toLowerCase().includes(filters.search.toLowerCase());
      
      const matchesRole = filters.role === 'all' || user.role === filters.role;
      const matchesStatus = filters.status === 'all' || user.status === filters.status;
      
      return matchesSearch && matchesRole && matchesStatus;
    });
  }
);

export const selectUserById = createSelector(
  [selectUsers, (state, userId) => userId],
  (users, userId) => users.find(user => user.id === userId)
);

export const selectUsersStats = createSelector(
  [selectUsers],
  (users) => ({
    total: users.length,
    active: users.filter(user => user.status === 'active').length,
    inactive: users.filter(user => user.status === 'inactive').length,
    admins: users.filter(user => user.role === 'admin').length
  })
);

// 3. Store配置
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'settings'] // 只持久化这些reducer
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    }).concat(
      // 自定义中间件
      loggerMiddleware,
      errorMiddleware
    ),
  devTools: process.env.NODE_ENV !== 'production'
});

export const persistor = persistStore(store);

// 4. 自定义中间件
const loggerMiddleware = (store) => (next) => (action) => {
  console.group(action.type);
  console.info('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  console.groupEnd();
  return result;
};

const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error('Redux error:', error);
    // 可以发送错误到监控服务
    throw error;
  }
};

// 5. React组件中使用
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

function UserList() {
  const dispatch = useDispatch();
  const users = useSelector(selectFilteredUsers);
  const loading = useSelector(selectUsersLoading);
  const error = useSelector(selectUsersError);
  const filters = useSelector(selectUsersFilters);
  const pagination = useSelector(selectUsersPagination);
  const stats = useSelector(selectUsersStats);
  
  useEffect(() => {
    dispatch(fetchUsers({ 
      page: pagination.page, 
      limit: pagination.limit,
      ...filters 
    }));
  }, [dispatch, pagination.page, pagination.limit, filters]);
  
  const handleFilterChange = (newFilters) => {
    dispatch(setFilters(newFilters));
  };
  
  const handlePageChange = (page) => {
    dispatch(setPagination({ page }));
  };
  
  const handleCreateUser = (userData) => {
    dispatch(createUser(userData));
  };
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <UserStats stats={stats} />
      <UserFilters filters={filters} onChange={handleFilterChange} />
      <UserTable users={users} />
      <Pagination 
        current={pagination.page}
        total={pagination.total}
        pageSize={pagination.limit}
        onChange={handlePageChange}
      />
    </div>
  );
}
```

## 现代状态管理方案

### Zustand - 轻量级状态管理

```javascript
// 1. 基础Zustand store
import { create } from 'zustand';
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

const useUserStore = create()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // 状态
          users: [],
          loading: false,
          error: null,
          filters: {
            search: '',
            role: 'all'
          },
          
          // 动作
          setUsers: (users) => set((state) => {
            state.users = users;
          }),
          
          addUser: (user) => set((state) => {
            state.users.push(user);
          }),
          
          updateUser: (id, updates) => set((state) => {
            const userIndex = state.users.findIndex(u => u.id === id);
            if (userIndex !== -1) {
              Object.assign(state.users[userIndex], updates);
            }
          }),
          
          removeUser: (id) => set((state) => {
            state.users = state.users.filter(u => u.id !== id);
          }),
          
          setFilters: (filters) => set((state) => {
            Object.assign(state.filters, filters);
          }),
          
          setLoading: (loading) => set({ loading }),
          setError: (error) => set({ error }),
          
          // 异步动作
          fetchUsers: async () => {
            const { setLoading, setError, setUsers } = get();
            
            setLoading(true);
            setError(null);
            
            try {
              const response = await fetch('/api/users');
              const users = await response.json();
              setUsers(users);
            } catch (error) {
              setError(error.message);
            } finally {
              setLoading(false);
            }
          },
          
          // 计算属性
          get filteredUsers() {
            const { users, filters } = get();
            return users.filter(user => {
              const matchesSearch = !filters.search || 
                user.name.toLowerCase().includes(filters.search.toLowerCase());
              const matchesRole = filters.role === 'all' || user.role === filters.role;
              return matchesSearch && matchesRole;
            });
          }
        }))
      ),
      {
        name: 'user-store',
        partialize: (state) => ({ 
          filters: state.filters 
        })
      }
    ),
    {
      name: 'user-store'
    }
  )
);

// 2. 分片store模式
const createUserSlice = (set, get) => ({
  users: [],
  addUser: (user) => set((state) => ({ 
    users: [...state.users, user] 
  })),
  removeUser: (id) => set((state) => ({ 
    users: state.users.filter(u => u.id !== id) 
  }))
});

const createAuthSlice = (set, get) => ({
  user: null,
  token: null,
  login: async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    const { user, token } = await response.json();
    set({ user, token });
  },
  logout: () => set({ user: null, token: null })
});

const useAppStore = create()(
  devtools(
    (...args) => ({
      ...createUserSlice(...args),
      ...createAuthSlice(...args)
    })
  )
);

// 3. 选择器和订阅
import { useShallow } from 'zustand/react/shallow';

function UserComponent() {
  // 浅比较选择器
  const { users, addUser, removeUser } = useUserStore(
    useShallow((state) => ({
      users: state.users,
      addUser: state.addUser,
      removeUser: state.removeUser
    }))
  );
  
  // 订阅特定状态变化
  useEffect(() => {
    const unsubscribe = useUserStore.subscribe(
      (state) => state.users.length,
      (userCount) => {
        console.log('用户数量变化:', userCount);
      }
    );
    
    return unsubscribe;
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onRemove={() => removeUser(user.id)}
        />
      ))}
    </div>
  );
}
```

### Jotai - 原子化状态管理

```javascript
// 1. 原子定义
import { atom, selector } from 'jotai';

// 基础原子
export const usersAtom = atom([]);
export const loadingAtom = atom(false);
export const errorAtom = atom(null);
export const searchAtom = atom('');
export const roleFilterAtom = atom('all');

// 派生原子
export const filteredUsersAtom = atom((get) => {
  const users = get(usersAtom);
  const search = get(searchAtom);
  const roleFilter = get(roleFilterAtom);
  
  return users.filter(user => {
    const matchesSearch = !search || 
      user.name.toLowerCase().includes(search.toLowerCase());
    const matchesRole = roleFilter === 'all' || user.role === roleFilter;
    return matchesSearch && matchesRole;
  });
});

export const userStatsAtom = atom((get) => {
  const users = get(usersAtom);
  return {
    total: users.length,
    active: users.filter(u => u.status === 'active').length,
    admins: users.filter(u => u.role === 'admin').length
  };
});

// 异步原子
export const fetchUsersAtom = atom(
  null,
  async (get, set) => {
    set(loadingAtom, true);
    set(errorAtom, null);
    
    try {
      const response = await fetch('/api/users');
      const users = await response.json();
      set(usersAtom, users);
    } catch (error) {
      set(errorAtom, error.message);
    } finally {
      set(loadingAtom, false);
    }
  }
);

export const addUserAtom = atom(
  null,
  async (get, set, newUser) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser)
      });
      const user = await response.json();
      
      const currentUsers = get(usersAtom);
      set(usersAtom, [...currentUsers, user]);
      
      return user;
    } catch (error) {
      set(errorAtom, error.message);
      throw error;
    }
  }
);

// 2. 组件中使用
import { useAtom, useAtomValue, useSetAtom } from 'jotai';

function UserList() {
  const [users, setUsers] = useAtom(usersAtom);
  const filteredUsers = useAtomValue(filteredUsersAtom);
  const loading = useAtomValue(loadingAtom);
  const error = useAtomValue(errorAtom);
  const stats = useAtomValue(userStatsAtom);
  
  const fetchUsers = useSetAtom(fetchUsersAtom);
  const addUser = useSetAtom(addUserAtom);
  
  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);
  
  const handleAddUser = async (userData) => {
    try {
      await addUser(userData);
      console.log('用户添加成功');
    } catch (error) {
      console.error('添加用户失败:', error);
    }
  };
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <UserStats stats={stats} />
      <UserFilters />
      <div>
        {filteredUsers.map(user => (
          <UserCard key={user.id} user={user} />
        ))}
      </div>
    </div>
  );
}

function UserFilters() {
  const [search, setSearch] = useAtom(searchAtom);
  const [roleFilter, setRoleFilter] = useAtom(roleFilterAtom);
  
  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="搜索用户..."
      />
      <select
        value={roleFilter}
        onChange={(e) => setRoleFilter(e.target.value)}
      >
        <option value="all">所有角色</option>
        <option value="admin">管理员</option>
        <option value="user">普通用户</option>
      </select>
    </div>
  );
}

// 3. 原子的持久化
import { atomWithStorage } from 'jotai/utils';

export const themeAtom = atomWithStorage('theme', 'light');
export const settingsAtom = atomWithStorage('settings', {
  language: 'zh-CN',
  notifications: true
});

// 4. 原子的重置
import { RESET } from 'jotai/utils';

export const resetUsersAtom = atom(null, (get, set) => {
  set(usersAtom, RESET);
  set(searchAtom, RESET);
  set(roleFilterAtom, RESET);
  set(errorAtom, RESET);
});
```

## 状态管理方案对比

### 方案选择矩阵

| 特性 | Redux Toolkit | Zustand | Jotai | Context API | Valtio |
|------|---------------|---------|-------|-------------|--------|
| **学习曲线** | 中等 | 简单 | 中等 | 简单 | 简单 |
| **包大小** | 大 | 小 | 小 | 无 | 小 |
| **TypeScript支持** | 优秀 | 优秀 | 优秀 | 良好 | 优秀 |
| **开发工具** | 优秀 | 良好 | 良好 | 无 | 良好 |
| **性能** | 良好 | 优秀 | 优秀 | 差 | 优秀 |
| **生态系统** | 丰富 | 中等 | 中等 | 丰富 | 小 |
| **适用场景** | 大型应用 | 中小型应用 | 复杂状态 | 简单状态 | 响应式应用 |

### 选择指南

```javascript
// 选择决策树
const stateManagementDecision = {
  // 1. 应用规模
  applicationSize: {
    small: {
      recommendation: 'useState + useContext',
      reason: '简单状态管理足够，避免过度工程化'
    },
    medium: {
      recommendation: 'Zustand',
      reason: '轻量级，易于使用，性能良好'
    },
    large: {
      recommendation: 'Redux Toolkit',
      reason: '成熟的生态系统，强大的开发工具'
    }
  },
  
  // 2. 团队经验
  teamExperience: {
    beginner: {
      recommendation: 'Zustand',
      reason: '学习曲线平缓，概念简单'
    },
    intermediate: {
      recommendation: 'Jotai 或 Zustand',
      reason: '可以处理更复杂的状态逻辑'
    },
    expert: {
      recommendation: 'Redux Toolkit',
      reason: '可以充分利用Redux的强大功能'
    }
  },
  
  // 3. 状态复杂度
  stateComplexity: {
    simple: {
      recommendation: 'useState + useContext',
      reason: '内置解决方案足够'
    },
    moderate: {
      recommendation: 'Zustand',
      reason: '平衡了简单性和功能性'
    },
    complex: {
      recommendation: 'Redux Toolkit 或 Jotai',
      reason: '强大的状态管理能力'
    }
  },
  
  // 4. 性能要求
  performanceRequirements: {
    low: {
      recommendation: '任何方案',
      reason: '性能不是主要考虑因素'
    },
    high: {
      recommendation: 'Jotai 或 Valtio',
      reason: '细粒度更新，避免不必要的重渲染'
    }
  }
};

// 实际选择示例
function chooseStateManagement(requirements) {
  const {
    appSize,
    teamSize,
    complexity,
    performance,
    timeline
  } = requirements;
  
  // 快速原型或小项目
  if (timeline === 'short' && appSize === 'small') {
    return {
      solution: 'useState + useContext',
      reason: '快速开发，无需额外依赖'
    };
  }
  
  // 中型项目，注重开发体验
  if (appSize === 'medium' && teamSize <= 5) {
    return {
      solution: 'Zustand',
      reason: '简单易用，性能良好，学习成本低'
    };
  }
  
  // 大型企业应用
  if (appSize === 'large' && teamSize > 5) {
    return {
      solution: 'Redux Toolkit',
      reason: '成熟稳定，工具链完善，团队协作友好'
    };
  }
  
  // 高性能要求
  if (performance === 'critical') {
    return {
      solution: 'Jotai',
      reason: '原子化状态，精确控制重渲染'
    };
  }
  
  // 默认推荐
  return {
    solution: 'Zustand',
    reason: '平衡了所有方面的需求'
  };
}
```

## 最佳实践和选择指南

<Callout type="info">
选择状态管理方案需要考虑应用规模、团队经验、性能要求等多个维度。
</Callout>

### 选择决策树

```javascript
// 状态管理方案选择指南
function chooseStateManagement(appContext) {
  const {
    teamSize,
    appComplexity,
    performanceRequirements,
    teamExperience,
    framework
  } = appContext;

  // 小型应用
  if (appComplexity === 'simple' && teamSize <= 3) {
    return framework === 'react'
      ? 'useState + useContext'
      : 'Vue reactive + provide/inject';
  }

  // 中型应用
  if (appComplexity === 'medium' && teamSize <= 10) {
    return framework === 'react'
      ? ['Zustand', 'Jotai', 'Valtio']
      : ['Pinia', 'Vuex'];
  }

  // 大型应用
  if (appComplexity === 'complex' || teamSize > 10) {
    return framework === 'react'
      ? ['Redux Toolkit', 'MobX']
      : ['Pinia', 'Vuex'];
  }

  // 高性能要求
  if (performanceRequirements === 'high') {
    return ['Valtio', 'Jotai', 'MobX'];
  }
}
```

### 最佳实践原则

```javascript
// 1. 状态结构设计
const goodStateStructure = {
  // 扁平化结构
  users: {
    byId: {
      '1': { id: '1', name: 'John' },
      '2': { id: '2', name: 'Jane' }
    },
    allIds: ['1', '2']
  },

  // 分离UI状态和业务状态
  ui: {
    loading: false,
    selectedUserId: '1',
    filters: {
      status: 'active',
      role: 'admin'
    }
  }
};

// 2. 避免深度嵌套
const badStateStructure = {
  users: [
    {
      id: '1',
      profile: {
        personal: {
          name: 'John',
          address: {
            street: '123 Main St',
            city: 'New York'
          }
        }
      }
    }
  ]
};

// 3. 使用选择器优化性能
import { createSelector } from '@reduxjs/toolkit';

const selectUsers = (state) => state.users.byId;
const selectUserIds = (state) => state.users.allIds;
const selectActiveFilter = (state) => state.ui.filters.status;

const selectActiveUsers = createSelector(
  [selectUsers, selectUserIds, selectActiveFilter],
  (users, userIds, activeFilter) => {
    return userIds
      .map(id => users[id])
      .filter(user => user.status === activeFilter);
  }
);
```

## 服务端状态管理

<Callout type="info">
服务端状态管理专注于处理异步数据获取、缓存、同步等问题，与客户端状态管理有不同的关注点。
</Callout>

### React Query / TanStack Query

```javascript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// 数据获取
function UserProfile({ userId }) {
  const {
    data: user,
    isLoading,
    error,
    refetch
  } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5分钟内数据被认为是新鲜的
    cacheTime: 10 * 60 * 1000, // 10分钟后清除缓存
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{user.name}</div>;
}

// 数据变更
function UpdateUserForm({ userId }) {
  const queryClient = useQueryClient();

  const updateUserMutation = useMutation({
    mutationFn: updateUser,
    onSuccess: (data) => {
      // 更新缓存
      queryClient.setQueryData(['user', userId], data);

      // 或者重新获取
      queryClient.invalidateQueries(['user', userId]);

      // 乐观更新
      queryClient.setQueryData(['users'], (oldData) => {
        return oldData.map(user =>
          user.id === userId ? { ...user, ...data } : user
        );
      });
    },
    onError: (error) => {
      console.error('Update failed:', error);
    }
  });

  const handleSubmit = (formData) => {
    updateUserMutation.mutate({ userId, ...formData });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 表单内容 */}
      <button
        type="submit"
        disabled={updateUserMutation.isLoading}
      >
        {updateUserMutation.isLoading ? 'Updating...' : 'Update'}
      </button>
    </form>
  );
}
```

### SWR

```javascript
import useSWR, { mutate } from 'swr';

const fetcher = (url) => fetch(url).then(res => res.json());

function UserList() {
  const { data: users, error, isLoading } = useSWR('/api/users', fetcher, {
    refreshInterval: 30000, // 30秒自动刷新
    revalidateOnFocus: true, // 窗口获得焦点时重新验证
    revalidateOnReconnect: true, // 网络重连时重新验证
    dedupingInterval: 2000, // 2秒内的重复请求会被去重
  });

  const deleteUser = async (userId) => {
    // 乐观更新
    const updatedUsers = users.filter(user => user.id !== userId);
    mutate('/api/users', updatedUsers, false);

    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      // 重新验证数据
      mutate('/api/users');
    } catch (error) {
      // 回滚乐观更新
      mutate('/api/users');
      console.error('Delete failed:', error);
    }
  };

  if (error) return <div>Failed to load users</div>;
  if (isLoading) return <div>Loading...</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => deleteUser(user.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Apollo Client (GraphQL)

```javascript
import { useQuery, useMutation, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers($filter: UserFilter) {
    users(filter: $filter) {
      id
      name
      email
      status
    }
  }
`;

const UPDATE_USER = gql`
  mutation UpdateUser($id: ID!, $input: UserInput!) {
    updateUser(id: $id, input: $input) {
      id
      name
      email
      status
    }
  }
`;

function UserManagement() {
  const { loading, error, data, refetch } = useQuery(GET_USERS, {
    variables: { filter: { status: 'ACTIVE' } },
    pollInterval: 30000, // 30秒轮询
    errorPolicy: 'partial', // 部分数据也显示
    fetchPolicy: 'cache-and-network' // 先显示缓存，然后网络请求
  });

  const [updateUser] = useMutation(UPDATE_USER, {
    update(cache, { data: { updateUser } }) {
      // 更新Apollo缓存
      cache.modify({
        fields: {
          users(existingUsers = []) {
            return existingUsers.map(user =>
              user.__ref === cache.identify(updateUser)
                ? updateUser
                : user
            );
          }
        }
      });
    },
    optimisticResponse: (variables) => ({
      updateUser: {
        __typename: 'User',
        id: variables.id,
        ...variables.input
      }
    })
  });

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {data.users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onUpdate={updateUser}
        />
      ))}
    </div>
  );
}
```

---

<Callout type="success">
选择合适的状态管理方案需要综合考虑应用规模、团队经验、性能要求等多个因素。没有银弹，只有最适合的解决方案。
</Callout>

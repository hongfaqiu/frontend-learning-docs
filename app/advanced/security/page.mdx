import { Callout } from 'nextra/components'

# 17. å‰ç«¯å®‰å…¨å’Œæœ€ä½³å®è·µ

## ğŸ“‹ ç›®å½•

- [å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ](#å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ)
- [XSSæ”»å‡»é˜²æŠ¤](#xssæ”»å‡»é˜²æŠ¤)
- [CSRFæ”»å‡»é˜²æŠ¤](#csrfæ”»å‡»é˜²æŠ¤)
- [å†…å®¹å®‰å…¨ç­–ç•¥CSP](#å†…å®¹å®‰å…¨ç­–ç•¥csp)
- [æ•°æ®ä¼ è¾“å®‰å…¨](#æ•°æ®ä¼ è¾“å®‰å…¨)
- [å®‰å…¨å¼€å‘æœ€ä½³å®è·µ](#å®‰å…¨å¼€å‘æœ€ä½³å®è·µ)

## ğŸ›¡ï¸ å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ

<Callout type="warning">
å‰ç«¯å®‰å…¨æ˜¯Webåº”ç”¨å®‰å…¨çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œäº†è§£å¸¸è§å¨èƒå’Œé˜²æŠ¤æªæ–½å¯¹äºæ„å»ºå®‰å…¨çš„Webåº”ç”¨è‡³å…³é‡è¦ã€‚
</Callout>

### å¸¸è§å®‰å…¨å¨èƒåˆ†ç±»

```javascript
// å‰ç«¯å®‰å…¨å¨èƒåˆ†ç±»å’Œé˜²æŠ¤ç­–ç•¥
const securityThreats = {
  // 1. æ³¨å…¥æ”»å‡»
  injection: {
    types: ['XSS', 'SQLæ³¨å…¥', 'NoSQLæ³¨å…¥', 'LDAPæ³¨å…¥'],
    description: 'æ¶æ„ä»£ç æ³¨å…¥åˆ°åº”ç”¨ä¸­æ‰§è¡Œ',
    impact: 'æ•°æ®æ³„éœ²ã€ä¼šè¯åŠ«æŒã€æ¶æ„æ“ä½œ',
    prevention: [
      'è¾“å…¥éªŒè¯å’Œè¿‡æ»¤',
      'è¾“å‡ºç¼–ç ',
      'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢',
      'å†…å®¹å®‰å…¨ç­–ç•¥'
    ]
  },
  
  // 2. èº«ä»½è®¤è¯ç¼ºé™·
  authentication: {
    types: ['å¼±å¯†ç ', 'ä¼šè¯ç®¡ç†ç¼ºé™·', 'æš´åŠ›ç ´è§£'],
    description: 'èº«ä»½éªŒè¯æœºåˆ¶å­˜åœ¨æ¼æ´',
    impact: 'è´¦æˆ·è¢«ç›—ã€æœªæˆæƒè®¿é—®',
    prevention: [
      'å¼ºå¯†ç ç­–ç•¥',
      'å¤šå› ç´ è®¤è¯',
      'ä¼šè¯è¶…æ—¶',
      'è´¦æˆ·é”å®šæœºåˆ¶'
    ]
  },
  
  // 3. æ•æ„Ÿæ•°æ®æš´éœ²
  dataExposure: {
    types: ['æ˜æ–‡ä¼ è¾“', 'ä¸å½“å­˜å‚¨', 'ç¼“å­˜æ³„éœ²'],
    description: 'æ•æ„Ÿæ•°æ®æœªå¾—åˆ°é€‚å½“ä¿æŠ¤',
    impact: 'éšç§æ³„éœ²ã€åˆè§„é£é™©',
    prevention: [
      'HTTPSä¼ è¾“',
      'æ•°æ®åŠ å¯†',
      'å®‰å…¨å­˜å‚¨',
      'è®¿é—®æ§åˆ¶'
    ]
  },
  
  // 4. è·¨ç«™è¯·æ±‚ä¼ªé€ 
  csrf: {
    types: ['GETå‹CSRF', 'POSTå‹CSRF', 'JSON CSRF'],
    description: 'è¯±å¯¼ç”¨æˆ·æ‰§è¡Œéé¢„æœŸæ“ä½œ',
    impact: 'æ¶æ„æ“ä½œã€æ•°æ®ç¯¡æ”¹',
    prevention: [
      'CSRF Token',
      'SameSite Cookie',
      'éªŒè¯Referer',
      'åŒé‡æäº¤Cookie'
    ]
  },
  
  // 5. å®‰å…¨é…ç½®é”™è¯¯
  misconfiguration: {
    types: ['é»˜è®¤é…ç½®', 'é”™è¯¯æƒé™', 'è°ƒè¯•ä¿¡æ¯æ³„éœ²'],
    description: 'å®‰å…¨é…ç½®ä¸å½“å¯¼è‡´çš„æ¼æ´',
    impact: 'ç³»ç»Ÿæš´éœ²ã€ä¿¡æ¯æ³„éœ²',
    prevention: [
      'å®‰å…¨é…ç½®æ£€æŸ¥',
      'æœ€å°æƒé™åŸåˆ™',
      'å®šæœŸå®‰å…¨å®¡è®¡',
      'é”™è¯¯å¤„ç†ä¼˜åŒ–'
    ]
  }
};

// å®‰å…¨è¯„ä¼°å·¥å…·
class SecurityAssessment {
  constructor() {
    this.vulnerabilities = [];
    this.securityScore = 0;
  }
  
  // æ‰§è¡Œå®‰å…¨è¯„ä¼°
  async performAssessment() {
    console.log('å¼€å§‹å®‰å…¨è¯„ä¼°...');
    
    await this.checkXSSVulnerabilities();
    await this.checkCSRFProtection();
    await this.checkHTTPSUsage();
    await this.checkContentSecurityPolicy();
    await this.checkCookieSecurity();
    await this.checkDependencyVulnerabilities();
    
    this.calculateSecurityScore();
    return this.generateReport();
  }
  
  async checkXSSVulnerabilities() {
    // æ£€æŸ¥æ½œåœ¨çš„XSSæ¼æ´
    const inputs = document.querySelectorAll('input, textarea');
    const outputs = document.querySelectorAll('[data-user-content]');
    
    inputs.forEach(input => {
      if (!input.hasAttribute('data-sanitized')) {
        this.vulnerabilities.push({
          type: 'XSS',
          severity: 'high',
          element: input,
          description: 'ç”¨æˆ·è¾“å…¥æœªè¿›è¡Œé€‚å½“çš„éªŒè¯å’Œè¿‡æ»¤'
        });
      }
    });
    
    outputs.forEach(output => {
      if (output.innerHTML.includes('<script>')) {
        this.vulnerabilities.push({
          type: 'XSS',
          severity: 'critical',
          element: output,
          description: 'æ£€æµ‹åˆ°å¯èƒ½çš„è„šæœ¬æ³¨å…¥'
        });
      }
    });
  }
  
  async checkCSRFProtection() {
    // æ£€æŸ¥CSRFä¿æŠ¤
    const forms = document.querySelectorAll('form');
    
    forms.forEach(form => {
      const csrfToken = form.querySelector('input[name="csrf_token"], input[name="_token"]');
      if (!csrfToken && form.method.toLowerCase() === 'post') {
        this.vulnerabilities.push({
          type: 'CSRF',
          severity: 'medium',
          element: form,
          description: 'POSTè¡¨å•ç¼ºå°‘CSRFä»¤ç‰Œä¿æŠ¤'
        });
      }
    });
  }
  
  async checkHTTPSUsage() {
    // æ£€æŸ¥HTTPSä½¿ç”¨æƒ…å†µ
    if (location.protocol !== 'https:') {
      this.vulnerabilities.push({
        type: 'Transport Security',
        severity: 'high',
        description: 'ç½‘ç«™æœªä½¿ç”¨HTTPSåŠ å¯†ä¼ è¾“'
      });
    }
    
    // æ£€æŸ¥æ··åˆå†…å®¹
    const resources = performance.getEntriesByType('resource');
    resources.forEach(resource => {
      if (resource.name.startsWith('http://')) {
        this.vulnerabilities.push({
          type: 'Mixed Content',
          severity: 'medium',
          description: `æ£€æµ‹åˆ°HTTPèµ„æº: ${resource.name}`
        });
      }
    });
  }
  
  async checkContentSecurityPolicy() {
    // æ£€æŸ¥CSPé…ç½®
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = this.getResponseHeader('Content-Security-Policy');
    
    if (!cspMeta && !cspHeader) {
      this.vulnerabilities.push({
        type: 'CSP',
        severity: 'medium',
        description: 'æœªé…ç½®å†…å®¹å®‰å…¨ç­–ç•¥(CSP)'
      });
    }
  }
  
  async checkCookieSecurity() {
    // æ£€æŸ¥Cookieå®‰å…¨å±æ€§
    const cookies = document.cookie.split(';');
    
    cookies.forEach(cookie => {
      const [name] = cookie.trim().split('=');
      
      // è¿™é‡Œç®€åŒ–æ£€æŸ¥ï¼Œå®é™…åº”è¯¥æ£€æŸ¥Set-Cookieå¤´
      if (name && !cookie.includes('Secure')) {
        this.vulnerabilities.push({
          type: 'Cookie Security',
          severity: 'low',
          description: `Cookie ${name} ç¼ºå°‘Secureå±æ€§`
        });
      }
      
      if (name && !cookie.includes('HttpOnly')) {
        this.vulnerabilities.push({
          type: 'Cookie Security',
          severity: 'medium',
          description: `Cookie ${name} ç¼ºå°‘HttpOnlyå±æ€§`
        });
      }
    });
  }
  
  async checkDependencyVulnerabilities() {
    // æ£€æŸ¥å·²çŸ¥çš„ä¾èµ–æ¼æ´ï¼ˆéœ€è¦åç«¯æ”¯æŒï¼‰
    try {
      const response = await fetch('/api/security/check-dependencies');
      const vulnerabilities = await response.json();
      
      vulnerabilities.forEach(vuln => {
        this.vulnerabilities.push({
          type: 'Dependency',
          severity: vuln.severity,
          description: `ä¾èµ– ${vuln.package} å­˜åœ¨å·²çŸ¥æ¼æ´: ${vuln.title}`
        });
      });
    } catch (error) {
      console.warn('æ— æ³•æ£€æŸ¥ä¾èµ–æ¼æ´:', error);
    }
  }
  
  calculateSecurityScore() {
    const severityWeights = {
      critical: 10,
      high: 7,
      medium: 4,
      low: 1
    };
    
    const totalDeductions = this.vulnerabilities.reduce((sum, vuln) => {
      return sum + (severityWeights[vuln.severity] || 0);
    }, 0);
    
    this.securityScore = Math.max(0, 100 - totalDeductions);
  }
  
  generateReport() {
    return {
      score: this.securityScore,
      grade: this.getSecurityGrade(),
      vulnerabilities: this.vulnerabilities,
      summary: {
        total: this.vulnerabilities.length,
        critical: this.vulnerabilities.filter(v => v.severity === 'critical').length,
        high: this.vulnerabilities.filter(v => v.severity === 'high').length,
        medium: this.vulnerabilities.filter(v => v.severity === 'medium').length,
        low: this.vulnerabilities.filter(v => v.severity === 'low').length
      },
      recommendations: this.getRecommendations()
    };
  }
  
  getSecurityGrade() {
    if (this.securityScore >= 90) return 'A';
    if (this.securityScore >= 80) return 'B';
    if (this.securityScore >= 70) return 'C';
    if (this.securityScore >= 60) return 'D';
    return 'F';
  }
  
  getRecommendations() {
    const recommendations = [];
    
    if (this.vulnerabilities.some(v => v.type === 'XSS')) {
      recommendations.push('å®æ–½è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç ');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'CSRF')) {
      recommendations.push('æ·»åŠ CSRFä»¤ç‰Œä¿æŠ¤');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'Transport Security')) {
      recommendations.push('å¯ç”¨HTTPSå¹¶é…ç½®HSTS');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'CSP')) {
      recommendations.push('é…ç½®å†…å®¹å®‰å…¨ç­–ç•¥(CSP)');
    }
    
    return recommendations;
  }
  
  getResponseHeader(name) {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä»å“åº”å¤´è·å–
    return null;
  }
}
```

## ğŸ”’ XSSæ”»å‡»é˜²æŠ¤

### XSSé˜²æŠ¤å®ç°

```javascript
// 1. XSSé˜²æŠ¤å·¥å…·ç±»
class XSSProtection {
  constructor() {
    this.htmlEntities = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    
    this.setupGlobalProtection();
  }
  
  // è®¾ç½®å…¨å±€XSSé˜²æŠ¤
  setupGlobalProtection() {
    // é‡å†™innerHTML setter
    this.protectInnerHTML();
    
    // ç›‘æ§åŠ¨æ€å†…å®¹æ’å…¥
    this.monitorDOMChanges();
    
    // ä¿æŠ¤äº‹ä»¶å¤„ç†å™¨
    this.protectEventHandlers();
  }
  
  protectInnerHTML() {
    const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
    
    Object.defineProperty(Element.prototype, 'innerHTML', {
      set: function(value) {
        // æ£€æŸ¥æ˜¯å¦åŒ…å«æ½œåœ¨çš„XSSä»£ç 
        if (typeof value === 'string' && this.containsXSS(value)) {
          console.warn('æ£€æµ‹åˆ°æ½œåœ¨XSSæ”»å‡»ï¼Œå†…å®¹å·²è¢«è¿‡æ»¤');
          value = this.sanitizeHTML(value);
        }
        
        originalInnerHTML.set.call(this, value);
      }.bind(this),
      get: originalInnerHTML.get
    });
  }
  
  containsXSS(html) {
    const xssPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe\b[^>]*>/gi,
      /<object\b[^>]*>/gi,
      /<embed\b[^>]*>/gi,
      /<link\b[^>]*>/gi,
      /<meta\b[^>]*>/gi
    ];
    
    return xssPatterns.some(pattern => pattern.test(html));
  }
  
  // HTMLå†…å®¹æ¸…ç†
  sanitizeHTML(html) {
    // ç§»é™¤å±é™©æ ‡ç­¾
    const dangerousTags = [
      'script', 'iframe', 'object', 'embed', 'link', 'meta',
      'form', 'input', 'button', 'textarea', 'select'
    ];
    
    let sanitized = html;
    
    dangerousTags.forEach(tag => {
      const regex = new RegExp(`<${tag}\\b[^>]*>.*?<\\/${tag}>`, 'gi');
      sanitized = sanitized.replace(regex, '');
      
      const selfClosingRegex = new RegExp(`<${tag}\\b[^>]*\\/?>`, 'gi');
      sanitized = sanitized.replace(selfClosingRegex, '');
    });
    
    // ç§»é™¤å±é™©å±æ€§
    sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
    sanitized = sanitized.replace(/javascript:/gi, '');
    
    // HTMLå®ä½“ç¼–ç 
    return this.escapeHTML(sanitized);
  }
  
  // HTMLå®ä½“ç¼–ç 
  escapeHTML(text) {
    return String(text).replace(/[&<>"'\/]/g, (char) => {
      return this.htmlEntities[char] || char;
    });
  }
  
  // è§£ç HTMLå®ä½“
  unescapeHTML(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }
  
  // å®‰å…¨çš„DOMæ“ä½œ
  safeSetTextContent(element, text) {
    element.textContent = text;
  }
  
  safeSetHTML(element, html) {
    element.innerHTML = this.sanitizeHTML(html);
  }
  
  // åˆ›å»ºå®‰å…¨çš„å…ƒç´ 
  createSafeElement(tagName, attributes = {}, textContent = '') {
    const element = document.createElement(tagName);
    
    // å®‰å…¨è®¾ç½®å±æ€§
    Object.entries(attributes).forEach(([key, value]) => {
      if (this.isSafeAttribute(key, value)) {
        element.setAttribute(key, value);
      }
    });
    
    // å®‰å…¨è®¾ç½®æ–‡æœ¬å†…å®¹
    if (textContent) {
      element.textContent = textContent;
    }
    
    return element;
  }
  
  isSafeAttribute(name, value) {
    // å±é™©å±æ€§é»‘åå•
    const dangerousAttributes = [
      'onclick', 'onload', 'onerror', 'onmouseover',
      'onfocus', 'onblur', 'onchange', 'onsubmit'
    ];
    
    if (dangerousAttributes.includes(name.toLowerCase())) {
      return false;
    }
    
    // æ£€æŸ¥å±æ€§å€¼
    if (typeof value === 'string') {
      if (value.toLowerCase().includes('javascript:')) {
        return false;
      }
      
      if (value.toLowerCase().includes('data:text/html')) {
        return false;
      }
    }
    
    return true;
  }
  
  monitorDOMChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.scanElementForXSS(node);
          }
        });
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  scanElementForXSS(element) {
    // æ£€æŸ¥å…ƒç´ çš„innerHTML
    if (element.innerHTML && this.containsXSS(element.innerHTML)) {
      console.warn('æ£€æµ‹åˆ°åŠ¨æ€æ’å…¥çš„XSSå†…å®¹:', element);
      element.innerHTML = this.sanitizeHTML(element.innerHTML);
    }
    
    // æ£€æŸ¥å±æ€§
    Array.from(element.attributes).forEach(attr => {
      if (!this.isSafeAttribute(attr.name, attr.value)) {
        console.warn('ç§»é™¤å±é™©å±æ€§:', attr.name, attr.value);
        element.removeAttribute(attr.name);
      }
    });
  }
  
  protectEventHandlers() {
    // é‡å†™addEventListener
    const originalAddEventListener = EventTarget.prototype.addEventListener;
    
    EventTarget.prototype.addEventListener = function(type, listener, options) {
      // æ£€æŸ¥äº‹ä»¶å¤„ç†å™¨æ˜¯å¦å®‰å…¨
      if (typeof listener === 'string') {
        console.warn('é˜»æ­¢å­—ç¬¦ä¸²å½¢å¼çš„äº‹ä»¶å¤„ç†å™¨:', listener);
        return;
      }
      
      return originalAddEventListener.call(this, type, listener, options);
    };
  }
}

// 2. å†…å®¹å®‰å…¨ç­–ç•¥(CSP)åŠ©æ‰‹
class CSPHelper {
  constructor() {
    this.policy = {
      'default-src': ["'self'"],
      'script-src': ["'self'"],
      'style-src': ["'self'", "'unsafe-inline'"],
      'img-src': ["'self'", 'data:', 'https:'],
      'font-src': ["'self'"],
      'connect-src': ["'self'"],
      'frame-src': ["'none'"],
      'object-src': ["'none'"],
      'base-uri': ["'self'"],
      'form-action': ["'self'"]
    };
  }
  
  // ç”ŸæˆCSPå­—ç¬¦ä¸²
  generateCSP() {
    return Object.entries(this.policy)
      .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
      .join('; ');
  }
  
  // æ·»åŠ å…è®¸çš„æº
  addSource(directive, source) {
    if (this.policy[directive]) {
      if (!this.policy[directive].includes(source)) {
        this.policy[directive].push(source);
      }
    }
  }
  
  // ç§»é™¤æº
  removeSource(directive, source) {
    if (this.policy[directive]) {
      this.policy[directive] = this.policy[directive].filter(s => s !== source);
    }
  }
  
  // åº”ç”¨CSP
  applyCSP() {
    const csp = this.generateCSP();
    
    // é€šè¿‡metaæ ‡ç­¾åº”ç”¨
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = csp;
    document.head.appendChild(meta);
    
    console.log('åº”ç”¨CSP:', csp);
  }
  
  // ç›‘å¬CSPè¿è§„
  monitorViolations() {
    document.addEventListener('securitypolicyviolation', (event) => {
      console.error('CSPè¿è§„:', {
        directive: event.violatedDirective,
        blockedURI: event.blockedURI,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber
      });
      
      // å‘é€è¿è§„æŠ¥å‘Š
      this.reportViolation(event);
    });
  }
  
  reportViolation(event) {
    fetch('/api/security/csp-violation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        directive: event.violatedDirective,
        blockedURI: event.blockedURI,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        timestamp: Date.now(),
        userAgent: navigator.userAgent
      })
    }).catch(console.error);
  }
}

// 3. å®‰å…¨çš„æ¨¡æ¿æ¸²æŸ“
class SecureTemplateRenderer {
  constructor() {
    this.xssProtection = new XSSProtection();
  }
  
  // å®‰å…¨æ¸²æŸ“æ¨¡æ¿
  render(template, data) {
    let rendered = template;
    
    // æ›¿æ¢å˜é‡
    Object.entries(data).forEach(([key, value]) => {
      const placeholder = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
      const escapedValue = this.xssProtection.escapeHTML(String(value));
      rendered = rendered.replace(placeholder, escapedValue);
    });
    
    // å¤„ç†åŸå§‹HTMLï¼ˆéœ€è¦ç‰¹æ®Šæ ‡è®°ï¼‰
    rendered = rendered.replace(/{{{(\w+)}}}/g, (match, key) => {
      const value = data[key];
      if (value) {
        return this.xssProtection.sanitizeHTML(String(value));
      }
      return '';
    });
    
    return rendered;
  }
  
  // åˆ›å»ºå®‰å…¨çš„æ¨¡æ¿å‡½æ•°
  compile(template) {
    return (data) => this.render(template, data);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const xssProtection = new XSSProtection();
const cspHelper = new CSPHelper();
const templateRenderer = new SecureTemplateRenderer();

// åº”ç”¨å®‰å…¨ç­–ç•¥
cspHelper.applyCSP();
cspHelper.monitorViolations();

// å®‰å…¨æ¸²æŸ“ç”¨æˆ·å†…å®¹
const userContent = '<script>alert("XSS")</script>Hello World';
const safeContent = xssProtection.sanitizeHTML(userContent);
console.log('å®‰å…¨å†…å®¹:', safeContent); // Hello World

// å®‰å…¨æ¨¡æ¿æ¸²æŸ“
const template = '<div>Hello {{name}}, your message: {{message}}</div>';
const rendered = templateRenderer.render(template, {
  name: '<script>alert("XSS")</script>John',
  message: 'Welcome to our site!'
});
console.log('æ¸²æŸ“ç»“æœ:', rendered);
```

---

<Callout type="success">
å‰ç«¯å®‰å…¨éœ€è¦å¤šå±‚é˜²æŠ¤ï¼ŒåŒ…æ‹¬è¾“å…¥éªŒè¯ã€è¾“å‡ºç¼–ç ã€CSPé…ç½®ç­‰ã€‚å®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦å®šæœŸè¯„ä¼°å’Œæ›´æ–°é˜²æŠ¤æªæ–½ã€‚
</Callout>

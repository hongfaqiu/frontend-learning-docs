import { Callout } from 'nextra/components'

# 18. ç°ä»£å‰ç«¯æ¶æ„è®¾è®¡

## ğŸ“‹ ç›®å½•

- [å‰ç«¯æ¶æ„æ¼”è¿›å†ç¨‹](#å‰ç«¯æ¶æ„æ¼”è¿›å†ç¨‹)
- [å¾®å‰ç«¯æ¶æ„è®¾è®¡](#å¾®å‰ç«¯æ¶æ„è®¾è®¡)
- [ç»„ä»¶åŒ–æ¶æ„æ¨¡å¼](#ç»„ä»¶åŒ–æ¶æ„æ¨¡å¼)
- [æ¨¡å—åŒ–å’Œä¾èµ–ç®¡ç†](#æ¨¡å—åŒ–å’Œä¾èµ–ç®¡ç†)
- [å¯æ‰©å±•æ€§è®¾è®¡åŸåˆ™](#å¯æ‰©å±•æ€§è®¾è®¡åŸåˆ™)
- [æ¶æ„å†³ç­–å’Œæƒè¡¡](#æ¶æ„å†³ç­–å’Œæƒè¡¡)

## å‰ç«¯æ¶æ„æ¼”è¿›å†ç¨‹

<Callout type="info">
å‰ç«¯æ¶æ„ä»ç®€å•çš„é¡µé¢è„šæœ¬å‘å±•åˆ°å¤æ‚çš„åº”ç”¨æ¶æ„ï¼Œç†è§£è¿™ä¸ªæ¼”è¿›è¿‡ç¨‹æœ‰åŠ©äºæˆ‘ä»¬åšå‡ºæ›´å¥½çš„æ¶æ„å†³ç­–ã€‚
</Callout>

### æ¶æ„æ¼”è¿›é˜¶æ®µ

```javascript
// å‰ç«¯æ¶æ„æ¼”è¿›å†ç¨‹
const architectureEvolution = {
  // 1. ä¼ ç»Ÿå¤šé¡µåº”ç”¨ (MPA)
  traditionalMPA: {
    period: '1990s-2000s',
    characteristics: [
      'æœåŠ¡ç«¯æ¸²æŸ“',
      'é¡µé¢åˆ·æ–°å¯¼èˆª',
      'jQueryæ“ä½œDOM',
      'ç®€å•çš„è„šæœ¬æ–‡ä»¶'
    ],
    advantages: ['SEOå‹å¥½', 'ç®€å•ç›´æ¥', 'æœåŠ¡ç«¯æ§åˆ¶'],
    disadvantages: ['ç”¨æˆ·ä½“éªŒå·®', 'é‡å¤åŠ è½½', 'çŠ¶æ€éš¾ä»¥ç»´æŠ¤'],
    example: `
      <!-- ä¼ ç»ŸMPAç»“æ„ -->
      <script src="jquery.js"></script>
      <script>
        $(document).ready(function() {
          $('#button').click(function() {
            window.location.href = '/next-page';
          });
        });
      </script>
    `
  },
  
  // 2. å•é¡µåº”ç”¨ (SPA)
  singlePageApp: {
    period: '2010s',
    characteristics: [
      'å®¢æˆ·ç«¯è·¯ç”±',
      'åŠ¨æ€å†…å®¹æ›´æ–°',
      'AJAXæ•°æ®è·å–',
      'å‰ç«¯æ¡†æ¶å…´èµ·'
    ],
    advantages: ['æµç•…ä½“éªŒ', 'å¿«é€Ÿå¯¼èˆª', 'ä¸°å¯Œäº¤äº’'],
    disadvantages: ['SEOæŒ‘æˆ˜', 'é¦–å±åŠ è½½æ…¢', 'å¤æ‚åº¦å¢åŠ '],
    frameworks: ['Angular', 'React', 'Vue'],
    example: `
      // SPAè·¯ç”±ç¤ºä¾‹
      const router = new Router({
        '/home': () => import('./pages/Home'),
        '/about': () => import('./pages/About'),
        '/contact': () => import('./pages/Contact')
      });
    `
  },
  
  // 3. åŒæ„åº”ç”¨ (SSR)
  isomorphicApp: {
    period: '2015+',
    characteristics: [
      'æœåŠ¡ç«¯+å®¢æˆ·ç«¯æ¸²æŸ“',
      'ä»£ç å¤ç”¨',
      'é¦–å±ä¼˜åŒ–',
      'SEOå‹å¥½'
    ],
    advantages: ['æœ€ä½³æ€§èƒ½', 'SEOä¼˜åŒ–', 'ç”¨æˆ·ä½“éªŒå¥½'],
    disadvantages: ['å¤æ‚åº¦é«˜', 'å¼€å‘æˆæœ¬å¤§', 'æœåŠ¡å™¨å‹åŠ›'],
    frameworks: ['Next.js', 'Nuxt.js', 'SvelteKit'],
    example: `
      // Next.js SSRç¤ºä¾‹
      export async function getServerSideProps() {
        const data = await fetchData();
        return { props: { data } };
      }
    `
  },
  
  // 4. å¾®å‰ç«¯æ¶æ„
  microfrontend: {
    period: '2018+',
    characteristics: [
      'åº”ç”¨æ‹†åˆ†',
      'ç‹¬ç«‹éƒ¨ç½²',
      'æŠ€æœ¯æ ˆè‡ªç”±',
      'å›¢é˜Ÿè‡ªæ²»'
    ],
    advantages: ['å¯æ‰©å±•æ€§', 'æŠ€æœ¯å¤šæ ·æ€§', 'å›¢é˜Ÿç‹¬ç«‹'],
    disadvantages: ['å¤æ‚åº¦é«˜', 'æ€§èƒ½å¼€é”€', 'ä¸€è‡´æ€§æŒ‘æˆ˜'],
    solutions: ['Single-SPA', 'Module Federation', 'qiankun'],
    example: `
      // å¾®å‰ç«¯æ³¨å†Œ
      registerApplication({
        name: 'react-app',
        app: () => import('./react-app/main.js'),
        activeWhen: ['/react']
      });
    `
  },
  
  // 5. è¾¹ç¼˜è®¡ç®—æ¶æ„
  edgeComputing: {
    period: '2020+',
    characteristics: [
      'è¾¹ç¼˜æ¸²æŸ“',
      'å°±è¿‘è®¡ç®—',
      'ä½å»¶è¿Ÿ',
      'å…¨çƒåˆ†å¸ƒ'
    ],
    advantages: ['æä½å»¶è¿Ÿ', 'å…¨çƒæ€§èƒ½', 'é«˜å¯ç”¨æ€§'],
    disadvantages: ['å¤æ‚éƒ¨ç½²', 'æˆæœ¬è¾ƒé«˜', 'è°ƒè¯•å›°éš¾'],
    platforms: ['Cloudflare Workers', 'Vercel Edge', 'Deno Deploy']
  }
};

// æ¶æ„é€‰æ‹©å†³ç­–æ ‘
class ArchitectureDecisionTree {
  constructor() {
    this.factors = {
      teamSize: null,
      projectComplexity: null,
      performanceRequirements: null,
      seoRequirements: null,
      scalabilityNeeds: null,
      maintenanceCapacity: null
    };
  }
  
  analyze(requirements) {
    this.factors = { ...this.factors, ...requirements };
    return this.recommend();
  }
  
  recommend() {
    const { 
      teamSize, 
      projectComplexity, 
      performanceRequirements,
      seoRequirements,
      scalabilityNeeds 
    } = this.factors;
    
    // å°å›¢é˜Ÿ + ç®€å•é¡¹ç›®
    if (teamSize <= 5 && projectComplexity === 'low') {
      return {
        architecture: 'Traditional MPA',
        reason: 'ç®€å•ç›´æ¥ï¼Œç»´æŠ¤æˆæœ¬ä½',
        frameworks: ['Next.js', 'Nuxt.js', 'SvelteKit']
      };
    }
    
    // ä¸­ç­‰å›¢é˜Ÿ + ä¸­ç­‰å¤æ‚åº¦ + é«˜æ€§èƒ½è¦æ±‚
    if (teamSize <= 15 && performanceRequirements === 'high') {
      return {
        architecture: 'SSR/SSG',
        reason: 'å¹³è¡¡æ€§èƒ½å’Œå¼€å‘æ•ˆç‡',
        frameworks: ['Next.js', 'Nuxt.js', 'Remix']
      };
    }
    
    // å¤§å›¢é˜Ÿ + é«˜å¤æ‚åº¦ + é«˜æ‰©å±•æ€§éœ€æ±‚
    if (teamSize > 15 && scalabilityNeeds === 'high') {
      return {
        architecture: 'Micro-frontend',
        reason: 'æ”¯æŒå¤§è§„æ¨¡å›¢é˜Ÿåä½œ',
        solutions: ['Module Federation', 'Single-SPA', 'qiankun']
      };
    }
    
    // SEOé‡è¦çš„å†…å®¹ç½‘ç«™
    if (seoRequirements === 'critical') {
      return {
        architecture: 'Static Site Generation',
        reason: 'æœ€ä½³SEOæ€§èƒ½',
        frameworks: ['Next.js', 'Gatsby', 'Astro']
      };
    }
    
    // é»˜è®¤æ¨è
    return {
      architecture: 'SPA with SSR',
      reason: 'å¹³è¡¡å„æ–¹é¢éœ€æ±‚',
      frameworks: ['Next.js', 'Nuxt.js']
    };
  }
}
```

## å¾®å‰ç«¯æ¶æ„è®¾è®¡

### å¾®å‰ç«¯å®ç°æ–¹æ¡ˆ

```javascript
// 1. åŸºäºModule Federationçš„å¾®å‰ç«¯æ¶æ„
class MicrofrontendOrchestrator {
  constructor() {
    this.applications = new Map();
    this.sharedDependencies = new Map();
    this.eventBus = new EventTarget();
    this.setupGlobalErrorHandling();
  }
  
  // æ³¨å†Œå¾®åº”ç”¨
  registerApplication(config) {
    const {
      name,
      entry,
      container,
      activeRule,
      props = {}
    } = config;
    
    const application = {
      name,
      entry,
      container,
      activeRule,
      props,
      status: 'NOT_LOADED',
      instance: null
    };
    
    this.applications.set(name, application);
    console.log(`å¾®åº”ç”¨ ${name} æ³¨å†ŒæˆåŠŸ`);
  }
  
  // åŠ è½½å¾®åº”ç”¨
  async loadApplication(name) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`å¾®åº”ç”¨ ${name} æœªæ³¨å†Œ`);
    }
    
    if (app.status === 'LOADED') {
      return app.instance;
    }
    
    try {
      app.status = 'LOADING';
      
      // åŠ¨æ€å¯¼å…¥å¾®åº”ç”¨
      const module = await import(app.entry);
      
      // åˆ›å»ºåº”ç”¨å®ä¾‹
      app.instance = {
        mount: module.mount,
        unmount: module.unmount,
        update: module.update || (() => {}),
        getStatus: () => app.status
      };
      
      app.status = 'LOADED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-loaded', {
        detail: { name, app }
      }));
      
      return app.instance;
    } catch (error) {
      app.status = 'LOAD_ERROR';
      console.error(`åŠ è½½å¾®åº”ç”¨ ${name} å¤±è´¥:`, error);
      throw error;
    }
  }
  
  // æŒ‚è½½å¾®åº”ç”¨
  async mountApplication(name, container) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`å¾®åº”ç”¨ ${name} æœªæ³¨å†Œ`);
    }
    
    try {
      if (app.status !== 'LOADED') {
        await this.loadApplication(name);
      }
      
      // å‡†å¤‡æŒ‚è½½ç¯å¢ƒ
      const mountContainer = container || document.querySelector(app.container);
      if (!mountContainer) {
        throw new Error(`æ‰¾ä¸åˆ°å®¹å™¨: ${app.container}`);
      }
      
      // è®¾ç½®æ²™ç®±ç¯å¢ƒ
      const sandbox = this.createSandbox(name);
      
      // æŒ‚è½½åº”ç”¨
      await app.instance.mount({
        container: mountContainer,
        props: app.props,
        sandbox
      });
      
      app.status = 'MOUNTED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-mounted', {
        detail: { name, app }
      }));
      
      console.log(`å¾®åº”ç”¨ ${name} æŒ‚è½½æˆåŠŸ`);
    } catch (error) {
      app.status = 'MOUNT_ERROR';
      console.error(`æŒ‚è½½å¾®åº”ç”¨ ${name} å¤±è´¥:`, error);
      throw error;
    }
  }
  
  // å¸è½½å¾®åº”ç”¨
  async unmountApplication(name) {
    const app = this.applications.get(name);
    if (!app || app.status !== 'MOUNTED') {
      return;
    }
    
    try {
      await app.instance.unmount();
      app.status = 'LOADED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-unmounted', {
        detail: { name, app }
      }));
      
      console.log(`å¾®åº”ç”¨ ${name} å¸è½½æˆåŠŸ`);
    } catch (error) {
      console.error(`å¸è½½å¾®åº”ç”¨ ${name} å¤±è´¥:`, error);
    }
  }
  
  // åˆ›å»ºæ²™ç®±ç¯å¢ƒ
  createSandbox(appName) {
    const sandbox = {
      // æ ·å¼éš”ç¦»
      scopedCSS: this.createScopedCSS(appName),
      
      // JavaScriptéš”ç¦»
      isolatedGlobals: this.createIsolatedGlobals(appName),
      
      // äº‹ä»¶éš”ç¦»
      eventIsolation: this.createEventIsolation(appName)
    };
    
    return sandbox;
  }
  
  createScopedCSS(appName) {
    const prefix = `micro-app-${appName}`;
    
    return {
      addScope: (css) => {
        // ç®€åŒ–çš„CSSä½œç”¨åŸŸæ·»åŠ 
        return css.replace(/([^{}]+){/g, (match, selector) => {
          return `.${prefix} ${selector.trim()}{`;
        });
      },
      
      removeScope: (css) => {
        const regex = new RegExp(`\\.${prefix}\\s+`, 'g');
        return css.replace(regex, '');
      }
    };
  }
  
  createIsolatedGlobals(appName) {
    const originalGlobals = {};
    const isolatedWindow = {};
    
    return {
      isolate: () => {
        // ä¿å­˜åŸå§‹å…¨å±€å˜é‡
        ['localStorage', 'sessionStorage', 'history'].forEach(key => {
          originalGlobals[key] = window[key];
        });
        
        // åˆ›å»ºéš”ç¦»çš„å…¨å±€å¯¹è±¡
        isolatedWindow.localStorage = this.createIsolatedStorage(`${appName}-local`);
        isolatedWindow.sessionStorage = this.createIsolatedStorage(`${appName}-session`);
        isolatedWindow.history = this.createIsolatedHistory(appName);
        
        return isolatedWindow;
      },
      
      restore: () => {
        Object.assign(window, originalGlobals);
      }
    };
  }
  
  createIsolatedStorage(prefix) {
    return {
      getItem: (key) => {
        return localStorage.getItem(`${prefix}-${key}`);
      },
      setItem: (key, value) => {
        localStorage.setItem(`${prefix}-${key}`, value);
      },
      removeItem: (key) => {
        localStorage.removeItem(`${prefix}-${key}`);
      },
      clear: () => {
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith(`${prefix}-`)) {
            localStorage.removeItem(key);
          }
        });
      }
    };
  }
  
  createIsolatedHistory(appName) {
    const baseUrl = `/micro-app/${appName}`;
    
    return {
      pushState: (state, title, url) => {
        const fullUrl = `${baseUrl}${url}`;
        history.pushState(state, title, fullUrl);
      },
      replaceState: (state, title, url) => {
        const fullUrl = `${baseUrl}${url}`;
        history.replaceState(state, title, fullUrl);
      },
      back: () => history.back(),
      forward: () => history.forward(),
      go: (delta) => history.go(delta)
    };
  }
  
  createEventIsolation(appName) {
    const eventMap = new Map();
    
    return {
      addEventListener: (type, listener, options) => {
        const wrappedListener = (event) => {
          // æ£€æŸ¥äº‹ä»¶æ˜¯å¦å±äºå½“å‰åº”ç”¨
          if (this.isEventFromApp(event, appName)) {
            listener(event);
          }
        };
        
        eventMap.set(listener, wrappedListener);
        document.addEventListener(type, wrappedListener, options);
      },
      
      removeEventListener: (type, listener, options) => {
        const wrappedListener = eventMap.get(listener);
        if (wrappedListener) {
          document.removeEventListener(type, wrappedListener, options);
          eventMap.delete(listener);
        }
      }
    };
  }
  
  isEventFromApp(event, appName) {
    const target = event.target;
    const appContainer = document.querySelector(`[data-app="${appName}"]`);
    return appContainer && appContainer.contains(target);
  }
  
  // åº”ç”¨é—´é€šä¿¡
  createCommunicationBridge() {
    return {
      // å‘é€æ¶ˆæ¯
      emit: (event, data) => {
        this.eventBus.dispatchEvent(new CustomEvent(event, {
          detail: data
        }));
      },
      
      // ç›‘å¬æ¶ˆæ¯
      on: (event, callback) => {
        this.eventBus.addEventListener(event, callback);
      },
      
      // ç§»é™¤ç›‘å¬
      off: (event, callback) => {
        this.eventBus.removeEventListener(event, callback);
      },
      
      // å…±äº«çŠ¶æ€
      setSharedState: (key, value) => {
        window.__SHARED_STATE__ = window.__SHARED_STATE__ || {};
        window.__SHARED_STATE__[key] = value;
        
        this.eventBus.dispatchEvent(new CustomEvent('shared-state-change', {
          detail: { key, value }
        }));
      },
      
      getSharedState: (key) => {
        return window.__SHARED_STATE__?.[key];
      }
    };
  }
  
  setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      console.error('å¾®å‰ç«¯å…¨å±€é”™è¯¯:', event.error);
      
      // å°è¯•è¯†åˆ«é”™è¯¯æ¥æºçš„åº”ç”¨
      const sourceApp = this.identifyErrorSource(event);
      if (sourceApp) {
        console.log(`é”™è¯¯æ¥æºåº”ç”¨: ${sourceApp}`);
        
        // å¯ä»¥é€‰æ‹©é‡å¯åº”ç”¨æˆ–æ˜¾ç¤ºé”™è¯¯é¡µé¢
        this.handleApplicationError(sourceApp, event.error);
      }
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('å¾®å‰ç«¯æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
    });
  }
  
  identifyErrorSource(event) {
    // ç®€åŒ–çš„é”™è¯¯æºè¯†åˆ«
    const stack = event.error?.stack || '';
    
    for (const [name] of this.applications) {
      if (stack.includes(name) || stack.includes(`micro-app-${name}`)) {
        return name;
      }
    }
    
    return null;
  }
  
  handleApplicationError(appName, error) {
    const app = this.applications.get(appName);
    if (app && app.status === 'MOUNTED') {
      // å°è¯•é‡æ–°æŒ‚è½½åº”ç”¨
      this.unmountApplication(appName)
        .then(() => this.mountApplication(appName))
        .catch(console.error);
    }
  }
}

// 2. å¾®å‰ç«¯è·¯ç”±ç®¡ç†
class MicrofrontendRouter {
  constructor(orchestrator) {
    this.orchestrator = orchestrator;
    this.routes = new Map();
    this.currentApp = null;
    this.setupRouting();
  }
  
  registerRoute(path, appName) {
    this.routes.set(path, appName);
  }
  
  setupRouting() {
    window.addEventListener('popstate', () => {
      this.handleRouteChange();
    });
    
    // æ‹¦æˆªpushStateå’ŒreplaceState
    this.interceptHistoryMethods();
    
    // åˆå§‹è·¯ç”±å¤„ç†
    this.handleRouteChange();
  }
  
  interceptHistoryMethods() {
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = (...args) => {
      originalPushState.apply(history, args);
      this.handleRouteChange();
    };
    
    history.replaceState = (...args) => {
      originalReplaceState.apply(history, args);
      this.handleRouteChange();
    };
  }
  
  async handleRouteChange() {
    const currentPath = window.location.pathname;
    const targetApp = this.findMatchingApp(currentPath);
    
    if (targetApp !== this.currentApp) {
      // å¸è½½å½“å‰åº”ç”¨
      if (this.currentApp) {
        await this.orchestrator.unmountApplication(this.currentApp);
      }
      
      // æŒ‚è½½æ–°åº”ç”¨
      if (targetApp) {
        await this.orchestrator.mountApplication(targetApp);
        this.currentApp = targetApp;
      }
    }
  }
  
  findMatchingApp(path) {
    for (const [routePath, appName] of this.routes) {
      if (path.startsWith(routePath)) {
        return appName;
      }
    }
    return null;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const orchestrator = new MicrofrontendOrchestrator();
const router = new MicrofrontendRouter(orchestrator);

// æ³¨å†Œå¾®åº”ç”¨
orchestrator.registerApplication({
  name: 'header-app',
  entry: './micro-apps/header/index.js',
  container: '#header-container',
  activeRule: () => true
});

orchestrator.registerApplication({
  name: 'dashboard-app',
  entry: './micro-apps/dashboard/index.js',
  container: '#main-container',
  activeRule: (location) => location.pathname.startsWith('/dashboard')
});

// æ³¨å†Œè·¯ç”±
router.registerRoute('/dashboard', 'dashboard-app');
router.registerRoute('/profile', 'profile-app');

// åˆ›å»ºé€šä¿¡æ¡¥
const communicationBridge = orchestrator.createCommunicationBridge();

// åº”ç”¨é—´é€šä¿¡ç¤ºä¾‹
communicationBridge.on('user-login', (event) => {
  console.log('ç”¨æˆ·ç™»å½•:', event.detail);
  communicationBridge.setSharedState('currentUser', event.detail.user);
});
```

## ç»„ä»¶åŒ–æ¶æ„æ¨¡å¼

<Callout type="info">
ç»„ä»¶åŒ–æ¶æ„æ˜¯ç°ä»£å‰ç«¯å¼€å‘çš„æ ¸å¿ƒæ€æƒ³ï¼Œé€šè¿‡å°†UIæ‹†åˆ†ä¸ºç‹¬ç«‹ã€å¯å¤ç”¨çš„ç»„ä»¶æ¥æé«˜å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ã€‚
</Callout>

### ç»„ä»¶è®¾è®¡åŸåˆ™

```javascript
// 1. å•ä¸€èŒè´£åŸåˆ™
// å¥½çš„ç»„ä»¶è®¾è®¡ - èŒè´£å•ä¸€
const UserAvatar = ({ user, size = 'medium', onClick }) => {
  const sizeClasses = {
    small: 'w-8 h-8',
    medium: 'w-12 h-12',
    large: 'w-16 h-16'
  };

  return (
    <div
      className={`rounded-full overflow-hidden ${sizeClasses[size]} cursor-pointer`}
      onClick={onClick}
    >
      <img
        src={user.avatar || '/default-avatar.png'}
        alt={user.name}
        className="w-full h-full object-cover"
      />
    </div>
  );
};

// 2. ç»„åˆä¼˜äºç»§æ‰¿
const Card = ({ children, className = '', ...props }) => (
  <div className={`bg-white rounded-lg shadow-md p-4 ${className}`} {...props}>
    {children}
  </div>
);

const CardHeader = ({ children, className = '' }) => (
  <div className={`border-b pb-2 mb-4 ${className}`}>
    {children}
  </div>
);

const CardBody = ({ children, className = '' }) => (
  <div className={className}>
    {children}
  </div>
);

const CardFooter = ({ children, className = '' }) => (
  <div className={`border-t pt-2 mt-4 ${className}`}>
    {children}
  </div>
);

// ä½¿ç”¨ç»„åˆ
const UserCard = ({ user }) => (
  <Card>
    <CardHeader>
      <div className="flex items-center space-x-3">
        <UserAvatar user={user} />
        <h3 className="text-lg font-semibold">{user.name}</h3>
      </div>
    </CardHeader>
    <CardBody>
      <p className="text-gray-600">{user.bio}</p>
    </CardBody>
    <CardFooter>
      <button className="btn-primary">Follow</button>
    </CardFooter>
  </Card>
);

// 3. é«˜é˜¶ç»„ä»¶æ¨¡å¼
const withLoading = (WrappedComponent) => {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div className="spinner">Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

const withErrorBoundary = (WrappedComponent) => {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
      return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
      console.error('Component error:', error, errorInfo);
    }

    render() {
      if (this.state.hasError) {
        return <div className="error">Something went wrong.</div>;
      }
      return <WrappedComponent {...this.props} />;
    }
  };
};

// 4. Render Propsæ¨¡å¼
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
};

// ä½¿ç”¨Render Props
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      return (
        <div>
          {data.map(user => (
            <UserCard key={user.id} user={user} />
          ))}
        </div>
      );
    }}
  </DataFetcher>
);

// 5. å¤åˆç»„ä»¶æ¨¡å¼
const Tabs = ({ children, defaultTab = 0 }) => {
  const [activeTab, setActiveTab] = useState(defaultTab);

  const tabs = React.Children.toArray(children);

  return (
    <div className="tabs">
      <div className="tab-list">
        {tabs.map((tab, index) => (
          <button
            key={index}
            className={`tab ${index === activeTab ? 'active' : ''}`}
            onClick={() => setActiveTab(index)}
          >
            {tab.props.label}
          </button>
        ))}
      </div>
      <div className="tab-content">
        {tabs[activeTab]}
      </div>
    </div>
  );
};

const TabPanel = ({ children, label }) => (
  <div className="tab-panel">
    {children}
  </div>
);

// ä½¿ç”¨å¤åˆç»„ä»¶
const App = () => (
  <Tabs defaultTab={0}>
    <TabPanel label="Home">
      <h2>Home Content</h2>
    </TabPanel>
    <TabPanel label="About">
      <h2>About Content</h2>
    </TabPanel>
    <TabPanel label="Contact">
      <h2>Contact Content</h2>
    </TabPanel>
  </Tabs>
);
```

## æ¨¡å—åŒ–å’Œä¾èµ–ç®¡ç†

<Callout type="warning">
è‰¯å¥½çš„æ¨¡å—åŒ–è®¾è®¡å’Œä¾èµ–ç®¡ç†æ˜¯å¤§å‹å‰ç«¯åº”ç”¨å¯ç»´æŠ¤æ€§çš„å…³é”®ï¼Œéœ€è¦åˆç†çš„æ¨¡å—åˆ’åˆ†å’Œä¾èµ–å…³ç³»è®¾è®¡ã€‚
</Callout>

### æ¨¡å—åŒ–æ¶æ„è®¾è®¡

```javascript
// 1. åˆ†å±‚æ¶æ„æ¨¡å¼
// è¡¨ç°å±‚ (Presentation Layer)
// components/UserProfile.jsx
import { useUser } from '../hooks/useUser';
import { userService } from '../services/userService';

export const UserProfile = ({ userId }) => {
  const { user, loading, error, updateUser } = useUser(userId);

  const handleUpdate = async (userData) => {
    try {
      await updateUser(userData);
    } catch (error) {
      console.error('Update failed:', error);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => handleUpdate({ ...user, lastSeen: new Date() })}>
        Update Last Seen
      </button>
    </div>
  );
};

// ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)
// hooks/useUser.js
import { useState, useEffect } from 'react';
import { userService } from '../services/userService';

export const useUser = (userId) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    loadUser();
  }, [userId]);

  const loadUser = async () => {
    try {
      setLoading(true);
      const userData = await userService.getUser(userId);
      setUser(userData);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  const updateUser = async (userData) => {
    const updatedUser = await userService.updateUser(userId, userData);
    setUser(updatedUser);
    return updatedUser;
  };

  return { user, loading, error, updateUser, reload: loadUser };
};

// æœåŠ¡å±‚ (Service Layer)
// services/userService.js
import { apiClient } from './apiClient';
import { cacheManager } from '../utils/cacheManager';

class UserService {
  async getUser(userId) {
    const cacheKey = `user:${userId}`;
    const cached = cacheManager.get(cacheKey);

    if (cached) {
      return cached;
    }

    const user = await apiClient.get(`/users/${userId}`);
    cacheManager.set(cacheKey, user, 5 * 60 * 1000); // 5åˆ†é’Ÿç¼“å­˜
    return user;
  }

  async updateUser(userId, userData) {
    const updatedUser = await apiClient.put(`/users/${userId}`, userData);
    cacheManager.delete(`user:${userId}`);
    return updatedUser;
  }

  async createUser(userData) {
    return apiClient.post('/users', userData);
  }

  async deleteUser(userId) {
    await apiClient.delete(`/users/${userId}`);
    cacheManager.delete(`user:${userId}`);
  }
}

export const userService = new UserService();

// æ•°æ®è®¿é—®å±‚ (Data Access Layer)
// services/apiClient.js
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.interceptors = {
      request: [],
      response: []
    };
  }

  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }

  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }

  async request(url, options = {}) {
    let config = {
      ...options,
      url: `${this.baseURL}${url}`,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    };

    // åº”ç”¨è¯·æ±‚æ‹¦æˆªå™¨
    for (const interceptor of this.interceptors.request) {
      config = await interceptor(config);
    }

    let response = await fetch(config.url, config);

    // åº”ç”¨å“åº”æ‹¦æˆªå™¨
    for (const interceptor of this.interceptors.response) {
      response = await interceptor(response);
    }

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }

  get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  }

  post(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  put(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }

  delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }
}

export const apiClient = new APIClient(process.env.REACT_APP_API_URL);

// 2. ä¾èµ–æ³¨å…¥æ¨¡å¼
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }

  register(name, factory, options = {}) {
    this.services.set(name, {
      factory,
      singleton: options.singleton || false,
      dependencies: options.dependencies || []
    });
  }

  resolve(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }

    if (service.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }

    const dependencies = service.dependencies.map(dep => this.resolve(dep));
    const instance = service.factory(...dependencies);

    if (service.singleton) {
      this.singletons.set(name, instance);
    }

    return instance;
  }
}

// ä½¿ç”¨ä¾èµ–æ³¨å…¥
const container = new DIContainer();

container.register('logger', () => new Logger(), { singleton: true });
container.register('apiClient', (logger) => new APIClient('/api', logger), {
  dependencies: ['logger'],
  singleton: true
});
container.register('userService', (apiClient) => new UserService(apiClient), {
  dependencies: ['apiClient'],
  singleton: true
});

// 3. æ¨¡å—è”é‚¦æ¶æ„
// webpack.config.js (ä¸»åº”ç”¨)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        userModule: 'userModule@http://localhost:3001/remoteEntry.js',
        productModule: 'productModule@http://localhost:3002/remoteEntry.js'
      }
    })
  ]
};

// åŠ¨æ€å¯¼å…¥è¿œç¨‹æ¨¡å—
const loadUserModule = async () => {
  const { UserModule } = await import('userModule/UserModule');
  return UserModule;
};

const App = () => {
  const [UserModule, setUserModule] = useState(null);

  useEffect(() => {
    loadUserModule().then(setUserModule);
  }, []);

  return (
    <div>
      <h1>Main Application</h1>
      {UserModule && <UserModule />}
    </div>
  );
};
```

## å¯æ‰©å±•æ€§è®¾è®¡åŸåˆ™

<Callout type="info">
å¯æ‰©å±•æ€§è®¾è®¡ç¡®ä¿åº”ç”¨èƒ½å¤Ÿéšç€ä¸šåŠ¡å¢é•¿è€Œå¹³æ»‘æ‰©å±•ï¼ŒåŒ…æ‹¬åŠŸèƒ½æ‰©å±•ã€æ€§èƒ½æ‰©å±•å’Œå›¢é˜Ÿæ‰©å±•ã€‚
</Callout>

### å¯æ‰©å±•æ¶æ„æ¨¡å¼

```javascript
// 1. æ’ä»¶åŒ–æ¶æ„
class PluginManager {
  constructor() {
    this.plugins = new Map();
    this.hooks = new Map();
  }

  registerPlugin(name, plugin) {
    if (this.plugins.has(name)) {
      throw new Error(`Plugin ${name} already registered`);
    }

    this.plugins.set(name, plugin);

    // åˆå§‹åŒ–æ’ä»¶
    if (plugin.init) {
      plugin.init(this);
    }

    // æ³¨å†Œæ’ä»¶çš„é’©å­
    if (plugin.hooks) {
      Object.entries(plugin.hooks).forEach(([hookName, handler]) => {
        this.addHook(hookName, handler);
      });
    }
  }

  addHook(name, handler) {
    if (!this.hooks.has(name)) {
      this.hooks.set(name, []);
    }
    this.hooks.get(name).push(handler);
  }

  async executeHook(name, context = {}) {
    const handlers = this.hooks.get(name) || [];
    let result = context;

    for (const handler of handlers) {
      result = await handler(result);
    }

    return result;
  }

  getPlugin(name) {
    return this.plugins.get(name);
  }

  removePlugin(name) {
    const plugin = this.plugins.get(name);
    if (plugin && plugin.destroy) {
      plugin.destroy();
    }
    this.plugins.delete(name);
  }
}

// ç¤ºä¾‹æ’ä»¶
const analyticsPlugin = {
  name: 'analytics',

  init(pluginManager) {
    console.log('Analytics plugin initialized');
  },

  hooks: {
    'page:view': async (context) => {
      console.log('Page viewed:', context.path);
      // å‘é€åˆ†ææ•°æ®
      await fetch('/api/analytics/pageview', {
        method: 'POST',
        body: JSON.stringify({
          path: context.path,
          timestamp: Date.now()
        })
      });
      return context;
    },

    'user:action': async (context) => {
      console.log('User action:', context.action);
      return context;
    }
  },

  destroy() {
    console.log('Analytics plugin destroyed');
  }
};

// 2. äº‹ä»¶é©±åŠ¨æ¶æ„
class EventBus {
  constructor() {
    this.events = new Map();
  }

  on(event, handler) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(handler);
  }

  off(event, handler) {
    const handlers = this.events.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  emit(event, data) {
    const handlers = this.events.get(event) || [];
    handlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    });
  }

  once(event, handler) {
    const onceHandler = (data) => {
      handler(data);
      this.off(event, onceHandler);
    };
    this.on(event, onceHandler);
  }
}

// ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„
const eventBus = new EventBus();

// ç”¨æˆ·æ¨¡å—
class UserModule {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.setupEventListeners();
  }

  setupEventListeners() {
    this.eventBus.on('user:login', this.handleUserLogin.bind(this));
    this.eventBus.on('user:logout', this.handleUserLogout.bind(this));
  }

  handleUserLogin(user) {
    console.log('User logged in:', user);
    // æ›´æ–°ç”¨æˆ·çŠ¶æ€
    this.eventBus.emit('user:status:changed', { user, status: 'online' });
  }

  handleUserLogout() {
    console.log('User logged out');
    this.eventBus.emit('user:status:changed', { status: 'offline' });
  }

  login(credentials) {
    // ç™»å½•é€»è¾‘
    const user = { id: 1, name: 'John Doe' };
    this.eventBus.emit('user:login', user);
  }
}

// 3. å¾®æœåŠ¡å‰ç«¯æ¶æ„
class MicroFrontendOrchestrator {
  constructor() {
    this.applications = new Map();
    this.routes = new Map();
    this.sharedState = new Map();
  }

  registerApplication(name, config) {
    this.applications.set(name, {
      ...config,
      status: 'registered'
    });

    // æ³¨å†Œè·¯ç”±
    if (config.routes) {
      config.routes.forEach(route => {
        this.routes.set(route, name);
      });
    }
  }

  async loadApplication(name) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`Application ${name} not found`);
    }

    if (app.status === 'loaded') {
      return app.instance;
    }

    try {
      app.status = 'loading';

      // åŠ¨æ€å¯¼å…¥åº”ç”¨
      const module = await import(app.url);
      const instance = module.default || module;

      // åˆå§‹åŒ–åº”ç”¨
      if (instance.mount) {
        await instance.mount({
          container: app.container,
          sharedState: this.sharedState,
          eventBus: this.eventBus
        });
      }

      app.instance = instance;
      app.status = 'loaded';

      return instance;
    } catch (error) {
      app.status = 'error';
      throw error;
    }
  }

  async unloadApplication(name) {
    const app = this.applications.get(name);
    if (app && app.instance && app.instance.unmount) {
      await app.instance.unmount();
      app.status = 'registered';
      app.instance = null;
    }
  }

  async navigateToRoute(path) {
    const appName = this.routes.get(path);
    if (appName) {
      await this.loadApplication(appName);
    }
  }

  setSharedState(key, value) {
    this.sharedState.set(key, value);
    // é€šçŸ¥æ‰€æœ‰åº”ç”¨çŠ¶æ€å˜åŒ–
    this.applications.forEach((app, name) => {
      if (app.instance && app.instance.onSharedStateChange) {
        app.instance.onSharedStateChange(key, value);
      }
    });
  }

  getSharedState(key) {
    return this.sharedState.get(key);
  }
}

// 4. é…ç½®é©±åŠ¨æ¶æ„
class ConfigurableApplication {
  constructor(config) {
    this.config = config;
    this.components = new Map();
    this.layouts = new Map();
    this.themes = new Map();
  }

  registerComponent(name, component) {
    this.components.set(name, component);
  }

  registerLayout(name, layout) {
    this.layouts.set(name, layout);
  }

  registerTheme(name, theme) {
    this.themes.set(name, theme);
  }

  renderPage(pageConfig) {
    const { layout, components, theme } = pageConfig;

    const LayoutComponent = this.layouts.get(layout);
    const themeConfig = this.themes.get(theme);

    if (!LayoutComponent) {
      throw new Error(`Layout ${layout} not found`);
    }

    const renderedComponents = components.map(componentConfig => {
      const Component = this.components.get(componentConfig.type);
      if (!Component) {
        console.warn(`Component ${componentConfig.type} not found`);
        return null;
      }

      return React.createElement(Component, {
        key: componentConfig.id,
        ...componentConfig.props
      });
    });

    return React.createElement(LayoutComponent, {
      theme: themeConfig,
      children: renderedComponents
    });
  }
}

// é¡µé¢é…ç½®ç¤ºä¾‹
const pageConfig = {
  layout: 'main',
  theme: 'default',
  components: [
    {
      id: 'header',
      type: 'Header',
      props: {
        title: 'Welcome',
        showNavigation: true
      }
    },
    {
      id: 'content',
      type: 'ContentArea',
      props: {
        sections: [
          { type: 'hero', title: 'Hero Section' },
          { type: 'features', items: ['Feature 1', 'Feature 2'] }
        ]
      }
    },
    {
      id: 'footer',
      type: 'Footer',
      props: {
        copyright: '2023 Company Name'
      }
    }
  ]
};
```

## æ¶æ„å†³ç­–å’Œæƒè¡¡

<Callout type="warning">
æ¶æ„å†³ç­–éœ€è¦åœ¨å¤šä¸ªå› ç´ ä¹‹é—´è¿›è¡Œæƒè¡¡ï¼ŒåŒ…æ‹¬æ€§èƒ½ã€å¯ç»´æŠ¤æ€§ã€å¼€å‘æ•ˆç‡ã€å›¢é˜ŸæŠ€èƒ½ç­‰ã€‚
</Callout>

### æ¶æ„å†³ç­–æ¡†æ¶

```javascript
// 1. æ¶æ„å†³ç­–è®°å½• (ADR)
class ArchitectureDecisionRecord {
  constructor(title, status = 'proposed') {
    this.title = title;
    this.status = status; // proposed, accepted, deprecated, superseded
    this.date = new Date().toISOString();
    this.context = '';
    this.decision = '';
    this.consequences = {
      positive: [],
      negative: [],
      neutral: []
    };
    this.alternatives = [];
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setDecision(decision) {
    this.decision = decision;
    return this;
  }

  addConsequence(type, consequence) {
    if (this.consequences[type]) {
      this.consequences[type].push(consequence);
    }
    return this;
  }

  addAlternative(alternative) {
    this.alternatives.push(alternative);
    return this;
  }

  accept() {
    this.status = 'accepted';
    this.acceptedDate = new Date().toISOString();
    return this;
  }

  deprecate(reason) {
    this.status = 'deprecated';
    this.deprecatedDate = new Date().toISOString();
    this.deprecationReason = reason;
    return this;
  }

  supersede(newADR) {
    this.status = 'superseded';
    this.supersededBy = newADR.title;
    this.supersededDate = new Date().toISOString();
    return this;
  }

  toMarkdown() {
    return `
# ${this.title}

**Status:** ${this.status}
**Date:** ${this.date}

## Context

${this.context}

## Decision

${this.decision}

## Consequences

### Positive
${this.consequences.positive.map(c => `- ${c}`).join('\n')}

### Negative
${this.consequences.negative.map(c => `- ${c}`).join('\n')}

### Neutral
${this.consequences.neutral.map(c => `- ${c}`).join('\n')}

## Alternatives Considered

${this.alternatives.map(alt => `- ${alt}`).join('\n')}
    `.trim();
  }
}

// 2. æ¶æ„è¯„ä¼°çŸ©é˜µ
class ArchitectureEvaluationMatrix {
  constructor() {
    this.criteria = new Map();
    this.alternatives = [];
    this.weights = new Map();
  }

  addCriterion(name, description, weight = 1) {
    this.criteria.set(name, { description, weight });
    this.weights.set(name, weight);
  }

  addAlternative(name, scores = {}) {
    this.alternatives.push({ name, scores });
  }

  scoreAlternative(alternativeName, criterion, score) {
    const alternative = this.alternatives.find(alt => alt.name === alternativeName);
    if (alternative) {
      alternative.scores[criterion] = score;
    }
  }

  calculateWeightedScores() {
    return this.alternatives.map(alternative => {
      let totalScore = 0;
      let totalWeight = 0;

      for (const [criterion, weight] of this.weights) {
        const score = alternative.scores[criterion] || 0;
        totalScore += score * weight;
        totalWeight += weight;
      }

      return {
        name: alternative.name,
        weightedScore: totalScore / totalWeight,
        scores: alternative.scores
      };
    }).sort((a, b) => b.weightedScore - a.weightedScore);
  }

  generateReport() {
    const results = this.calculateWeightedScores();

    return {
      criteria: Array.from(this.criteria.entries()),
      alternatives: results,
      recommendation: results[0]?.name,
      analysis: this.generateAnalysis(results)
    };
  }

  generateAnalysis(results) {
    const analysis = [];

    // æ‰¾å‡ºæœ€ä½³é€‰æ‹©
    if (results.length > 0) {
      analysis.push(`æ¨èæ–¹æ¡ˆ: ${results[0].name} (å¾—åˆ†: ${results[0].weightedScore.toFixed(2)})`);
    }

    // åˆ†æå„ä¸ªæ ‡å‡†çš„è¡¨ç°
    for (const [criterion] of this.criteria) {
      const bestInCriterion = this.alternatives.reduce((best, current) => {
        return (current.scores[criterion] || 0) > (best.scores[criterion] || 0) ? current : best;
      });

      analysis.push(`${criterion}æœ€ä½³: ${bestInCriterion.name} (${bestInCriterion.scores[criterion] || 0}åˆ†)`);
    }

    return analysis;
  }
}

// 3. æŠ€æœ¯å€ºåŠ¡ç®¡ç†
class TechnicalDebtTracker {
  constructor() {
    this.debts = [];
    this.categories = ['performance', 'maintainability', 'security', 'scalability'];
  }

  addDebt(debt) {
    const debtItem = {
      id: Math.random().toString(36).substr(2, 9),
      title: debt.title,
      description: debt.description,
      category: debt.category,
      severity: debt.severity, // low, medium, high, critical
      effort: debt.effort, // hours
      impact: debt.impact, // 1-10
      createdDate: new Date().toISOString(),
      status: 'open', // open, in-progress, resolved
      assignee: debt.assignee,
      dueDate: debt.dueDate
    };

    this.debts.push(debtItem);
    return debtItem;
  }

  updateDebt(id, updates) {
    const debt = this.debts.find(d => d.id === id);
    if (debt) {
      Object.assign(debt, updates);
      if (updates.status === 'resolved') {
        debt.resolvedDate = new Date().toISOString();
      }
    }
    return debt;
  }

  getDebtsByCategory(category) {
    return this.debts.filter(debt => debt.category === category);
  }

  getDebtsBySeverity(severity) {
    return this.debts.filter(debt => debt.severity === severity);
  }

  calculateDebtMetrics() {
    const totalDebts = this.debts.length;
    const openDebts = this.debts.filter(d => d.status === 'open').length;
    const totalEffort = this.debts.reduce((sum, debt) => sum + (debt.effort || 0), 0);

    const categoryBreakdown = this.categories.map(category => ({
      category,
      count: this.getDebtsByCategory(category).length,
      effort: this.getDebtsByCategory(category).reduce((sum, debt) => sum + (debt.effort || 0), 0)
    }));

    const severityBreakdown = ['low', 'medium', 'high', 'critical'].map(severity => ({
      severity,
      count: this.getDebtsBySeverity(severity).length
    }));

    return {
      totalDebts,
      openDebts,
      resolvedDebts: totalDebts - openDebts,
      totalEffort,
      categoryBreakdown,
      severityBreakdown,
      debtRatio: openDebts / totalDebts
    };
  }

  prioritizeDebts() {
    return this.debts
      .filter(debt => debt.status === 'open')
      .map(debt => ({
        ...debt,
        priority: this.calculatePriority(debt)
      }))
      .sort((a, b) => b.priority - a.priority);
  }

  calculatePriority(debt) {
    const severityWeight = {
      low: 1,
      medium: 2,
      high: 3,
      critical: 4
    };

    const impactWeight = debt.impact || 5;
    const effortPenalty = Math.min(debt.effort / 40, 2); // å‡å°‘é«˜å·¥ä½œé‡é¡¹ç›®çš„ä¼˜å…ˆçº§

    return (severityWeight[debt.severity] * 2 + impactWeight) / (1 + effortPenalty);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// åˆ›å»ºæ¶æ„å†³ç­–è®°å½•
const microFrontendADR = new ArchitectureDecisionRecord('é‡‡ç”¨å¾®å‰ç«¯æ¶æ„')
  .setContext('éšç€å›¢é˜Ÿè§„æ¨¡æ‰©å¤§å’Œäº§å“å¤æ‚åº¦å¢åŠ ï¼Œå•ä½“å‰ç«¯åº”ç”¨å˜å¾—éš¾ä»¥ç»´æŠ¤')
  .setDecision('é‡‡ç”¨åŸºäºModule Federationçš„å¾®å‰ç«¯æ¶æ„')
  .addConsequence('positive', 'å›¢é˜Ÿå¯ä»¥ç‹¬ç«‹å¼€å‘å’Œéƒ¨ç½²')
  .addConsequence('positive', 'æŠ€æœ¯æ ˆå¯ä»¥å¤šæ ·åŒ–')
  .addConsequence('negative', 'å¢åŠ äº†æ¶æ„å¤æ‚åº¦')
  .addConsequence('negative', 'éœ€è¦é¢å¤–çš„åè°ƒæœºåˆ¶')
  .addAlternative('ç»§ç»­ä½¿ç”¨å•ä½“æ¶æ„')
  .addAlternative('é‡‡ç”¨iframeæ–¹æ¡ˆ')
  .accept();

// æ¶æ„è¯„ä¼°
const evaluationMatrix = new ArchitectureEvaluationMatrix();
evaluationMatrix.addCriterion('å¼€å‘æ•ˆç‡', 'å›¢é˜Ÿå¼€å‘å’Œç»´æŠ¤çš„æ•ˆç‡', 3);
evaluationMatrix.addCriterion('æ€§èƒ½', 'åº”ç”¨è¿è¡Œæ—¶æ€§èƒ½', 2);
evaluationMatrix.addCriterion('å¯æ‰©å±•æ€§', 'æ¶æ„çš„æ‰©å±•èƒ½åŠ›', 3);
evaluationMatrix.addCriterion('å­¦ä¹ æˆæœ¬', 'å›¢é˜Ÿå­¦ä¹ æ–°æ¶æ„çš„æˆæœ¬', 1);

evaluationMatrix.addAlternative('å¾®å‰ç«¯');
evaluationMatrix.scoreAlternative('å¾®å‰ç«¯', 'å¼€å‘æ•ˆç‡', 8);
evaluationMatrix.scoreAlternative('å¾®å‰ç«¯', 'æ€§èƒ½', 6);
evaluationMatrix.scoreAlternative('å¾®å‰ç«¯', 'å¯æ‰©å±•æ€§', 9);
evaluationMatrix.scoreAlternative('å¾®å‰ç«¯', 'å­¦ä¹ æˆæœ¬', 4);

evaluationMatrix.addAlternative('å•ä½“åº”ç”¨');
evaluationMatrix.scoreAlternative('å•ä½“åº”ç”¨', 'å¼€å‘æ•ˆç‡', 6);
evaluationMatrix.scoreAlternative('å•ä½“åº”ç”¨', 'æ€§èƒ½', 8);
evaluationMatrix.scoreAlternative('å•ä½“åº”ç”¨', 'å¯æ‰©å±•æ€§', 4);
evaluationMatrix.scoreAlternative('å•ä½“åº”ç”¨', 'å­¦ä¹ æˆæœ¬', 8);

const report = evaluationMatrix.generateReport();
console.log('æ¶æ„è¯„ä¼°æŠ¥å‘Š:', report);
```

---

<Callout type="success">
ç°ä»£å‰ç«¯æ¶æ„è®¾è®¡éœ€è¦å¹³è¡¡å¤æ‚æ€§ã€å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ã€‚é€‰æ‹©åˆé€‚çš„æ¶æ„æ¨¡å¼å¯¹é¡¹ç›®çš„é•¿æœŸæˆåŠŸè‡³å…³é‡è¦ã€‚
</Callout>

---

## ğŸ“š å‚è€ƒå­¦ä¹ èµ„æ–™

### ğŸ“– å®˜æ–¹æ–‡æ¡£
- [Micro Frontends](https://micro-frontends.org/) - å¾®å‰ç«¯å®˜æ–¹æŒ‡å—
- [Single-spa](https://single-spa.js.org/) - å¾®å‰ç«¯æ¡†æ¶æ–‡æ¡£
- [Module Federation](https://webpack.js.org/concepts/module-federation/) - Webpackæ¨¡å—è”é‚¦
- [qiankun](https://qiankun.umijs.org/) - èš‚èšé‡‘æœå¾®å‰ç«¯æ¡†æ¶

### ğŸ“ ä¼˜è´¨æ•™ç¨‹
- [Frontend Architecture](https://frontendmasters.com/courses/frontend-architecture/) - Frontend Mastersæ¶æ„è¯¾ç¨‹
- [Micro Frontend Architecture](https://martinfowler.com/articles/micro-frontends.html) - Martin Fowlerå¾®å‰ç«¯æ–‡ç« 
- [Scalable Frontend Architecture](https://blog.logrocket.com/scalable-frontend-architecture/) - å¯æ‰©å±•å‰ç«¯æ¶æ„

### ğŸ› ï¸ å®è·µé¡¹ç›®
- [Micro Frontend Examples](https://github.com/micro-frontends-demo) - å¾®å‰ç«¯ç¤ºä¾‹é¡¹ç›®
- [Architecture Patterns](https://github.com/kamranahmedse/developer-roadmap) - å¼€å‘è€…è·¯çº¿å›¾
- [Frontend Architecture Samples](https://github.com/topics/frontend-architecture) - å‰ç«¯æ¶æ„ç¤ºä¾‹

### ğŸ”§ å¼€å‘å·¥å…·
- [Single-spa](https://single-spa.js.org/) - å¾®å‰ç«¯æ¡†æ¶
- [qiankun](https://qiankun.umijs.org/) - å¾®å‰ç«¯è§£å†³æ–¹æ¡ˆ
- [Nx](https://nx.dev/) - å•ä½“ä»“åº“å·¥å…·
- [Lerna](https://lerna.js.org/) - å¤šåŒ…ç®¡ç†å·¥å…·

### ğŸ“ æ·±å…¥é˜…è¯»
- [Building Micro Frontends](https://www.buildingmicrofrontends.com/) - å¾®å‰ç«¯æ„å»ºæŒ‡å—
- [Frontend Architecture Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/) - å‰ç«¯æ¶æ„æ¨¡å¼
- [Scalable JavaScript Architecture](https://www.youtube.com/watch?v=mKouqShWI4o) - å¯æ‰©å±•JavaScriptæ¶æ„

<Callout type="tip">
ğŸ’¡ **å­¦ä¹ å»ºè®®**ï¼šå»ºè®®ä»ç†è§£å•ä½“åº”ç”¨çš„å±€é™æ€§å¼€å§‹ï¼Œå­¦ä¹ ç»„ä»¶åŒ–å’Œæ¨¡å—åŒ–è®¾è®¡ï¼Œç„¶åæ·±å…¥å¾®å‰ç«¯æ¶æ„ï¼Œæœ€åå®è·µå¤§å‹é¡¹ç›®æ¶æ„è®¾è®¡ã€‚
</Callout>

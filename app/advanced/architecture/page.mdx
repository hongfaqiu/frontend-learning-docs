import { Callout } from 'nextra/components'

# 18. 现代前端架构设计

## 📋 目录

- [前端架构演进历程](#前端架构演进历程)
- [微前端架构设计](#微前端架构设计)
- [组件化架构模式](#组件化架构模式)
- [模块化和依赖管理](#模块化和依赖管理)
- [可扩展性设计原则](#可扩展性设计原则)
- [架构决策和权衡](#架构决策和权衡)

## 前端架构演进历程

<Callout type="info">
前端架构从简单的页面脚本发展到复杂的应用架构，理解这个演进过程有助于我们做出更好的架构决策。
</Callout>

### 架构演进阶段

```javascript
// 前端架构演进历程
const architectureEvolution = {
  // 1. 传统多页应用 (MPA)
  traditionalMPA: {
    period: '1990s-2000s',
    characteristics: [
      '服务端渲染',
      '页面刷新导航',
      'jQuery操作DOM',
      '简单的脚本文件'
    ],
    advantages: ['SEO友好', '简单直接', '服务端控制'],
    disadvantages: ['用户体验差', '重复加载', '状态难以维护'],
    example: `
      <!-- 传统MPA结构 -->
      <script src="jquery.js"></script>
      <script>
        $(document).ready(function() {
          $('#button').click(function() {
            window.location.href = '/next-page';
          });
        });
      </script>
    `
  },
  
  // 2. 单页应用 (SPA)
  singlePageApp: {
    period: '2010s',
    characteristics: [
      '客户端路由',
      '动态内容更新',
      'AJAX数据获取',
      '前端框架兴起'
    ],
    advantages: ['流畅体验', '快速导航', '丰富交互'],
    disadvantages: ['SEO挑战', '首屏加载慢', '复杂度增加'],
    frameworks: ['Angular', 'React', 'Vue'],
    example: `
      // SPA路由示例
      const router = new Router({
        '/home': () => import('./pages/Home'),
        '/about': () => import('./pages/About'),
        '/contact': () => import('./pages/Contact')
      });
    `
  },
  
  // 3. 同构应用 (SSR)
  isomorphicApp: {
    period: '2015+',
    characteristics: [
      '服务端+客户端渲染',
      '代码复用',
      '首屏优化',
      'SEO友好'
    ],
    advantages: ['最佳性能', 'SEO优化', '用户体验好'],
    disadvantages: ['复杂度高', '开发成本大', '服务器压力'],
    frameworks: ['Next.js', 'Nuxt.js', 'SvelteKit'],
    example: `
      // Next.js SSR示例
      export async function getServerSideProps() {
        const data = await fetchData();
        return { props: { data } };
      }
    `
  },
  
  // 4. 微前端架构
  microfrontend: {
    period: '2018+',
    characteristics: [
      '应用拆分',
      '独立部署',
      '技术栈自由',
      '团队自治'
    ],
    advantages: ['可扩展性', '技术多样性', '团队独立'],
    disadvantages: ['复杂度高', '性能开销', '一致性挑战'],
    solutions: ['Single-SPA', 'Module Federation', 'qiankun'],
    example: `
      // 微前端注册
      registerApplication({
        name: 'react-app',
        app: () => import('./react-app/main.js'),
        activeWhen: ['/react']
      });
    `
  },
  
  // 5. 边缘计算架构
  edgeComputing: {
    period: '2020+',
    characteristics: [
      '边缘渲染',
      '就近计算',
      '低延迟',
      '全球分布'
    ],
    advantages: ['极低延迟', '全球性能', '高可用性'],
    disadvantages: ['复杂部署', '成本较高', '调试困难'],
    platforms: ['Cloudflare Workers', 'Vercel Edge', 'Deno Deploy']
  }
};

// 架构选择决策树
class ArchitectureDecisionTree {
  constructor() {
    this.factors = {
      teamSize: null,
      projectComplexity: null,
      performanceRequirements: null,
      seoRequirements: null,
      scalabilityNeeds: null,
      maintenanceCapacity: null
    };
  }
  
  analyze(requirements) {
    this.factors = { ...this.factors, ...requirements };
    return this.recommend();
  }
  
  recommend() {
    const { 
      teamSize, 
      projectComplexity, 
      performanceRequirements,
      seoRequirements,
      scalabilityNeeds 
    } = this.factors;
    
    // 小团队 + 简单项目
    if (teamSize <= 5 && projectComplexity === 'low') {
      return {
        architecture: 'Traditional MPA',
        reason: '简单直接，维护成本低',
        frameworks: ['Next.js', 'Nuxt.js', 'SvelteKit']
      };
    }
    
    // 中等团队 + 中等复杂度 + 高性能要求
    if (teamSize <= 15 && performanceRequirements === 'high') {
      return {
        architecture: 'SSR/SSG',
        reason: '平衡性能和开发效率',
        frameworks: ['Next.js', 'Nuxt.js', 'Remix']
      };
    }
    
    // 大团队 + 高复杂度 + 高扩展性需求
    if (teamSize > 15 && scalabilityNeeds === 'high') {
      return {
        architecture: 'Micro-frontend',
        reason: '支持大规模团队协作',
        solutions: ['Module Federation', 'Single-SPA', 'qiankun']
      };
    }
    
    // SEO重要的内容网站
    if (seoRequirements === 'critical') {
      return {
        architecture: 'Static Site Generation',
        reason: '最佳SEO性能',
        frameworks: ['Next.js', 'Gatsby', 'Astro']
      };
    }
    
    // 默认推荐
    return {
      architecture: 'SPA with SSR',
      reason: '平衡各方面需求',
      frameworks: ['Next.js', 'Nuxt.js']
    };
  }
}
```

## 微前端架构设计

### 微前端实现方案

```javascript
// 1. 基于Module Federation的微前端架构
class MicrofrontendOrchestrator {
  constructor() {
    this.applications = new Map();
    this.sharedDependencies = new Map();
    this.eventBus = new EventTarget();
    this.setupGlobalErrorHandling();
  }
  
  // 注册微应用
  registerApplication(config) {
    const {
      name,
      entry,
      container,
      activeRule,
      props = {}
    } = config;
    
    const application = {
      name,
      entry,
      container,
      activeRule,
      props,
      status: 'NOT_LOADED',
      instance: null
    };
    
    this.applications.set(name, application);
    console.log(`微应用 ${name} 注册成功`);
  }
  
  // 加载微应用
  async loadApplication(name) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`微应用 ${name} 未注册`);
    }
    
    if (app.status === 'LOADED') {
      return app.instance;
    }
    
    try {
      app.status = 'LOADING';
      
      // 动态导入微应用
      const module = await import(app.entry);
      
      // 创建应用实例
      app.instance = {
        mount: module.mount,
        unmount: module.unmount,
        update: module.update || (() => {}),
        getStatus: () => app.status
      };
      
      app.status = 'LOADED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-loaded', {
        detail: { name, app }
      }));
      
      return app.instance;
    } catch (error) {
      app.status = 'LOAD_ERROR';
      console.error(`加载微应用 ${name} 失败:`, error);
      throw error;
    }
  }
  
  // 挂载微应用
  async mountApplication(name, container) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`微应用 ${name} 未注册`);
    }
    
    try {
      if (app.status !== 'LOADED') {
        await this.loadApplication(name);
      }
      
      // 准备挂载环境
      const mountContainer = container || document.querySelector(app.container);
      if (!mountContainer) {
        throw new Error(`找不到容器: ${app.container}`);
      }
      
      // 设置沙箱环境
      const sandbox = this.createSandbox(name);
      
      // 挂载应用
      await app.instance.mount({
        container: mountContainer,
        props: app.props,
        sandbox
      });
      
      app.status = 'MOUNTED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-mounted', {
        detail: { name, app }
      }));
      
      console.log(`微应用 ${name} 挂载成功`);
    } catch (error) {
      app.status = 'MOUNT_ERROR';
      console.error(`挂载微应用 ${name} 失败:`, error);
      throw error;
    }
  }
  
  // 卸载微应用
  async unmountApplication(name) {
    const app = this.applications.get(name);
    if (!app || app.status !== 'MOUNTED') {
      return;
    }
    
    try {
      await app.instance.unmount();
      app.status = 'LOADED';
      
      this.eventBus.dispatchEvent(new CustomEvent('app-unmounted', {
        detail: { name, app }
      }));
      
      console.log(`微应用 ${name} 卸载成功`);
    } catch (error) {
      console.error(`卸载微应用 ${name} 失败:`, error);
    }
  }
  
  // 创建沙箱环境
  createSandbox(appName) {
    const sandbox = {
      // 样式隔离
      scopedCSS: this.createScopedCSS(appName),
      
      // JavaScript隔离
      isolatedGlobals: this.createIsolatedGlobals(appName),
      
      // 事件隔离
      eventIsolation: this.createEventIsolation(appName)
    };
    
    return sandbox;
  }
  
  createScopedCSS(appName) {
    const prefix = `micro-app-${appName}`;
    
    return {
      addScope: (css) => {
        // 简化的CSS作用域添加
        return css.replace(/([^{}]+){/g, (match, selector) => {
          return `.${prefix} ${selector.trim()}{`;
        });
      },
      
      removeScope: (css) => {
        const regex = new RegExp(`\\.${prefix}\\s+`, 'g');
        return css.replace(regex, '');
      }
    };
  }
  
  createIsolatedGlobals(appName) {
    const originalGlobals = {};
    const isolatedWindow = {};
    
    return {
      isolate: () => {
        // 保存原始全局变量
        ['localStorage', 'sessionStorage', 'history'].forEach(key => {
          originalGlobals[key] = window[key];
        });
        
        // 创建隔离的全局对象
        isolatedWindow.localStorage = this.createIsolatedStorage(`${appName}-local`);
        isolatedWindow.sessionStorage = this.createIsolatedStorage(`${appName}-session`);
        isolatedWindow.history = this.createIsolatedHistory(appName);
        
        return isolatedWindow;
      },
      
      restore: () => {
        Object.assign(window, originalGlobals);
      }
    };
  }
  
  createIsolatedStorage(prefix) {
    return {
      getItem: (key) => {
        return localStorage.getItem(`${prefix}-${key}`);
      },
      setItem: (key, value) => {
        localStorage.setItem(`${prefix}-${key}`, value);
      },
      removeItem: (key) => {
        localStorage.removeItem(`${prefix}-${key}`);
      },
      clear: () => {
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith(`${prefix}-`)) {
            localStorage.removeItem(key);
          }
        });
      }
    };
  }
  
  createIsolatedHistory(appName) {
    const baseUrl = `/micro-app/${appName}`;
    
    return {
      pushState: (state, title, url) => {
        const fullUrl = `${baseUrl}${url}`;
        history.pushState(state, title, fullUrl);
      },
      replaceState: (state, title, url) => {
        const fullUrl = `${baseUrl}${url}`;
        history.replaceState(state, title, fullUrl);
      },
      back: () => history.back(),
      forward: () => history.forward(),
      go: (delta) => history.go(delta)
    };
  }
  
  createEventIsolation(appName) {
    const eventMap = new Map();
    
    return {
      addEventListener: (type, listener, options) => {
        const wrappedListener = (event) => {
          // 检查事件是否属于当前应用
          if (this.isEventFromApp(event, appName)) {
            listener(event);
          }
        };
        
        eventMap.set(listener, wrappedListener);
        document.addEventListener(type, wrappedListener, options);
      },
      
      removeEventListener: (type, listener, options) => {
        const wrappedListener = eventMap.get(listener);
        if (wrappedListener) {
          document.removeEventListener(type, wrappedListener, options);
          eventMap.delete(listener);
        }
      }
    };
  }
  
  isEventFromApp(event, appName) {
    const target = event.target;
    const appContainer = document.querySelector(`[data-app="${appName}"]`);
    return appContainer && appContainer.contains(target);
  }
  
  // 应用间通信
  createCommunicationBridge() {
    return {
      // 发送消息
      emit: (event, data) => {
        this.eventBus.dispatchEvent(new CustomEvent(event, {
          detail: data
        }));
      },
      
      // 监听消息
      on: (event, callback) => {
        this.eventBus.addEventListener(event, callback);
      },
      
      // 移除监听
      off: (event, callback) => {
        this.eventBus.removeEventListener(event, callback);
      },
      
      // 共享状态
      setSharedState: (key, value) => {
        window.__SHARED_STATE__ = window.__SHARED_STATE__ || {};
        window.__SHARED_STATE__[key] = value;
        
        this.eventBus.dispatchEvent(new CustomEvent('shared-state-change', {
          detail: { key, value }
        }));
      },
      
      getSharedState: (key) => {
        return window.__SHARED_STATE__?.[key];
      }
    };
  }
  
  setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      console.error('微前端全局错误:', event.error);
      
      // 尝试识别错误来源的应用
      const sourceApp = this.identifyErrorSource(event);
      if (sourceApp) {
        console.log(`错误来源应用: ${sourceApp}`);
        
        // 可以选择重启应用或显示错误页面
        this.handleApplicationError(sourceApp, event.error);
      }
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('微前端未处理的Promise拒绝:', event.reason);
    });
  }
  
  identifyErrorSource(event) {
    // 简化的错误源识别
    const stack = event.error?.stack || '';
    
    for (const [name] of this.applications) {
      if (stack.includes(name) || stack.includes(`micro-app-${name}`)) {
        return name;
      }
    }
    
    return null;
  }
  
  handleApplicationError(appName, error) {
    const app = this.applications.get(appName);
    if (app && app.status === 'MOUNTED') {
      // 尝试重新挂载应用
      this.unmountApplication(appName)
        .then(() => this.mountApplication(appName))
        .catch(console.error);
    }
  }
}

// 2. 微前端路由管理
class MicrofrontendRouter {
  constructor(orchestrator) {
    this.orchestrator = orchestrator;
    this.routes = new Map();
    this.currentApp = null;
    this.setupRouting();
  }
  
  registerRoute(path, appName) {
    this.routes.set(path, appName);
  }
  
  setupRouting() {
    window.addEventListener('popstate', () => {
      this.handleRouteChange();
    });
    
    // 拦截pushState和replaceState
    this.interceptHistoryMethods();
    
    // 初始路由处理
    this.handleRouteChange();
  }
  
  interceptHistoryMethods() {
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = (...args) => {
      originalPushState.apply(history, args);
      this.handleRouteChange();
    };
    
    history.replaceState = (...args) => {
      originalReplaceState.apply(history, args);
      this.handleRouteChange();
    };
  }
  
  async handleRouteChange() {
    const currentPath = window.location.pathname;
    const targetApp = this.findMatchingApp(currentPath);
    
    if (targetApp !== this.currentApp) {
      // 卸载当前应用
      if (this.currentApp) {
        await this.orchestrator.unmountApplication(this.currentApp);
      }
      
      // 挂载新应用
      if (targetApp) {
        await this.orchestrator.mountApplication(targetApp);
        this.currentApp = targetApp;
      }
    }
  }
  
  findMatchingApp(path) {
    for (const [routePath, appName] of this.routes) {
      if (path.startsWith(routePath)) {
        return appName;
      }
    }
    return null;
  }
}

// 使用示例
const orchestrator = new MicrofrontendOrchestrator();
const router = new MicrofrontendRouter(orchestrator);

// 注册微应用
orchestrator.registerApplication({
  name: 'header-app',
  entry: './micro-apps/header/index.js',
  container: '#header-container',
  activeRule: () => true
});

orchestrator.registerApplication({
  name: 'dashboard-app',
  entry: './micro-apps/dashboard/index.js',
  container: '#main-container',
  activeRule: (location) => location.pathname.startsWith('/dashboard')
});

// 注册路由
router.registerRoute('/dashboard', 'dashboard-app');
router.registerRoute('/profile', 'profile-app');

// 创建通信桥
const communicationBridge = orchestrator.createCommunicationBridge();

// 应用间通信示例
communicationBridge.on('user-login', (event) => {
  console.log('用户登录:', event.detail);
  communicationBridge.setSharedState('currentUser', event.detail.user);
});
```

## 组件化架构模式

<Callout type="info">
组件化架构是现代前端开发的核心思想，通过将UI拆分为独立、可复用的组件来提高开发效率和代码质量。
</Callout>

### 组件设计原则

```javascript
// 1. 单一职责原则
// 好的组件设计 - 职责单一
const UserAvatar = ({ user, size = 'medium', onClick }) => {
  const sizeClasses = {
    small: 'w-8 h-8',
    medium: 'w-12 h-12',
    large: 'w-16 h-16'
  };

  return (
    <div
      className={`rounded-full overflow-hidden ${sizeClasses[size]} cursor-pointer`}
      onClick={onClick}
    >
      <img
        src={user.avatar || '/default-avatar.png'}
        alt={user.name}
        className="w-full h-full object-cover"
      />
    </div>
  );
};

// 2. 组合优于继承
const Card = ({ children, className = '', ...props }) => (
  <div className={`bg-white rounded-lg shadow-md p-4 ${className}`} {...props}>
    {children}
  </div>
);

const CardHeader = ({ children, className = '' }) => (
  <div className={`border-b pb-2 mb-4 ${className}`}>
    {children}
  </div>
);

const CardBody = ({ children, className = '' }) => (
  <div className={className}>
    {children}
  </div>
);

const CardFooter = ({ children, className = '' }) => (
  <div className={`border-t pt-2 mt-4 ${className}`}>
    {children}
  </div>
);

// 使用组合
const UserCard = ({ user }) => (
  <Card>
    <CardHeader>
      <div className="flex items-center space-x-3">
        <UserAvatar user={user} />
        <h3 className="text-lg font-semibold">{user.name}</h3>
      </div>
    </CardHeader>
    <CardBody>
      <p className="text-gray-600">{user.bio}</p>
    </CardBody>
    <CardFooter>
      <button className="btn-primary">Follow</button>
    </CardFooter>
  </Card>
);

// 3. 高阶组件模式
const withLoading = (WrappedComponent) => {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div className="spinner">Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

const withErrorBoundary = (WrappedComponent) => {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
      return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
      console.error('Component error:', error, errorInfo);
    }

    render() {
      if (this.state.hasError) {
        return <div className="error">Something went wrong.</div>;
      }
      return <WrappedComponent {...this.props} />;
    }
  };
};

// 4. Render Props模式
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
};

// 使用Render Props
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      return (
        <div>
          {data.map(user => (
            <UserCard key={user.id} user={user} />
          ))}
        </div>
      );
    }}
  </DataFetcher>
);

// 5. 复合组件模式
const Tabs = ({ children, defaultTab = 0 }) => {
  const [activeTab, setActiveTab] = useState(defaultTab);

  const tabs = React.Children.toArray(children);

  return (
    <div className="tabs">
      <div className="tab-list">
        {tabs.map((tab, index) => (
          <button
            key={index}
            className={`tab ${index === activeTab ? 'active' : ''}`}
            onClick={() => setActiveTab(index)}
          >
            {tab.props.label}
          </button>
        ))}
      </div>
      <div className="tab-content">
        {tabs[activeTab]}
      </div>
    </div>
  );
};

const TabPanel = ({ children, label }) => (
  <div className="tab-panel">
    {children}
  </div>
);

// 使用复合组件
const App = () => (
  <Tabs defaultTab={0}>
    <TabPanel label="Home">
      <h2>Home Content</h2>
    </TabPanel>
    <TabPanel label="About">
      <h2>About Content</h2>
    </TabPanel>
    <TabPanel label="Contact">
      <h2>Contact Content</h2>
    </TabPanel>
  </Tabs>
);
```

## 模块化和依赖管理

<Callout type="warning">
良好的模块化设计和依赖管理是大型前端应用可维护性的关键，需要合理的模块划分和依赖关系设计。
</Callout>

### 模块化架构设计

```javascript
// 1. 分层架构模式
// 表现层 (Presentation Layer)
// components/UserProfile.jsx
import { useUser } from '../hooks/useUser';
import { userService } from '../services/userService';

export const UserProfile = ({ userId }) => {
  const { user, loading, error, updateUser } = useUser(userId);

  const handleUpdate = async (userData) => {
    try {
      await updateUser(userData);
    } catch (error) {
      console.error('Update failed:', error);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => handleUpdate({ ...user, lastSeen: new Date() })}>
        Update Last Seen
      </button>
    </div>
  );
};

// 业务逻辑层 (Business Logic Layer)
// hooks/useUser.js
import { useState, useEffect } from 'react';
import { userService } from '../services/userService';

export const useUser = (userId) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    loadUser();
  }, [userId]);

  const loadUser = async () => {
    try {
      setLoading(true);
      const userData = await userService.getUser(userId);
      setUser(userData);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  const updateUser = async (userData) => {
    const updatedUser = await userService.updateUser(userId, userData);
    setUser(updatedUser);
    return updatedUser;
  };

  return { user, loading, error, updateUser, reload: loadUser };
};

// 服务层 (Service Layer)
// services/userService.js
import { apiClient } from './apiClient';
import { cacheManager } from '../utils/cacheManager';

class UserService {
  async getUser(userId) {
    const cacheKey = `user:${userId}`;
    const cached = cacheManager.get(cacheKey);

    if (cached) {
      return cached;
    }

    const user = await apiClient.get(`/users/${userId}`);
    cacheManager.set(cacheKey, user, 5 * 60 * 1000); // 5分钟缓存
    return user;
  }

  async updateUser(userId, userData) {
    const updatedUser = await apiClient.put(`/users/${userId}`, userData);
    cacheManager.delete(`user:${userId}`);
    return updatedUser;
  }

  async createUser(userData) {
    return apiClient.post('/users', userData);
  }

  async deleteUser(userId) {
    await apiClient.delete(`/users/${userId}`);
    cacheManager.delete(`user:${userId}`);
  }
}

export const userService = new UserService();

// 数据访问层 (Data Access Layer)
// services/apiClient.js
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.interceptors = {
      request: [],
      response: []
    };
  }

  addRequestInterceptor(interceptor) {
    this.interceptors.request.push(interceptor);
  }

  addResponseInterceptor(interceptor) {
    this.interceptors.response.push(interceptor);
  }

  async request(url, options = {}) {
    let config = {
      ...options,
      url: `${this.baseURL}${url}`,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    };

    // 应用请求拦截器
    for (const interceptor of this.interceptors.request) {
      config = await interceptor(config);
    }

    let response = await fetch(config.url, config);

    // 应用响应拦截器
    for (const interceptor of this.interceptors.response) {
      response = await interceptor(response);
    }

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }

  get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  }

  post(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  put(url, data, options = {}) {
    return this.request(url, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }

  delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }
}

export const apiClient = new APIClient(process.env.REACT_APP_API_URL);

// 2. 依赖注入模式
class DIContainer {
  constructor() {
    this.services = new Map();
    this.singletons = new Map();
  }

  register(name, factory, options = {}) {
    this.services.set(name, {
      factory,
      singleton: options.singleton || false,
      dependencies: options.dependencies || []
    });
  }

  resolve(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }

    if (service.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }

    const dependencies = service.dependencies.map(dep => this.resolve(dep));
    const instance = service.factory(...dependencies);

    if (service.singleton) {
      this.singletons.set(name, instance);
    }

    return instance;
  }
}

// 使用依赖注入
const container = new DIContainer();

container.register('logger', () => new Logger(), { singleton: true });
container.register('apiClient', (logger) => new APIClient('/api', logger), {
  dependencies: ['logger'],
  singleton: true
});
container.register('userService', (apiClient) => new UserService(apiClient), {
  dependencies: ['apiClient'],
  singleton: true
});

// 3. 模块联邦架构
// webpack.config.js (主应用)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        userModule: 'userModule@http://localhost:3001/remoteEntry.js',
        productModule: 'productModule@http://localhost:3002/remoteEntry.js'
      }
    })
  ]
};

// 动态导入远程模块
const loadUserModule = async () => {
  const { UserModule } = await import('userModule/UserModule');
  return UserModule;
};

const App = () => {
  const [UserModule, setUserModule] = useState(null);

  useEffect(() => {
    loadUserModule().then(setUserModule);
  }, []);

  return (
    <div>
      <h1>Main Application</h1>
      {UserModule && <UserModule />}
    </div>
  );
};
```

## 可扩展性设计原则

<Callout type="info">
可扩展性设计确保应用能够随着业务增长而平滑扩展，包括功能扩展、性能扩展和团队扩展。
</Callout>

### 可扩展架构模式

```javascript
// 1. 插件化架构
class PluginManager {
  constructor() {
    this.plugins = new Map();
    this.hooks = new Map();
  }

  registerPlugin(name, plugin) {
    if (this.plugins.has(name)) {
      throw new Error(`Plugin ${name} already registered`);
    }

    this.plugins.set(name, plugin);

    // 初始化插件
    if (plugin.init) {
      plugin.init(this);
    }

    // 注册插件的钩子
    if (plugin.hooks) {
      Object.entries(plugin.hooks).forEach(([hookName, handler]) => {
        this.addHook(hookName, handler);
      });
    }
  }

  addHook(name, handler) {
    if (!this.hooks.has(name)) {
      this.hooks.set(name, []);
    }
    this.hooks.get(name).push(handler);
  }

  async executeHook(name, context = {}) {
    const handlers = this.hooks.get(name) || [];
    let result = context;

    for (const handler of handlers) {
      result = await handler(result);
    }

    return result;
  }

  getPlugin(name) {
    return this.plugins.get(name);
  }

  removePlugin(name) {
    const plugin = this.plugins.get(name);
    if (plugin && plugin.destroy) {
      plugin.destroy();
    }
    this.plugins.delete(name);
  }
}

// 示例插件
const analyticsPlugin = {
  name: 'analytics',

  init(pluginManager) {
    console.log('Analytics plugin initialized');
  },

  hooks: {
    'page:view': async (context) => {
      console.log('Page viewed:', context.path);
      // 发送分析数据
      await fetch('/api/analytics/pageview', {
        method: 'POST',
        body: JSON.stringify({
          path: context.path,
          timestamp: Date.now()
        })
      });
      return context;
    },

    'user:action': async (context) => {
      console.log('User action:', context.action);
      return context;
    }
  },

  destroy() {
    console.log('Analytics plugin destroyed');
  }
};

// 2. 事件驱动架构
class EventBus {
  constructor() {
    this.events = new Map();
  }

  on(event, handler) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(handler);
  }

  off(event, handler) {
    const handlers = this.events.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  emit(event, data) {
    const handlers = this.events.get(event) || [];
    handlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    });
  }

  once(event, handler) {
    const onceHandler = (data) => {
      handler(data);
      this.off(event, onceHandler);
    };
    this.on(event, onceHandler);
  }
}

// 使用事件驱动架构
const eventBus = new EventBus();

// 用户模块
class UserModule {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.setupEventListeners();
  }

  setupEventListeners() {
    this.eventBus.on('user:login', this.handleUserLogin.bind(this));
    this.eventBus.on('user:logout', this.handleUserLogout.bind(this));
  }

  handleUserLogin(user) {
    console.log('User logged in:', user);
    // 更新用户状态
    this.eventBus.emit('user:status:changed', { user, status: 'online' });
  }

  handleUserLogout() {
    console.log('User logged out');
    this.eventBus.emit('user:status:changed', { status: 'offline' });
  }

  login(credentials) {
    // 登录逻辑
    const user = { id: 1, name: 'John Doe' };
    this.eventBus.emit('user:login', user);
  }
}

// 3. 微服务前端架构
class MicroFrontendOrchestrator {
  constructor() {
    this.applications = new Map();
    this.routes = new Map();
    this.sharedState = new Map();
  }

  registerApplication(name, config) {
    this.applications.set(name, {
      ...config,
      status: 'registered'
    });

    // 注册路由
    if (config.routes) {
      config.routes.forEach(route => {
        this.routes.set(route, name);
      });
    }
  }

  async loadApplication(name) {
    const app = this.applications.get(name);
    if (!app) {
      throw new Error(`Application ${name} not found`);
    }

    if (app.status === 'loaded') {
      return app.instance;
    }

    try {
      app.status = 'loading';

      // 动态导入应用
      const module = await import(app.url);
      const instance = module.default || module;

      // 初始化应用
      if (instance.mount) {
        await instance.mount({
          container: app.container,
          sharedState: this.sharedState,
          eventBus: this.eventBus
        });
      }

      app.instance = instance;
      app.status = 'loaded';

      return instance;
    } catch (error) {
      app.status = 'error';
      throw error;
    }
  }

  async unloadApplication(name) {
    const app = this.applications.get(name);
    if (app && app.instance && app.instance.unmount) {
      await app.instance.unmount();
      app.status = 'registered';
      app.instance = null;
    }
  }

  async navigateToRoute(path) {
    const appName = this.routes.get(path);
    if (appName) {
      await this.loadApplication(appName);
    }
  }

  setSharedState(key, value) {
    this.sharedState.set(key, value);
    // 通知所有应用状态变化
    this.applications.forEach((app, name) => {
      if (app.instance && app.instance.onSharedStateChange) {
        app.instance.onSharedStateChange(key, value);
      }
    });
  }

  getSharedState(key) {
    return this.sharedState.get(key);
  }
}

// 4. 配置驱动架构
class ConfigurableApplication {
  constructor(config) {
    this.config = config;
    this.components = new Map();
    this.layouts = new Map();
    this.themes = new Map();
  }

  registerComponent(name, component) {
    this.components.set(name, component);
  }

  registerLayout(name, layout) {
    this.layouts.set(name, layout);
  }

  registerTheme(name, theme) {
    this.themes.set(name, theme);
  }

  renderPage(pageConfig) {
    const { layout, components, theme } = pageConfig;

    const LayoutComponent = this.layouts.get(layout);
    const themeConfig = this.themes.get(theme);

    if (!LayoutComponent) {
      throw new Error(`Layout ${layout} not found`);
    }

    const renderedComponents = components.map(componentConfig => {
      const Component = this.components.get(componentConfig.type);
      if (!Component) {
        console.warn(`Component ${componentConfig.type} not found`);
        return null;
      }

      return React.createElement(Component, {
        key: componentConfig.id,
        ...componentConfig.props
      });
    });

    return React.createElement(LayoutComponent, {
      theme: themeConfig,
      children: renderedComponents
    });
  }
}

// 页面配置示例
const pageConfig = {
  layout: 'main',
  theme: 'default',
  components: [
    {
      id: 'header',
      type: 'Header',
      props: {
        title: 'Welcome',
        showNavigation: true
      }
    },
    {
      id: 'content',
      type: 'ContentArea',
      props: {
        sections: [
          { type: 'hero', title: 'Hero Section' },
          { type: 'features', items: ['Feature 1', 'Feature 2'] }
        ]
      }
    },
    {
      id: 'footer',
      type: 'Footer',
      props: {
        copyright: '2023 Company Name'
      }
    }
  ]
};
```

## 架构决策和权衡

<Callout type="warning">
架构决策需要在多个因素之间进行权衡，包括性能、可维护性、开发效率、团队技能等。
</Callout>

### 架构决策框架

```javascript
// 1. 架构决策记录 (ADR)
class ArchitectureDecisionRecord {
  constructor(title, status = 'proposed') {
    this.title = title;
    this.status = status; // proposed, accepted, deprecated, superseded
    this.date = new Date().toISOString();
    this.context = '';
    this.decision = '';
    this.consequences = {
      positive: [],
      negative: [],
      neutral: []
    };
    this.alternatives = [];
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setDecision(decision) {
    this.decision = decision;
    return this;
  }

  addConsequence(type, consequence) {
    if (this.consequences[type]) {
      this.consequences[type].push(consequence);
    }
    return this;
  }

  addAlternative(alternative) {
    this.alternatives.push(alternative);
    return this;
  }

  accept() {
    this.status = 'accepted';
    this.acceptedDate = new Date().toISOString();
    return this;
  }

  deprecate(reason) {
    this.status = 'deprecated';
    this.deprecatedDate = new Date().toISOString();
    this.deprecationReason = reason;
    return this;
  }

  supersede(newADR) {
    this.status = 'superseded';
    this.supersededBy = newADR.title;
    this.supersededDate = new Date().toISOString();
    return this;
  }

  toMarkdown() {
    return `
# ${this.title}

**Status:** ${this.status}
**Date:** ${this.date}

## Context

${this.context}

## Decision

${this.decision}

## Consequences

### Positive
${this.consequences.positive.map(c => `- ${c}`).join('\n')}

### Negative
${this.consequences.negative.map(c => `- ${c}`).join('\n')}

### Neutral
${this.consequences.neutral.map(c => `- ${c}`).join('\n')}

## Alternatives Considered

${this.alternatives.map(alt => `- ${alt}`).join('\n')}
    `.trim();
  }
}

// 2. 架构评估矩阵
class ArchitectureEvaluationMatrix {
  constructor() {
    this.criteria = new Map();
    this.alternatives = [];
    this.weights = new Map();
  }

  addCriterion(name, description, weight = 1) {
    this.criteria.set(name, { description, weight });
    this.weights.set(name, weight);
  }

  addAlternative(name, scores = {}) {
    this.alternatives.push({ name, scores });
  }

  scoreAlternative(alternativeName, criterion, score) {
    const alternative = this.alternatives.find(alt => alt.name === alternativeName);
    if (alternative) {
      alternative.scores[criterion] = score;
    }
  }

  calculateWeightedScores() {
    return this.alternatives.map(alternative => {
      let totalScore = 0;
      let totalWeight = 0;

      for (const [criterion, weight] of this.weights) {
        const score = alternative.scores[criterion] || 0;
        totalScore += score * weight;
        totalWeight += weight;
      }

      return {
        name: alternative.name,
        weightedScore: totalScore / totalWeight,
        scores: alternative.scores
      };
    }).sort((a, b) => b.weightedScore - a.weightedScore);
  }

  generateReport() {
    const results = this.calculateWeightedScores();

    return {
      criteria: Array.from(this.criteria.entries()),
      alternatives: results,
      recommendation: results[0]?.name,
      analysis: this.generateAnalysis(results)
    };
  }

  generateAnalysis(results) {
    const analysis = [];

    // 找出最佳选择
    if (results.length > 0) {
      analysis.push(`推荐方案: ${results[0].name} (得分: ${results[0].weightedScore.toFixed(2)})`);
    }

    // 分析各个标准的表现
    for (const [criterion] of this.criteria) {
      const bestInCriterion = this.alternatives.reduce((best, current) => {
        return (current.scores[criterion] || 0) > (best.scores[criterion] || 0) ? current : best;
      });

      analysis.push(`${criterion}最佳: ${bestInCriterion.name} (${bestInCriterion.scores[criterion] || 0}分)`);
    }

    return analysis;
  }
}

// 3. 技术债务管理
class TechnicalDebtTracker {
  constructor() {
    this.debts = [];
    this.categories = ['performance', 'maintainability', 'security', 'scalability'];
  }

  addDebt(debt) {
    const debtItem = {
      id: Math.random().toString(36).substr(2, 9),
      title: debt.title,
      description: debt.description,
      category: debt.category,
      severity: debt.severity, // low, medium, high, critical
      effort: debt.effort, // hours
      impact: debt.impact, // 1-10
      createdDate: new Date().toISOString(),
      status: 'open', // open, in-progress, resolved
      assignee: debt.assignee,
      dueDate: debt.dueDate
    };

    this.debts.push(debtItem);
    return debtItem;
  }

  updateDebt(id, updates) {
    const debt = this.debts.find(d => d.id === id);
    if (debt) {
      Object.assign(debt, updates);
      if (updates.status === 'resolved') {
        debt.resolvedDate = new Date().toISOString();
      }
    }
    return debt;
  }

  getDebtsByCategory(category) {
    return this.debts.filter(debt => debt.category === category);
  }

  getDebtsBySeverity(severity) {
    return this.debts.filter(debt => debt.severity === severity);
  }

  calculateDebtMetrics() {
    const totalDebts = this.debts.length;
    const openDebts = this.debts.filter(d => d.status === 'open').length;
    const totalEffort = this.debts.reduce((sum, debt) => sum + (debt.effort || 0), 0);

    const categoryBreakdown = this.categories.map(category => ({
      category,
      count: this.getDebtsByCategory(category).length,
      effort: this.getDebtsByCategory(category).reduce((sum, debt) => sum + (debt.effort || 0), 0)
    }));

    const severityBreakdown = ['low', 'medium', 'high', 'critical'].map(severity => ({
      severity,
      count: this.getDebtsBySeverity(severity).length
    }));

    return {
      totalDebts,
      openDebts,
      resolvedDebts: totalDebts - openDebts,
      totalEffort,
      categoryBreakdown,
      severityBreakdown,
      debtRatio: openDebts / totalDebts
    };
  }

  prioritizeDebts() {
    return this.debts
      .filter(debt => debt.status === 'open')
      .map(debt => ({
        ...debt,
        priority: this.calculatePriority(debt)
      }))
      .sort((a, b) => b.priority - a.priority);
  }

  calculatePriority(debt) {
    const severityWeight = {
      low: 1,
      medium: 2,
      high: 3,
      critical: 4
    };

    const impactWeight = debt.impact || 5;
    const effortPenalty = Math.min(debt.effort / 40, 2); // 减少高工作量项目的优先级

    return (severityWeight[debt.severity] * 2 + impactWeight) / (1 + effortPenalty);
  }
}

// 使用示例
// 创建架构决策记录
const microFrontendADR = new ArchitectureDecisionRecord('采用微前端架构')
  .setContext('随着团队规模扩大和产品复杂度增加，单体前端应用变得难以维护')
  .setDecision('采用基于Module Federation的微前端架构')
  .addConsequence('positive', '团队可以独立开发和部署')
  .addConsequence('positive', '技术栈可以多样化')
  .addConsequence('negative', '增加了架构复杂度')
  .addConsequence('negative', '需要额外的协调机制')
  .addAlternative('继续使用单体架构')
  .addAlternative('采用iframe方案')
  .accept();

// 架构评估
const evaluationMatrix = new ArchitectureEvaluationMatrix();
evaluationMatrix.addCriterion('开发效率', '团队开发和维护的效率', 3);
evaluationMatrix.addCriterion('性能', '应用运行时性能', 2);
evaluationMatrix.addCriterion('可扩展性', '架构的扩展能力', 3);
evaluationMatrix.addCriterion('学习成本', '团队学习新架构的成本', 1);

evaluationMatrix.addAlternative('微前端');
evaluationMatrix.scoreAlternative('微前端', '开发效率', 8);
evaluationMatrix.scoreAlternative('微前端', '性能', 6);
evaluationMatrix.scoreAlternative('微前端', '可扩展性', 9);
evaluationMatrix.scoreAlternative('微前端', '学习成本', 4);

evaluationMatrix.addAlternative('单体应用');
evaluationMatrix.scoreAlternative('单体应用', '开发效率', 6);
evaluationMatrix.scoreAlternative('单体应用', '性能', 8);
evaluationMatrix.scoreAlternative('单体应用', '可扩展性', 4);
evaluationMatrix.scoreAlternative('单体应用', '学习成本', 8);

const report = evaluationMatrix.generateReport();
console.log('架构评估报告:', report);
```

---

<Callout type="success">
现代前端架构设计需要平衡复杂性、可维护性和性能。选择合适的架构模式对项目的长期成功至关重要。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [Micro Frontends](https://micro-frontends.org/) - 微前端官方指南
- [Single-spa](https://single-spa.js.org/) - 微前端框架文档
- [Module Federation](https://webpack.js.org/concepts/module-federation/) - Webpack模块联邦
- [qiankun](https://qiankun.umijs.org/) - 蚂蚁金服微前端框架

### 🎓 优质教程
- [Frontend Architecture](https://frontendmasters.com/courses/frontend-architecture/) - Frontend Masters架构课程
- [Micro Frontend Architecture](https://martinfowler.com/articles/micro-frontends.html) - Martin Fowler微前端文章
- [Scalable Frontend Architecture](https://blog.logrocket.com/scalable-frontend-architecture/) - 可扩展前端架构

### 🛠️ 实践项目
- [Micro Frontend Examples](https://github.com/micro-frontends-demo) - 微前端示例项目
- [Architecture Patterns](https://github.com/kamranahmedse/developer-roadmap) - 开发者路线图
- [Frontend Architecture Samples](https://github.com/topics/frontend-architecture) - 前端架构示例

### 🔧 开发工具
- [Single-spa](https://single-spa.js.org/) - 微前端框架
- [qiankun](https://qiankun.umijs.org/) - 微前端解决方案
- [Nx](https://nx.dev/) - 单体仓库工具
- [Lerna](https://lerna.js.org/) - 多包管理工具

### 📝 深入阅读
- [Building Micro Frontends](https://www.buildingmicrofrontends.com/) - 微前端构建指南
- [Frontend Architecture Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/) - 前端架构模式
- [Scalable JavaScript Architecture](https://www.youtube.com/watch?v=mKouqShWI4o) - 可扩展JavaScript架构

<Callout type="tip">
💡 **学习建议**：建议从理解单体应用的局限性开始，学习组件化和模块化设计，然后深入微前端架构，最后实践大型项目架构设计。
</Callout>

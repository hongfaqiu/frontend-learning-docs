import { Callout } from 'nextra/components'

# 17. 前端安全和最佳实践

## 📋 目录

- [前端安全威胁概览](#前端安全威胁概览)
- [XSS攻击防护](#xss攻击防护)
- [CSRF攻击防护](#csrf攻击防护)
- [内容安全策略CSP](#内容安全策略csp)
- [数据传输安全](#数据传输安全)
- [数据加密与安全存储](#数据加密与安全存储)
- [身份认证与授权](#身份认证与授权)
- [安全测试与监控](#安全测试与监控)
- [安全开发最佳实践](#安全开发最佳实践)

## 前端安全威胁概览

<Callout type="warning">
前端安全是[Web](https://developer.mozilla.org/en-US/docs/Web)应用安全的重要组成部分，了解常见威胁和防护措施对于构建安全的Web应用至关重要。
</Callout>

### 常见安全威胁分类

#### 前端安全威胁概览

| 威胁类型 | 常见形式 | 影响 | 防护措施 |
|----------|----------|------|----------|
| **注入攻击** | XSS、SQL注入、代码注入 | 数据泄露、会话劫持 | 输入验证、输出编码、CSP |
| **身份认证缺陷** | 弱密码、会话劫持、暴力破解 | 账户被盗、未授权访问 | 强密码策略、MFA、会话管理 |
| **敏感数据暴露** | 明文传输、不当存储、缓存泄露 | 隐私泄露、合规风险 | HTTPS、数据加密、访问控制 |
| **CSRF攻击** | 跨站请求伪造 | 恶意操作、数据篡改 | CSRF Token、SameSite Cookie |
| **安全配置错误** | 默认配置、权限错误、信息泄露 | 系统暴露、攻击面扩大 | 安全配置检查、最小权限原则 |

#### 安全威胁严重程度

| 严重程度 | 描述 | 示例 | 处理优先级 |
|----------|------|------|------------|
| **严重** | 可直接获取系统控制权 | 远程代码执行、SQL注入 | 立即修复 |
| **高** | 可获取敏感数据 | XSS、CSRF、数据泄露 | 24小时内修复 |
| **中** | 可影响系统可用性 | 拒绝服务、信息泄露 | 1周内修复 |
| **低** | 影响有限 | 配置问题、弱加密 | 1个月内修复 |

#### 安全评估流程

| 评估阶段 | 检查项目 | 工具/方法 | 频率 |
|----------|----------|-----------|------|
| **代码审查** | XSS、CSRF、注入漏洞 | ESLint Security、人工审查 | 每次提交 |
| **依赖扫描** | 已知漏洞、过期依赖 | npm audit、Snyk | 每日 |
| **配置检查** | 安全头、CSP、HTTPS | Security Headers工具 | 每周 |
| **渗透测试** | 综合安全评估 | OWASP ZAP、专业测试 | 每月 |

```javascript
// 简化的安全检查示例
class SimpleSecurityChecker {
  static checkBasicSecurity() {
    const checks = {
      https: location.protocol === 'https:',
      csp: !!document.querySelector('meta[http-equiv*="Content-Security-Policy"]'),
      xFrameOptions: this.hasSecurityHeader('X-Frame-Options'),
      noSniff: this.hasSecurityHeader('X-Content-Type-Options')
    };

    const score = Object.values(checks).filter(Boolean).length;
    return { checks, score: (score / 4) * 100 };
  }

  static hasSecurityHeader(header) {
    // 简化检查，实际需要检查HTTP响应头
    return document.querySelector(`meta[http-equiv="${header}"]`) !== null;
  }
}


```

## XSS攻击防护

<Callout type="warning">
XSS（跨站脚本攻击）是最常见的Web安全威胁之一，通过注入恶意脚本来窃取用户信息或执行恶意操作。
</Callout>

### XSS攻击类型

| 类型 | 描述 | 示例 | 防护方法 |
|------|------|------|----------|
| **存储型XSS** | 恶意脚本存储在服务器 | 评论、留言板 | 服务端过滤、输出编码 |
| **反射型XSS** | 恶意脚本通过URL参数传递 | 搜索结果页面 | 输入验证、输出编码 |
| **DOM型XSS** | 客户端脚本直接操作DOM | innerHTML赋值 | 避免危险API、使用安全方法 |

### XSS防护策略

#### 输入验证和输出编码

| 防护层面 | 方法 | 实施位置 | 效果 |
|----------|------|----------|------|
| **输入验证** | 白名单过滤、长度限制 | 客户端+服务端 | 阻止恶意输入 |
| **输出编码** | HTML实体编码 | 模板引擎 | 防止脚本执行 |
| **CSP策略** | 内容安全策略 | HTTP头 | 限制脚本来源 |
| **安全API** | textContent替代innerHTML | 客户端代码 | 避免HTML解析 |

#### 简化的XSS防护实现

```javascript
// 简单的XSS防护工具
class SimpleXSSProtection {
  // HTML实体编码
  static escapeHTML(str) {
    const entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };

    return String(str).replace(/[&<>"'/]/g, (s) => entityMap[s]);
  }

  // 安全地设置文本内容
  static safeSetText(element, text) {
    element.textContent = text; // 使用textContent而不是innerHTML
  }

  // 安全地设置HTML内容（使用DOMPurify等库）
  static safeSetHTML(element, html) {
    // 实际项目中应使用DOMPurify库
    element.innerHTML = this.escapeHTML(html);
  }
```

### 内容安全策略 (CSP)

CSP是防止XSS攻击的重要安全机制，通过限制资源加载来源来防止恶意脚本执行。

#### CSP配置示例

| 指令 | 作用 | 示例值 | 说明 |
|------|------|--------|------|
| **default-src** | 默认资源策略 | 'self' | 只允许同源资源 |
| **script-src** | 脚本资源策略 | 'self' 'unsafe-inline' | 允许同源和内联脚本 |
| **style-src** | 样式资源策略 | 'self' 'unsafe-inline' | 允许同源和内联样式 |
| **img-src** | 图片资源策略 | 'self' data: https: | 允许同源、data和HTTPS图片 |

```html
<!-- CSP配置示例 -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self' 'unsafe-inline' https://cdn.example.com;
               style-src 'self' 'unsafe-inline';
               img-src 'self' data: https:;">
```

```javascript
// 动态设置CSP
function setCSP() {
  const meta = document.createElement('meta');
  meta.httpEquiv = 'Content-Security-Policy';
  meta.content = "default-src 'self'; script-src 'self' 'unsafe-inline'";
  document.head.appendChild(meta);
```

## CSRF攻击防护

<Callout type="warning">
CSRF（跨站请求伪造）攻击通过诱导用户在已认证的网站上执行非预期的操作，是常见的Web安全威胁。
</Callout>

### CSRF攻击原理

| 攻击步骤 | 描述 | 示例 |
|----------|------|------|
| **1. 用户登录** | 用户登录目标网站 | 银行网站、社交平台 |
| **2. 获取凭证** | 浏览器保存认证信息 | Session Cookie |
| **3. 访问恶意网站** | 用户访问攻击者网站 | 钓鱼邮件、恶意链接 |
| **4. 发起请求** | 恶意网站向目标网站发请求 | 转账、修改密码 |
| **5. 自动认证** | 浏览器自动携带凭证 | Cookie自动发送 |

### CSRF防护策略

#### 防护方法对比

| 防护方法 | 安全性 | 实施难度 | 用户体验 | 适用场景 |
|----------|--------|----------|----------|----------|
| **CSRF Token** | 高 | 中 | 好 | 表单提交 |
| **SameSite Cookie** | 高 | 低 | 好 | 现代浏览器 |
| **双重提交Cookie** | 中 | 低 | 好 | API接口 |
| **验证Referer** | 低 | 低 | 好 | 辅助验证 |

#### 简化的CSRF防护实现

```javascript
// 简单的CSRF防护工具
class SimpleCSRFProtection {
  // 生成CSRF Token
  static generateToken() {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  // 设置CSRF Token到表单
  static addTokenToForm(form) {
    const token = this.generateToken();
    sessionStorage.setItem('csrf_token', token);

    const input = document.createElement('input');
    input.type = 'hidden';
    input.name = 'csrf_token';
    input.value = token;
    form.appendChild(input);
  }

  // 验证CSRF Token
  static validateToken(submittedToken) {
    const storedToken = sessionStorage.getItem('csrf_token');
    return submittedToken === storedToken;
  }
```

### SameSite Cookie配置

SameSite属性是防止CSRF攻击的现代方法，通过限制Cookie的跨站发送来提供保护。

#### SameSite属性值

| 值 | 行为 | 安全性 | 兼容性 | 适用场景 |
|----|------|--------|--------|----------|
| **Strict** | 完全禁止跨站发送 | 最高 | 好 | 高安全要求 |
| **Lax** | 导航请求可发送 | 高 | 好 | 平衡安全与体验 |
| **None** | 允许跨站发送 | 低 | 需HTTPS | 第三方集成 |

```javascript
// 设置安全的Cookie
function setSecureCookie(name, value, options = {}) {
  const defaults = {
    secure: true,        // 仅HTTPS传输
    httpOnly: true,      // 防止XSS访问
    sameSite: 'Lax',     // 防止CSRF
    maxAge: 3600         // 1小时过期
  };

  const config = { ...defaults, ...options };
  const cookieString = `${name}=${value}; ${Object.entries(config)
    .map(([key, val]) => `${key}=${val}`)
    .join('; ')}`;

  document.cookie = cookieString;
```

## 内容安全策略CSP

<Callout type="info">
内容安全策略（Content Security Policy, CSP）是一个重要的安全层，用于检测和减轻某些类型的攻击，包括跨站脚本（XSS）和数据注入攻击。
</Callout>

### CSP基础概念

CSP通过指定浏览器应该信任的内容来源，帮助防止恶意内容的执行。

#### CSP指令类型

| 指令 | 作用 | 示例 | 说明 |
|------|------|------|------|
| **default-src** | 默认策略 | 'self' | 为其他指令提供默认值 |
| **script-src** | 脚本来源 | 'self' 'unsafe-inline' | 控制JavaScript执行 |
| **style-src** | 样式来源 | 'self' 'unsafe-inline' | 控制CSS加载 |
| **img-src** | 图片来源 | 'self' data: https: | 控制图片资源 |
| **connect-src** | 连接来源 | 'self' https://api.example.com | 控制Ajax、WebSocket等 |
| **font-src** | 字体来源 | 'self' https://fonts.googleapis.com | 控制字体资源 |
| **object-src** | 对象来源 | 'none' | 控制插件（Flash等） |
| **media-src** | 媒体来源 | 'self' | 控制音视频资源 |

#### CSP值类型

| 值 | 含义 | 安全性 | 使用场景 |
|----|------|--------|----------|
| **'none'** | 禁止所有来源 | 最高 | 完全禁用某类资源 |
| **'self'** | 同源策略 | 高 | 只允许同源资源 |
| **'unsafe-inline'** | 允许内联 | 低 | 兼容内联脚本/样式 |
| **'unsafe-eval'** | 允许eval | 极低 | 兼容动态代码执行 |
| **域名** | 指定域名 | 中 | 信任的第三方域名 |
| **'nonce-xxx'** | 随机数验证 | 高 | 动态内联内容 |
| **'sha256-xxx'** | 哈希验证 | 高 | 静态内联内容 |

### CSP配置实践

#### 渐进式CSP部署

| 阶段 | 策略 | 目标 | 风险 |
|------|------|------|------|
| **1. 监控模式** | Report-Only | 收集违规报告 | 无 |
| **2. 宽松策略** | 允许unsafe-inline | 确保功能正常 | 中 |
| **3. 严格策略** | 禁用unsafe-inline | 提高安全性 | 高 |
| **4. 最严策略** | 使用nonce/hash | 最大安全性 | 最高 |

```html
<!-- 阶段1：监控模式 -->
<meta http-equiv="Content-Security-Policy-Report-Only"
      content="default-src 'self'; report-uri /csp-report">

<!-- 阶段2：宽松策略 -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self' 'unsafe-inline' https://cdn.example.com;
               style-src 'self' 'unsafe-inline';">

<!-- 阶段3：严格策略 -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self' https://cdn.example.com;
               style-src 'self';">
```

#### 动态CSP管理

```javascript
// CSP管理工具
class CSPManager {
  constructor() {
    this.policies = new Map();
    this.nonces = new Map();
  }

  // 生成随机nonce
  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode.apply(null, array));
  }

  // 设置页面级CSP
  setPageCSP(policies) {
    const cspString = Object.entries(policies)
      .map(([directive, sources]) => {
        const sourceList = Array.isArray(sources) ? sources.join(' ') : sources;
        return `${directive} ${sourceList}`;
      })
      .join('; ');

    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = cspString;
    document.head.appendChild(meta);
  }

  // 为内联脚本生成nonce
  createInlineScript(code, nonce = null) {
    if (!nonce) {
      nonce = this.generateNonce();
    }

    const script = document.createElement('script');
    script.nonce = nonce;
    script.textContent = code;

    return { script, nonce };
  }

  // 验证CSP违规
  handleCSPViolation(event) {
    const violation = {
      documentURI: event.documentURI,
      violatedDirective: event.violatedDirective,
      blockedURI: event.blockedURI,
      lineNumber: event.lineNumber,
      sourceFile: event.sourceFile,
      timestamp: Date.now()
    };

    // 发送违规报告
    this.reportViolation(violation);
  }

  // 发送违规报告
  async reportViolation(violation) {
    try {
      await fetch('/api/csp-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(violation)
      });
    } catch (error) {
      console.error('Failed to report CSP violation:', error);
    }
  }
}

// 使用示例
const cspManager = new CSPManager();

// 设置严格的CSP策略
cspManager.setPageCSP({
  'default-src': "'self'",
  'script-src': "'self' 'nonce-abc123'",
  'style-src': "'self' 'unsafe-inline'",
  'img-src': "'self' data: https:",
  'connect-src': "'self' https://api.example.com"
});

// 监听CSP违规事件
document.addEventListener('securitypolicyviolation', (event) => {
  cspManager.handleCSPViolation(event);
});
```

### CSP最佳实践

#### 常见CSP配置模板

```javascript
// CSP配置模板
const CSPTemplates = {
  // 严格模式 - 最高安全性
  strict: {
    'default-src': "'none'",
    'script-src': "'self'",
    'style-src': "'self'",
    'img-src': "'self' data:",
    'font-src': "'self'",
    'connect-src': "'self'",
    'object-src': "'none'",
    'base-uri': "'self'",
    'form-action': "'self'"
  },

  // 平衡模式 - 安全性与兼容性平衡
  balanced: {
    'default-src': "'self'",
    'script-src': "'self' 'unsafe-inline' https://cdn.jsdelivr.net",
    'style-src': "'self' 'unsafe-inline' https://fonts.googleapis.com",
    'img-src': "'self' data: https:",
    'font-src': "'self' https://fonts.gstatic.com",
    'connect-src': "'self' https://api.example.com"
  },

  // 宽松模式 - 兼容性优先
  permissive: {
    'default-src': "'self'",
    'script-src': "'self' 'unsafe-inline' 'unsafe-eval'",
    'style-src': "'self' 'unsafe-inline'",
    'img-src': "*",
    'font-src': "*"
  }
};
```

## 数据传输安全

<Callout type="warning">
数据传输安全是Web应用安全的基础，包括HTTPS配置、数据加密和安全通信协议的实施。
</Callout>

### HTTPS配置最佳实践

#### SSL/TLS配置

| 配置项 | 推荐值 | 安全级别 | 说明 |
|--------|--------|----------|------|
| **TLS版本** | TLS 1.2+ | 高 | 禁用TLS 1.0/1.1 |
| **加密套件** | AEAD优先 | 高 | 使用现代加密算法 |
| **密钥长度** | RSA 2048+, ECDSA 256+ | 高 | 足够的密钥强度 |
| **证书类型** | EV/OV证书 | 中 | 增强用户信任 |

#### 安全头配置

```javascript
// 安全头配置
const SecurityHeaders = {
  // 强制HTTPS
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',

  // 防止点击劫持
  'X-Frame-Options': 'DENY',

  // 防止MIME类型嗅探
  'X-Content-Type-Options': 'nosniff',

  // XSS保护
  'X-XSS-Protection': '1; mode=block',

  // 引用策略
  'Referrer-Policy': 'strict-origin-when-cross-origin',

  // 权限策略
  'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
};

// 检查安全头
class SecurityHeaderChecker {
  static async checkHeaders(url) {
    try {
      const response = await fetch(url, { method: 'HEAD' });
      const headers = {};

      for (const [key, value] of response.headers.entries()) {
        headers[key] = value;
      }

      return this.analyzeHeaders(headers);
    } catch (error) {
      return { error: error.message };
    }
  }

  static analyzeHeaders(headers) {
    const analysis = {
      score: 0,
      maxScore: 0,
      details: {}
    };

    const checks = [
      {
        name: 'HTTPS Enforcement',
        header: 'strict-transport-security',
        weight: 20,
        check: (value) => value && value.includes('max-age')
      },
      {
        name: 'Clickjacking Protection',
        header: 'x-frame-options',
        weight: 15,
        check: (value) => value && (value.includes('DENY') || value.includes('SAMEORIGIN'))
      },
      {
        name: 'MIME Sniffing Protection',
        header: 'x-content-type-options',
        weight: 10,
        check: (value) => value === 'nosniff'
      },
      {
        name: 'XSS Protection',
        header: 'x-xss-protection',
        weight: 10,
        check: (value) => value && value.includes('1')
      },
      {
        name: 'Content Security Policy',
        header: 'content-security-policy',
        weight: 25,
        check: (value) => value && value.length > 0
      }
    ];

    checks.forEach(check => {
      analysis.maxScore += check.weight;
      const headerValue = headers[check.header];
      const passed = check.check(headerValue);

      if (passed) {
        analysis.score += check.weight;
      }

      analysis.details[check.name] = {
        passed,
        value: headerValue || 'Not set',
        weight: check.weight
      };
    });

    analysis.grade = this.calculateGrade(analysis.score, analysis.maxScore);
    return analysis;
  }

  static calculateGrade(score, maxScore) {
    const percentage = (score / maxScore) * 100;
    if (percentage >= 90) return 'A';
    if (percentage >= 80) return 'B';
    if (percentage >= 70) return 'C';
    if (percentage >= 60) return 'D';
    return 'F';
  }
}
```

## 数据加密与安全存储

<Callout type="info">
前端数据加密主要用于敏感信息的临时保护，真正的安全应该依赖服务端加密和HTTPS传输。
</Callout>

### 前端加密场景

| 场景 | 加密目的 | 推荐方案 | 安全级别 |
|------|----------|----------|----------|
| **本地存储** | 防止本地数据泄露 | AES-GCM | 中 |
| **传输前加密** | 额外传输保护 | RSA + AES | 高 |
| **密码处理** | 客户端预处理 | bcrypt, PBKDF2 | 高 |
| **Token保护** | 防止XSS窃取 | 加密存储 | 中 |

### Web Crypto API使用

现代浏览器提供了Web Crypto API用于加密操作，比自定义实现更安全。

#### 加密算法对比

| 算法 | 类型 | 密钥长度 | 性能 | 安全性 | 适用场景 |
|------|------|----------|------|--------|----------|
| **AES-GCM** | 对称加密 | 128/256位 | 高 | 高 | 数据加密 |
| **RSA-OAEP** | 非对称加密 | 2048/4096位 | 低 | 高 | 密钥交换 |
| **ECDSA** | 数字签名 | 256/384位 | 中 | 高 | 身份验证 |
| **PBKDF2** | 密钥派生 | 可变 | 低 | 高 | 密码处理 |

#### 简化的加密工具

```javascript
// 简单的前端加密工具
class SimpleCrypto {
  // 生成随机密钥
  static async generateKey() {
    return await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 256 },
      true,
      ['encrypt', 'decrypt']
    );
  }

  // 加密数据
  static async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encodedData = new TextEncoder().encode(data);

    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      encodedData
    );

    return { encrypted, iv };
  }

  // 解密数据
  static async decrypt(encryptedData, key, iv) {
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encryptedData
    );

    return new TextDecoder().decode(decrypted);
  }
```

### 安全存储方案

| 存储方式 | 安全性 | 持久性 | 容量 | 适用数据 |
|----------|--------|--------|------|----------|
| **Memory** | 最高 | 会话期间 | 无限制 | 临时敏感数据 |
| **SessionStorage** | 高 | 标签页期间 | 5-10MB | 会话数据 |
| **LocalStorage** | 中 | 永久 | 5-10MB | 用户偏好 |
| **IndexedDB** | 中 | 永久 | 大容量 | 离线数据 |
| **Cookie** | 低 | 可设置 | 4KB | 认证信息 |

```javascript
// 安全存储工具
class SecureStorage {
  // 加密存储到localStorage
  static async setEncrypted(key, data, password) {
    const cryptoKey = await this.deriveKey(password);
    const { encrypted, iv } = await SimpleCrypto.encrypt(JSON.stringify(data), cryptoKey);

    localStorage.setItem(key, JSON.stringify({
      data: Array.from(new Uint8Array(encrypted)),
      iv: Array.from(iv)
    }));
  }

  // 从localStorage解密读取
  static async getEncrypted(key, password) {
    const stored = localStorage.getItem(key);
    if (!stored) return null;

    const { data, iv } = JSON.parse(stored);
    const cryptoKey = await this.deriveKey(password);

    const decrypted = await SimpleCrypto.decrypt(
      new Uint8Array(data),
      cryptoKey,
      new Uint8Array(iv)
    );

    return JSON.parse(decrypted);
  }

  // 从密码派生密钥
  static async deriveKey(password) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(password),
      'PBKDF2',
      false,
      ['deriveKey']
    );

    return await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode('salt'), // 实际应用中应使用随机salt
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }
```

## 身份认证与授权

<Callout type="info">
前端身份认证主要负责用户界面的访问控制，真正的安全验证应该在服务端进行。
</Callout>

### 认证方案对比

| 方案 | 安全性 | 复杂度 | 扩展性 | 适用场景 |
|------|--------|--------|--------|----------|
| **Session Cookie** | 高 | 低 | 中 | 传统Web应用 |
| **JWT Token** | 中 | 中 | 高 | SPA、API |
| **OAuth 2.0** | 高 | 高 | 高 | 第三方登录 |
| **WebAuthn** | 最高 | 高 | 中 | 无密码认证 |

### Token管理最佳实践

#### Token存储策略

| 存储位置 | 安全性 | XSS风险 | CSRF风险 | 推荐度 |
|----------|--------|---------|----------|--------|
| **Memory** | 最高 | 无 | 无 | ⭐⭐⭐⭐⭐ |
| **HttpOnly Cookie** | 高 | 无 | 有 | ⭐⭐⭐⭐ |
| **LocalStorage** | 低 | 有 | 无 | ⭐⭐ |
| **SessionStorage** | 中 | 有 | 无 | ⭐⭐⭐ |

#### 简化的认证管理

```javascript
// 简单的认证管理器
class SimpleAuthManager {
  constructor() {
    this.token = null;
    this.user = null;
    this.refreshTimer = null;
  }

  // 登录
  async login(credentials) {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });

      if (response.ok) {
        const data = await response.json();
        this.setAuth(data.token, data.user);
        return { success: true, user: data.user };
      }

      return { success: false, error: 'Invalid credentials' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // 设置认证信息
  setAuth(token, user) {
    this.token = token;
    this.user = user;
    this.scheduleRefresh();
  }

  // 登出
  logout() {
    this.token = null;
    this.user = null;
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }
  }

  // 检查是否已认证
  isAuthenticated() {
    return !!this.token && !!this.user;
  }

  // 获取当前用户
  getCurrentUser() {
    return this.user;
  }

  // 定时刷新token
  scheduleRefresh() {
    if (this.refreshTimer) {
      clearTimeout(this.refreshTimer);
    }

    // 15分钟后刷新
    this.refreshTimer = setTimeout(() => {
      this.refreshToken();
    }, 15 * 60 * 1000);
  }

  // 刷新token
  async refreshToken() {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        const data = await response.json();
        this.setAuth(data.token, data.user);
      } else {
        this.logout();
      }
    } catch (error) {
      console.error('Token refresh failed:', error);
      this.logout();
    }
  }
```

### 权限控制

前端权限控制主要用于用户界面的显示逻辑，不能替代服务端的权限验证。

#### 权限模型

| 模型 | 描述 | 适用场景 | 复杂度 |
|------|------|----------|--------|
| **RBAC** | 基于角色的访问控制 | 企业应用 | 中 |
| **ABAC** | 基于属性的访问控制 | 复杂权限场景 | 高 |
| **ACL** | 访问控制列表 | 简单权限场景 | 低 |

```javascript
// 简单的权限控制
class SimplePermissionManager {
  constructor(user) {
    this.user = user;
    this.permissions = user?.permissions || [];
    this.roles = user?.roles || [];
  }

  // 检查权限
  hasPermission(permission) {
    return this.permissions.includes(permission);
  }

  // 检查角色
  hasRole(role) {
    return this.roles.includes(role);
  }

  // 检查多个权限（任一）
  hasAnyPermission(permissions) {
    return permissions.some(p => this.hasPermission(p));
  }

  // 检查多个权限（全部）
  hasAllPermissions(permissions) {
    return permissions.every(p => this.hasPermission(p));
  }
}

// React权限组件示例
function ProtectedComponent({ permission, children }) {
  const { user } = useAuth();
  const permissionManager = new SimplePermissionManager(user);

  if (!permissionManager.hasPermission(permission)) {
    return <div>Access Denied</div>;
  }

  return children;
```

## 安全测试与监控

<Callout type="warning">
安全测试应该贯穿整个开发生命周期，包括静态代码分析、动态测试和持续监控。
</Callout>

### 安全测试类型

| 测试类型 | 测试阶段 | 工具示例 | 检测内容 |
|----------|----------|----------|----------|
| **静态分析** | 开发阶段 | ESLint Security, SonarQube | 代码漏洞、安全规则 |
| **依赖扫描** | 构建阶段 | npm audit, Snyk | 已知漏洞、许可证 |
| **动态测试** | 测试阶段 | OWASP ZAP, Burp Suite | 运行时漏洞 |
| **渗透测试** | 上线前 | 专业测试团队 | 综合安全评估 |

### 安全监控指标

#### 关键监控项

| 监控项 | 指标 | 阈值建议 | 处理方式 |
|--------|------|----------|----------|
| **异常登录** | 失败次数、地理位置 | 5次/小时 | 账户锁定 |
| **XSS尝试** | 恶意脚本检测 | 任何检测 | 立即阻止 |
| **CSRF攻击** | Token验证失败 | 10次/小时 | IP封禁 |
| **暴力破解** | 密码尝试频率 | 20次/小时 | 验证码 |

#### 简化的安全监控

```javascript
// 简单的安全事件监控
class SimpleSecurityMonitor {
  constructor() {
    this.events = [];
    this.thresholds = {
      loginFailures: 5,
      xssAttempts: 1,
      csrfFailures: 10
    };
  }

  // 记录安全事件
  logEvent(type, details) {
    const event = {
      type,
      details,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      ip: this.getClientIP()
    };

    this.events.push(event);
    this.checkThresholds(type);
    this.sendToServer(event);
  }

  // 检查阈值
  checkThresholds(type) {
    const recentEvents = this.getRecentEvents(type, 3600000); // 1小时内
    const threshold = this.thresholds[type];

    if (threshold && recentEvents.length >= threshold) {
      this.triggerAlert(type, recentEvents.length);
    }
  }

  // 获取最近事件
  getRecentEvents(type, timeWindow) {
    const cutoff = Date.now() - timeWindow;
    return this.events.filter(event =>
      event.type === type && event.timestamp > cutoff
    );
  }

  // 触发警报
  triggerAlert(type, count) {
    console.warn(`Security Alert: ${type} threshold exceeded (${count} events)`);
    // 实际应用中应发送到监控系统
  }

  // 发送到服务器
  async sendToServer(event) {
    try {
      await fetch('/api/security/events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event)
      });
    } catch (error) {
      console.error('Failed to send security event:', error);
    }
  }

  // 获取客户端IP（简化实现）
  getClientIP() {
    // 实际应用中需要服务端配合
    return 'unknown';
  }
```

### 安全开发流程

#### DevSecOps集成

| 阶段 | 安全活动 | 工具 | 自动化程度 |
|------|----------|------|------------|
| **开发** | 安全编码、代码审查 | ESLint Security | 高 |
| **构建** | 依赖扫描、SAST | npm audit, SonarQube | 高 |
| **测试** | 安全测试、DAST | OWASP ZAP | 中 |
| **部署** | 配置检查、监控 | 自定义脚本 | 中 |
| **运维** | 持续监控、应急响应 | 监控平台 | 低 |

## 安全开发最佳实践

<Callout type="success">
安全开发最佳实践涵盖了从代码编写到部署运维的全生命周期，建立系统性的安全保障体系。
</Callout>

### 安全编码规范

#### 输入验证原则

| 验证类型 | 验证方法 | 实施位置 | 安全级别 |
|----------|----------|----------|----------|
| **白名单验证** | 允许已知安全的输入 | 客户端+服务端 | 最高 |
| **黑名单过滤** | 阻止已知危险的输入 | 客户端+服务端 | 中 |
| **格式验证** | 检查数据格式和类型 | 客户端+服务端 | 高 |
| **长度限制** | 限制输入数据长度 | 客户端+服务端 | 中 |
| **编码转换** | 统一字符编码 | 服务端 | 高 |

#### 安全编码检查清单

```javascript
// 安全编码检查工具
class SecureCodingChecker {
  static checkCode(code) {
    const issues = [];

    // 检查危险函数使用
    const dangerousFunctions = [
      'eval', 'Function', 'setTimeout', 'setInterval',
      'innerHTML', 'outerHTML', 'insertAdjacentHTML'
    ];

    dangerousFunctions.forEach(func => {
      const regex = new RegExp(`\\b${func}\\s*\\(`, 'g');
      const matches = code.match(regex);
      if (matches) {
        issues.push({
          type: 'dangerous-function',
          function: func,
          count: matches.length,
          severity: 'high',
          message: `使用了危险函数 ${func}，可能导致代码注入`
        });
      }
    });

    // 检查硬编码敏感信息
    const sensitivePatterns = [
      { name: 'API Key', pattern: /api[_-]?key\s*[:=]\s*['"][^'"]+['"]/gi },
      { name: 'Password', pattern: /password\s*[:=]\s*['"][^'"]+['"]/gi },
      { name: 'Token', pattern: /token\s*[:=]\s*['"][^'"]+['"]/gi },
      { name: 'Secret', pattern: /secret\s*[:=]\s*['"][^'"]+['"]/gi }
    ];

    sensitivePatterns.forEach(pattern => {
      const matches = code.match(pattern.pattern);
      if (matches) {
        issues.push({
          type: 'hardcoded-secret',
          pattern: pattern.name,
          count: matches.length,
          severity: 'critical',
          message: `发现硬编码的${pattern.name}，应使用环境变量`
        });
      }
    });

    // 检查不安全的随机数生成
    if (code.includes('Math.random()')) {
      issues.push({
        type: 'weak-random',
        severity: 'medium',
        message: 'Math.random()不适用于安全场景，应使用crypto.getRandomValues()'
      });
    }

    return {
      totalIssues: issues.length,
      criticalIssues: issues.filter(i => i.severity === 'critical').length,
      highIssues: issues.filter(i => i.severity === 'high').length,
      mediumIssues: issues.filter(i => i.severity === 'medium').length,
      issues
    };
  }

  // 生成安全报告
  static generateReport(checkResult) {
    const { totalIssues, criticalIssues, highIssues, mediumIssues, issues } = checkResult;

    let grade = 'A';
    if (criticalIssues > 0) grade = 'F';
    else if (highIssues > 3) grade = 'D';
    else if (highIssues > 1) grade = 'C';
    else if (highIssues > 0 || mediumIssues > 3) grade = 'B';

    return {
      grade,
      summary: {
        total: totalIssues,
        critical: criticalIssues,
        high: highIssues,
        medium: mediumIssues
      },
      recommendations: this.getRecommendations(issues)
    };
  }

  static getRecommendations(issues) {
    const recommendations = [];

    if (issues.some(i => i.type === 'dangerous-function')) {
      recommendations.push('使用安全的DOM操作方法，如textContent替代innerHTML');
    }

    if (issues.some(i => i.type === 'hardcoded-secret')) {
      recommendations.push('将敏感信息移至环境变量或安全配置文件');
    }

    if (issues.some(i => i.type === 'weak-random')) {
      recommendations.push('使用crypto.getRandomValues()生成安全随机数');
    }

    return recommendations;
  }
}
```

### 依赖安全管理

#### 依赖风险评估

| 风险类型 | 评估指标 | 工具 | 处理策略 |
|----------|----------|------|----------|
| **已知漏洞** | CVE数量、CVSS评分 | npm audit, Snyk | 立即更新 |
| **维护状态** | 最后更新时间、活跃度 | npm outdated | 考虑替换 |
| **许可证风险** | 许可证类型、兼容性 | license-checker | 法务审查 |
| **供应链风险** | 依赖深度、维护者信誉 | 人工审查 | 谨慎选择 |

#### 自动化依赖检查

```javascript
// 依赖安全检查工具
class DependencySecurityChecker {
  constructor() {
    this.vulnerabilityDB = new Map(); // 简化的漏洞数据库
  }

  // 检查package.json中的依赖
  async checkDependencies(packageJson) {
    const dependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };

    const results = [];

    for (const [name, version] of Object.entries(dependencies)) {
      const result = await this.checkSingleDependency(name, version);
      results.push(result);
    }

    return this.generateDependencyReport(results);
  }

  async checkSingleDependency(name, version) {
    // 模拟依赖检查
    const vulnerabilities = await this.getVulnerabilities(name, version);
    const maintenance = await this.getMaintenanceInfo(name);
    const license = await this.getLicenseInfo(name);

    return {
      name,
      version,
      vulnerabilities,
      maintenance,
      license,
      riskScore: this.calculateRiskScore(vulnerabilities, maintenance)
    };
  }

  calculateRiskScore(vulnerabilities, maintenance) {
    let score = 0;

    // 漏洞风险
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'critical': score += 10; break;
        case 'high': score += 7; break;
        case 'medium': score += 4; break;
        case 'low': score += 1; break;
      }
    });

    // 维护风险
    if (maintenance.lastUpdate > 365) score += 5; // 超过1年未更新
    if (maintenance.weeklyDownloads < 1000) score += 3; // 使用量低

    return Math.min(score, 100);
  }

  generateDependencyReport(results) {
    const highRiskDeps = results.filter(r => r.riskScore >= 7);
    const mediumRiskDeps = results.filter(r => r.riskScore >= 4 && r.riskScore < 7);
    const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);

    return {
      summary: {
        totalDependencies: results.length,
        highRisk: highRiskDeps.length,
        mediumRisk: mediumRiskDeps.length,
        totalVulnerabilities: totalVulns
      },
      recommendations: this.generateRecommendations(highRiskDeps),
      details: results
    };
  }

  generateRecommendations(highRiskDeps) {
    const recommendations = [];

    highRiskDeps.forEach(dep => {
      if (dep.vulnerabilities.length > 0) {
        recommendations.push(`更新 ${dep.name} 以修复安全漏洞`);
      }
      if (dep.maintenance.lastUpdate > 365) {
        recommendations.push(`考虑替换长期未维护的依赖 ${dep.name}`);
      }
    });

    return recommendations;
  }

  // 模拟方法
  async getVulnerabilities(name, version) {
    // 实际应用中应查询真实的漏洞数据库
    return [];
  }

  async getMaintenanceInfo(name) {
    // 实际应用中应查询npm registry
    return {
      lastUpdate: Math.floor(Math.random() * 1000),
      weeklyDownloads: Math.floor(Math.random() * 100000)
    };
  }

  async getLicenseInfo(name) {
    // 实际应用中应查询包的许可证信息
    return { license: 'MIT', compatible: true };
  }
}
```

### 安全测试策略

#### 测试类型与覆盖范围

| 测试类型 | 测试内容 | 工具 | 执行频率 |
|----------|----------|------|----------|
| **单元测试** | 输入验证、边界条件 | Jest, Mocha | 每次提交 |
| **集成测试** | API安全、认证流程 | Cypress, Playwright | 每日构建 |
| **安全扫描** | 静态代码分析 | ESLint Security, SonarQube | 每次提交 |
| **渗透测试** | 模拟攻击场景 | OWASP ZAP, Burp Suite | 每月 |

#### 安全测试自动化

```javascript
// 安全测试套件
class SecurityTestSuite {
  constructor() {
    this.testResults = [];
  }

  // XSS防护测试
  testXSSProtection() {
    const testCases = [
      '<script>alert("xss")</script>',
      'javascript:alert("xss")',
      '<img src="x" onerror="alert(\'xss\')">',
      '"><script>alert("xss")</script>',
      '\';alert("xss");//'
    ];

    const results = testCases.map(payload => {
      try {
        // 测试输入过滤
        const filtered = this.filterXSS(payload);
        const isBlocked = !filtered.includes('<script>') &&
                         !filtered.includes('javascript:') &&
                         !filtered.includes('onerror=');

        return {
          payload,
          filtered,
          blocked: isBlocked,
          passed: isBlocked
        };
      } catch (error) {
        return {
          payload,
          error: error.message,
          passed: false
        };
      }
    });

    this.testResults.push({
      test: 'XSS Protection',
      results,
      passed: results.every(r => r.passed)
    });

    return results;
  }

  // CSRF防护测试
  testCSRFProtection() {
    const testCases = [
      { method: 'POST', hasToken: false, expected: false },
      { method: 'POST', hasToken: true, validToken: false, expected: false },
      { method: 'POST', hasToken: true, validToken: true, expected: true },
      { method: 'GET', hasToken: false, expected: true } // GET请求通常不需要CSRF token
    ];

    const results = testCases.map(testCase => {
      const passed = this.validateCSRFToken(testCase) === testCase.expected;
      return { ...testCase, passed };
    });

    this.testResults.push({
      test: 'CSRF Protection',
      results,
      passed: results.every(r => r.passed)
    });

    return results;
  }

  // 输入验证测试
  testInputValidation() {
    const testCases = [
      { input: 'normal@email.com', type: 'email', expected: true },
      { input: 'invalid-email', type: 'email', expected: false },
      { input: '12345', type: 'number', expected: true },
      { input: 'abc', type: 'number', expected: false },
      { input: 'a'.repeat(1000), type: 'text', maxLength: 100, expected: false }
    ];

    const results = testCases.map(testCase => {
      const isValid = this.validateInput(testCase.input, testCase.type, testCase);
      return {
        ...testCase,
        valid: isValid,
        passed: isValid === testCase.expected
      };
    });

    this.testResults.push({
      test: 'Input Validation',
      results,
      passed: results.every(r => r.passed)
    });

    return results;
  }

  // 生成测试报告
  generateReport() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(t => t.passed).length;
    const failedTests = totalTests - passedTests;

    return {
      summary: {
        total: totalTests,
        passed: passedTests,
        failed: failedTests,
        passRate: totalTests > 0 ? (passedTests / totalTests * 100).toFixed(2) : 0
      },
      details: this.testResults,
      recommendations: this.generateTestRecommendations()
    };
  }

  generateTestRecommendations() {
    const recommendations = [];

    this.testResults.forEach(test => {
      if (!test.passed) {
        switch (test.test) {
          case 'XSS Protection':
            recommendations.push('加强XSS防护，检查输入过滤和输出编码');
            break;
          case 'CSRF Protection':
            recommendations.push('实施CSRF Token验证或SameSite Cookie');
            break;
          case 'Input Validation':
            recommendations.push('完善输入验证规则，确保数据格式和长度限制');
            break;
        }
      }
    });

    return recommendations;
  }

  // 辅助方法（简化实现）
  filterXSS(input) {
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }

  validateCSRFToken(testCase) {
    if (testCase.method === 'GET') return true;
    if (!testCase.hasToken) return false;
    return testCase.validToken === true;
  }

  validateInput(input, type, options = {}) {
    switch (type) {
      case 'email':
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input);
      case 'number':
        return !isNaN(input) && !isNaN(parseFloat(input));
      case 'text':
        return options.maxLength ? input.length <= options.maxLength : true;
      default:
        return true;
    }
  }
}
```

---

<Callout type="success">
前端安全是一个持续的过程，需要在开发的每个阶段都考虑安全因素，建立完善的安全防护体系。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [OWASP Top 10](https://owasp.org/www-project-top-ten/) - Web应用安全风险
- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security) - Web安全指南
- [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) - CSP文档
- [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) - Web加密API

### 🎓 优质教程
- [Frontend Security](https://frontendmasters.com/courses/web-security/) - Frontend Masters安全课程
- [XSS Prevention](https://excess-xss.com/) - XSS防护指南
- [CSRF Protection](https://portswigger.net/web-security/csrf) - CSRF防护教程

### 🛠️ 实践项目
- [OWASP WebGoat](https://owasp.org/www-project-webgoat/) - Web安全学习平台
- [DVWA](http://www.dvwa.co.uk/) - 故意存在漏洞的Web应用
- [OWASP ZAP](https://www.zaproxy.org/) - Web应用安全测试工具
- [Security Checklist](https://github.com/FallibleInc/security-guide-for-developers) - 开发者安全指南

### 🔧 开发工具
- [ESLint Security](https://github.com/nodesecurity/eslint-plugin-security) - ESLint安全插件
- [Snyk](https://snyk.io/) - 依赖安全扫描
- [npm audit](https://docs.npmjs.com/cli/v8/commands/npm-audit) - npm安全审计
- [Helmet.js](https://helmetjs.github.io/) - Express安全中间件

### 📝 深入阅读
- [Frontend Security Best Practices](https://blog.logrocket.com/frontend-security-best-practices/) - 前端安全最佳实践
- [XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) - XSS防护备忘单
- [CSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) - CSRF防护指南

<Callout type="tip">
💡 **学习建议**：建议从OWASP Top 10开始了解常见安全威胁，学习XSS和CSRF防护技术，然后掌握CSP配置，最后建立完整的安全开发流程。
</Callout>

---

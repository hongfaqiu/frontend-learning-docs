import { Callout } from 'nextra/components'

# 19. AIæ—¶ä»£çš„å‰ç«¯å¼€å‘

## ğŸ“‹ ç›®å½•

- [AIåœ¨å‰ç«¯å¼€å‘ä¸­çš„åº”ç”¨](#aiåœ¨å‰ç«¯å¼€å‘ä¸­çš„åº”ç”¨)
- [AIè¾…åŠ©å¼€å‘å·¥å…·](#aiè¾…åŠ©å¼€å‘å·¥å…·)
- [æ™ºèƒ½åŒ–ç”¨æˆ·ç•Œé¢](#æ™ºèƒ½åŒ–ç”¨æˆ·ç•Œé¢)
- [å‰ç«¯AIé›†æˆå®è·µ](#å‰ç«¯aié›†æˆå®è·µ)
- [AIé©±åŠ¨çš„æ€§èƒ½ä¼˜åŒ–](#aié©±åŠ¨çš„æ€§èƒ½ä¼˜åŒ–)
- [æœªæ¥å‘å±•è¶‹åŠ¿](#æœªæ¥å‘å±•è¶‹åŠ¿)

## ğŸ¤– AIåœ¨å‰ç«¯å¼€å‘ä¸­çš„åº”ç”¨

<Callout type="info">
AIæ­£åœ¨æ·±åˆ»æ”¹å˜å‰ç«¯å¼€å‘çš„æ–¹å¼ï¼Œä»ä»£ç ç”Ÿæˆåˆ°ç”¨æˆ·ä½“éªŒä¼˜åŒ–ï¼ŒAIæŠ€æœ¯ä¸ºå‰ç«¯å¼€å‘å¸¦æ¥äº†å‰æ‰€æœªæœ‰çš„å¯èƒ½æ€§ã€‚
</Callout>

### AIåº”ç”¨åœºæ™¯æ¦‚è§ˆ

```javascript
// AIåœ¨å‰ç«¯å¼€å‘ä¸­çš„åº”ç”¨åœºæ™¯
const aiApplications = {
  // 1. ä»£ç ç”Ÿæˆå’Œè¾…åŠ©
  codeGeneration: {
    tools: ['GitHub Copilot', 'Tabnine', 'CodeT5', 'ChatGPT'],
    capabilities: [
      'è‡ªåŠ¨ä»£ç è¡¥å…¨',
      'å‡½æ•°ç”Ÿæˆ',
      'æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ',
      'ä»£ç é‡æ„å»ºè®®',
      'æ–‡æ¡£ç”Ÿæˆ'
    ],
    benefits: [
      'æé«˜å¼€å‘æ•ˆç‡',
      'å‡å°‘é‡å¤å·¥ä½œ',
      'å­¦ä¹ æœ€ä½³å®è·µ',
      'å¿«é€ŸåŸå‹å¼€å‘'
    ],
    example: `
      // AIè¾…åŠ©ç”Ÿæˆçš„Reactç»„ä»¶
      // Prompt: "Create a responsive card component with image, title, and description"
      
      const Card = ({ image, title, description, onClick }) => {
        return (
          <div className="card" onClick={onClick}>
            <img src={image} alt={title} className="card-image" />
            <div className="card-content">
              <h3 className="card-title">{title}</h3>
              <p className="card-description">{description}</p>
            </div>
          </div>
        );
      };
    `
  },
  
  // 2. è®¾è®¡åˆ°ä»£ç è½¬æ¢
  designToCode: {
    tools: ['Figma to Code', 'Sketch2Code', 'Uizard', 'Locofy'],
    capabilities: [
      'è®¾è®¡ç¨¿è¯†åˆ«',
      'å¸ƒå±€ç”Ÿæˆ',
      'æ ·å¼æå–',
      'ç»„ä»¶è¯†åˆ«',
      'å“åº”å¼é€‚é…'
    ],
    workflow: [
      'ä¸Šä¼ è®¾è®¡ç¨¿',
      'AIåˆ†æå¸ƒå±€',
      'ç”ŸæˆHTML/CSS',
      'ä¼˜åŒ–ä»£ç ç»“æ„',
      'æ‰‹åŠ¨è°ƒæ•´å®Œå–„'
    ]
  },
  
  // 3. æ™ºèƒ½æµ‹è¯•
  intelligentTesting: {
    tools: ['Testim', 'Applitools', 'Mabl', 'Functionize'],
    capabilities: [
      'è‡ªåŠ¨åŒ–æµ‹è¯•ç”Ÿæˆ',
      'è§†è§‰å›å½’æµ‹è¯•',
      'æ™ºèƒ½å…ƒç´ å®šä½',
      'æµ‹è¯•ç”¨ä¾‹ä¼˜åŒ–',
      'ç¼ºé™·é¢„æµ‹'
    ],
    types: [
      'å•å…ƒæµ‹è¯•ç”Ÿæˆ',
      'E2Eæµ‹è¯•è‡ªåŠ¨åŒ–',
      'æ€§èƒ½æµ‹è¯•ä¼˜åŒ–',
      'å¯è®¿é—®æ€§æµ‹è¯•'
    ]
  },
  
  // 4. ç”¨æˆ·ä½“éªŒä¼˜åŒ–
  uxOptimization: {
    applications: [
      'ä¸ªæ€§åŒ–æ¨è',
      'æ™ºèƒ½æœç´¢',
      'è‡ªé€‚åº”ç•Œé¢',
      'é¢„æµ‹æ€§åŠ è½½',
      'æƒ…æ„Ÿåˆ†æ'
    ],
    techniques: [
      'æœºå™¨å­¦ä¹ ç®—æ³•',
      'è‡ªç„¶è¯­è¨€å¤„ç†',
      'è®¡ç®—æœºè§†è§‰',
      'æ¨èç³»ç»Ÿ',
      'è¡Œä¸ºåˆ†æ'
    ]
  }
};

// AIå¼€å‘åŠ©æ‰‹ç±»
class AIDevAssistant {
  constructor() {
    this.apiKey = process.env.OPENAI_API_KEY;
    this.model = 'gpt-4';
    this.context = [];
  }
  
  // ä»£ç ç”Ÿæˆ
  async generateCode(prompt, language = 'javascript') {
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: 'system',
              content: `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„${language}å¼€å‘è€…ï¼Œè¯·ç”Ÿæˆé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„ä»£ç ã€‚`
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          max_tokens: 1000
        })
      });
      
      const data = await response.json();
      return data.choices[0].message.content;
    } catch (error) {
      console.error('AIä»£ç ç”Ÿæˆå¤±è´¥:', error);
      return null;
    }
  }
  
  // ä»£ç å®¡æŸ¥
  async reviewCode(code) {
    const prompt = `
      è¯·å®¡æŸ¥ä»¥ä¸‹ä»£ç ï¼Œæä¾›æ”¹è¿›å»ºè®®ï¼š
      
      \`\`\`javascript
      ${code}
      \`\`\`
      
      è¯·ä»ä»¥ä¸‹æ–¹é¢è¿›è¡Œè¯„ä¼°ï¼š
      1. ä»£ç è´¨é‡å’Œå¯è¯»æ€§
      2. æ€§èƒ½ä¼˜åŒ–å»ºè®®
      3. å®‰å…¨æ€§é—®é¢˜
      4. æœ€ä½³å®è·µéµå¾ª
      5. æ½œåœ¨çš„bug
    `;
    
    return await this.generateCode(prompt);
  }
  
  // ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
  async generateTests(functionCode, testFramework = 'jest') {
    const prompt = `
      ä¸ºä»¥ä¸‹å‡½æ•°ç”Ÿæˆ${testFramework}æµ‹è¯•ç”¨ä¾‹ï¼š
      
      \`\`\`javascript
      ${functionCode}
      \`\`\`
      
      è¯·åŒ…æ‹¬ï¼š
      1. æ­£å¸¸æƒ…å†µæµ‹è¯•
      2. è¾¹ç•Œæ¡ä»¶æµ‹è¯•
      3. é”™è¯¯æƒ…å†µæµ‹è¯•
      4. æ€§èƒ½æµ‹è¯•ï¼ˆå¦‚é€‚ç”¨ï¼‰
    `;
    
    return await this.generateCode(prompt);
  }
  
  // ä»£ç é‡æ„å»ºè®®
  async suggestRefactoring(code) {
    const prompt = `
      è¯·ä¸ºä»¥ä¸‹ä»£ç æä¾›é‡æ„å»ºè®®ï¼Œä½¿å…¶æ›´åŠ æ¸…æ™°ã€é«˜æ•ˆå’Œå¯ç»´æŠ¤ï¼š
      
      \`\`\`javascript
      ${code}
      \`\`\`
      
      è¯·æä¾›ï¼š
      1. é‡æ„åçš„ä»£ç 
      2. é‡æ„ç†ç”±
      3. æ€§èƒ½å½±å“åˆ†æ
    `;
    
    return await this.generateCode(prompt);
  }
  
  // æ–‡æ¡£ç”Ÿæˆ
  async generateDocumentation(code) {
    const prompt = `
      ä¸ºä»¥ä¸‹ä»£ç ç”Ÿæˆè¯¦ç»†çš„JSDocæ–‡æ¡£ï¼š
      
      \`\`\`javascript
      ${code}
      \`\`\`
      
      è¯·åŒ…æ‹¬ï¼š
      1. å‡½æ•°/ç±»æè¿°
      2. å‚æ•°è¯´æ˜
      3. è¿”å›å€¼è¯´æ˜
      4. ä½¿ç”¨ç¤ºä¾‹
      5. æ³¨æ„äº‹é¡¹
    `;
    
    return await this.generateCode(prompt);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const aiAssistant = new AIDevAssistant();

// ç”ŸæˆReactç»„ä»¶
const componentPrompt = `
  åˆ›å»ºä¸€ä¸ªå¯å¤ç”¨çš„Modalç»„ä»¶ï¼Œæ”¯æŒï¼š
  - è‡ªå®šä¹‰æ ‡é¢˜å’Œå†…å®¹
  - å¯æ§åˆ¶çš„æ˜¾ç¤º/éšè—
  - ç‚¹å‡»é®ç½©å±‚å…³é—­
  - é”®ç›˜ESCå…³é—­
  - åŠ¨ç”»æ•ˆæœ
  - å¯è®¿é—®æ€§æ”¯æŒ
`;

aiAssistant.generateCode(componentPrompt, 'react').then(code => {
  console.log('ç”Ÿæˆçš„ç»„ä»¶ä»£ç :', code);
});
```

## ğŸ› ï¸ AIè¾…åŠ©å¼€å‘å·¥å…·

### æ™ºèƒ½ä»£ç ç¼–è¾‘å™¨é›†æˆ

```javascript
// 1. AIä»£ç è¡¥å…¨ç³»ç»Ÿ
class IntelligentCodeCompletion {
  constructor() {
    this.model = null;
    this.context = [];
    this.suggestions = [];
    this.setupEventListeners();
  }
  
  async initialize() {
    // åˆå§‹åŒ–æœ¬åœ°AIæ¨¡å‹ï¼ˆå¦‚ä½¿ç”¨TensorFlow.jsï¼‰
    try {
      this.model = await tf.loadLayersModel('/models/code-completion/model.json');
      console.log('AIä»£ç è¡¥å…¨æ¨¡å‹åŠ è½½æˆåŠŸ');
    } catch (error) {
      console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error);
      // å›é€€åˆ°APIè°ƒç”¨
      this.useAPIFallback = true;
    }
  }
  
  setupEventListeners() {
    // ç›‘å¬ç¼–è¾‘å™¨è¾“å…¥
    document.addEventListener('input', (event) => {
      if (event.target.matches('.code-editor')) {
        this.handleCodeInput(event);
      }
    });
    
    // ç›‘å¬å¿«æ·é”®
    document.addEventListener('keydown', (event) => {
      if (event.ctrlKey && event.key === ' ') {
        event.preventDefault();
        this.triggerCompletion();
      }
    });
  }
  
  async handleCodeInput(event) {
    const editor = event.target;
    const code = editor.value;
    const cursorPosition = editor.selectionStart;
    
    // è·å–å½“å‰ä¸Šä¸‹æ–‡
    const context = this.extractContext(code, cursorPosition);
    
    // é˜²æŠ–å¤„ç†
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      this.generateSuggestions(context);
    }, 300);
  }
  
  extractContext(code, position) {
    const lines = code.split('\n');
    const currentLineIndex = code.substring(0, position).split('\n').length - 1;
    const currentLine = lines[currentLineIndex];
    const currentColumn = position - code.lastIndexOf('\n', position - 1) - 1;
    
    return {
      code,
      currentLine,
      currentColumn,
      previousLines: lines.slice(Math.max(0, currentLineIndex - 5), currentLineIndex),
      nextLines: lines.slice(currentLineIndex + 1, currentLineIndex + 3),
      language: this.detectLanguage(code),
      imports: this.extractImports(code),
      functions: this.extractFunctions(code)
    };
  }
  
  async generateSuggestions(context) {
    try {
      let suggestions;
      
      if (this.model && !this.useAPIFallback) {
        suggestions = await this.generateLocalSuggestions(context);
      } else {
        suggestions = await this.generateAPISuggestions(context);
      }
      
      this.displaySuggestions(suggestions);
    } catch (error) {
      console.error('ç”Ÿæˆå»ºè®®å¤±è´¥:', error);
    }
  }
  
  async generateLocalSuggestions(context) {
    // ä½¿ç”¨æœ¬åœ°æ¨¡å‹ç”Ÿæˆå»ºè®®
    const input = this.preprocessContext(context);
    const prediction = this.model.predict(input);
    return this.postprocessPrediction(prediction);
  }
  
  async generateAPISuggestions(context) {
    // ä½¿ç”¨APIç”Ÿæˆå»ºè®®
    const response = await fetch('/api/ai/code-completion', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ context })
    });
    
    const data = await response.json();
    return data.suggestions;
  }
  
  displaySuggestions(suggestions) {
    // æ˜¾ç¤ºå»ºè®®åˆ—è¡¨
    const suggestionList = document.getElementById('suggestion-list');
    suggestionList.innerHTML = '';
    
    suggestions.forEach((suggestion, index) => {
      const item = document.createElement('div');
      item.className = 'suggestion-item';
      item.innerHTML = `
        <div class="suggestion-code">${this.highlightCode(suggestion.code)}</div>
        <div class="suggestion-description">${suggestion.description}</div>
        <div class="suggestion-confidence">${Math.round(suggestion.confidence * 100)}%</div>
      `;
      
      item.addEventListener('click', () => {
        this.applySuggestion(suggestion);
      });
      
      suggestionList.appendChild(item);
    });
    
    this.showSuggestionPanel();
  }
  
  applySuggestion(suggestion) {
    const editor = document.querySelector('.code-editor');
    const cursorPosition = editor.selectionStart;
    const code = editor.value;
    
    const newCode = code.substring(0, cursorPosition) + 
                   suggestion.code + 
                   code.substring(cursorPosition);
    
    editor.value = newCode;
    editor.selectionStart = editor.selectionEnd = cursorPosition + suggestion.code.length;
    
    this.hideSuggestionPanel();
    
    // è®°å½•ä½¿ç”¨æƒ…å†µç”¨äºæ¨¡å‹æ”¹è¿›
    this.recordUsage(suggestion);
  }
  
  detectLanguage(code) {
    // ç®€å•çš„è¯­è¨€æ£€æµ‹
    if (code.includes('import React') || code.includes('jsx')) return 'javascript';
    if (code.includes('def ') || code.includes('import ')) return 'python';
    if (code.includes('function') || code.includes('const ')) return 'javascript';
    return 'javascript'; // é»˜è®¤
  }
  
  extractImports(code) {
    const importRegex = /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g;
    const imports = [];
    let match;
    
    while ((match = importRegex.exec(code)) !== null) {
      imports.push(match[1]);
    }
    
    return imports;
  }
  
  extractFunctions(code) {
    const functionRegex = /function\s+(\w+)|const\s+(\w+)\s*=|(\w+)\s*:/g;
    const functions = [];
    let match;
    
    while ((match = functionRegex.exec(code)) !== null) {
      functions.push(match[1] || match[2] || match[3]);
    }
    
    return functions;
  }
}

// 2. AIé©±åŠ¨çš„é”™è¯¯æ£€æµ‹å’Œä¿®å¤
class AIErrorDetector {
  constructor() {
    this.errorPatterns = new Map();
    this.fixSuggestions = new Map();
    this.setupErrorMonitoring();
  }
  
  setupErrorMonitoring() {
    // ç›‘å¬è¯­æ³•é”™è¯¯
    window.addEventListener('error', (event) => {
      this.analyzeError(event.error);
    });
    
    // ç›‘å¬Promiseæ‹’ç»
    window.addEventListener('unhandledrejection', (event) => {
      this.analyzeError(event.reason);
    });
    
    // ç›‘å¬ç¼–è¯‘é”™è¯¯ï¼ˆå¦‚æœæœ‰æ„å»ºå·¥å…·é›†æˆï¼‰
    if (window.webpackHotUpdate) {
      this.monitorBuildErrors();
    }
  }
  
  async analyzeError(error) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      type: error.constructor.name,
      timestamp: Date.now()
    };
    
    // ä½¿ç”¨AIåˆ†æé”™è¯¯
    const analysis = await this.getErrorAnalysis(errorInfo);
    
    if (analysis.fixSuggestion) {
      this.showFixSuggestion(errorInfo, analysis);
    }
  }
  
  async getErrorAnalysis(errorInfo) {
    try {
      const response = await fetch('/api/ai/error-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorInfo)
      });
      
      return await response.json();
    } catch (error) {
      console.error('é”™è¯¯åˆ†æå¤±è´¥:', error);
      return { fixSuggestion: null };
    }
  }
  
  showFixSuggestion(errorInfo, analysis) {
    const notification = document.createElement('div');
    notification.className = 'ai-fix-suggestion';
    notification.innerHTML = `
      <div class="error-summary">
        <h4>ğŸ¤– AIæ£€æµ‹åˆ°é”™è¯¯</h4>
        <p>${errorInfo.message}</p>
      </div>
      <div class="fix-suggestion">
        <h5>å»ºè®®ä¿®å¤:</h5>
        <pre><code>${analysis.fixSuggestion.code}</code></pre>
        <p>${analysis.fixSuggestion.explanation}</p>
      </div>
      <div class="actions">
        <button onclick="this.parentElement.parentElement.remove()">å¿½ç•¥</button>
        <button onclick="applyFix('${analysis.fixSuggestion.code}')">åº”ç”¨ä¿®å¤</button>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    // 5ç§’åè‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
      if (notification.parentElement) {
        notification.remove();
      }
    }, 5000);
  }
}

// 3. æ™ºèƒ½é‡æ„åŠ©æ‰‹
class AIRefactoringAssistant {
  constructor() {
    this.refactoringRules = new Map();
    this.codeMetrics = new Map();
  }
  
  async analyzeCode(code) {
    const metrics = {
      complexity: this.calculateComplexity(code),
      duplications: this.findDuplications(code),
      codeSmells: this.detectCodeSmells(code),
      testCoverage: await this.getTestCoverage(code)
    };
    
    return metrics;
  }
  
  async suggestRefactoring(code) {
    const analysis = await this.analyzeCode(code);
    const suggestions = [];
    
    // åŸºäºå¤æ‚åº¦å»ºè®®
    if (analysis.complexity > 10) {
      suggestions.push({
        type: 'complexity',
        priority: 'high',
        description: 'å‡½æ•°å¤æ‚åº¦è¿‡é«˜ï¼Œå»ºè®®æ‹†åˆ†',
        refactoring: await this.generateComplexityRefactoring(code)
      });
    }
    
    // åŸºäºé‡å¤ä»£ç å»ºè®®
    if (analysis.duplications.length > 0) {
      suggestions.push({
        type: 'duplication',
        priority: 'medium',
        description: 'å‘ç°é‡å¤ä»£ç ï¼Œå»ºè®®æå–å…¬å…±å‡½æ•°',
        refactoring: await this.generateDuplicationRefactoring(code, analysis.duplications)
      });
    }
    
    return suggestions;
  }
  
  calculateComplexity(code) {
    // ç®€åŒ–çš„åœˆå¤æ‚åº¦è®¡ç®—
    const complexityKeywords = ['if', 'else', 'while', 'for', 'switch', 'case', 'catch'];
    let complexity = 1;
    
    complexityKeywords.forEach(keyword => {
      const regex = new RegExp(`\\b${keyword}\\b`, 'g');
      const matches = code.match(regex);
      if (matches) {
        complexity += matches.length;
      }
    });
    
    return complexity;
  }
  
  findDuplications(code) {
    // ç®€åŒ–çš„é‡å¤ä»£ç æ£€æµ‹
    const lines = code.split('\n').filter(line => line.trim().length > 0);
    const duplications = [];
    
    for (let i = 0; i < lines.length - 2; i++) {
      for (let j = i + 3; j < lines.length; j++) {
        const block1 = lines.slice(i, i + 3).join('\n');
        const block2 = lines.slice(j, j + 3).join('\n');
        
        if (block1 === block2) {
          duplications.push({
            lines: [i + 1, j + 1],
            code: block1
          });
        }
      }
    }
    
    return duplications;
  }
  
  detectCodeSmells(code) {
    const smells = [];
    
    // æ£€æµ‹é•¿å‡½æ•°
    const functions = code.match(/function\s+\w+[^}]+}/g) || [];
    functions.forEach(func => {
      if (func.split('\n').length > 50) {
        smells.push({
          type: 'long-function',
          description: 'å‡½æ•°è¿‡é•¿ï¼Œå»ºè®®æ‹†åˆ†'
        });
      }
    });
    
    // æ£€æµ‹é­”æ³•æ•°å­—
    const magicNumbers = code.match(/\b\d{2,}\b/g) || [];
    if (magicNumbers.length > 0) {
      smells.push({
        type: 'magic-numbers',
        description: 'å‘ç°é­”æ³•æ•°å­—ï¼Œå»ºè®®ä½¿ç”¨å¸¸é‡'
      });
    }
    
    return smells;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const codeCompletion = new IntelligentCodeCompletion();
const errorDetector = new AIErrorDetector();
const refactoringAssistant = new AIRefactoringAssistant();

// åˆå§‹åŒ–AIè¾…åŠ©å·¥å…·
codeCompletion.initialize();

// åˆ†æä»£ç å¹¶æä¾›é‡æ„å»ºè®®
const sampleCode = `
function processUserData(users) {
  let result = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].age > 18) {
      if (users[i].status === 'active') {
        if (users[i].email && users[i].email.includes('@')) {
          result.push({
            id: users[i].id,
            name: users[i].name,
            email: users[i].email
          });
        }
      }
    }
  }
  return result;
}
`;

refactoringAssistant.suggestRefactoring(sampleCode).then(suggestions => {
  console.log('é‡æ„å»ºè®®:', suggestions);
});
```

---

<Callout type="success">
AIæ­£åœ¨é‡å¡‘å‰ç«¯å¼€å‘çš„æœªæ¥ï¼Œä»æé«˜å¼€å‘æ•ˆç‡åˆ°åˆ›é€ å…¨æ–°çš„ç”¨æˆ·ä½“éªŒã€‚æ‹¥æŠ±AIæŠ€æœ¯ï¼Œå°†è®©æˆ‘ä»¬æˆä¸ºæ›´é«˜æ•ˆã€æ›´åˆ›æ–°çš„å‰ç«¯å¼€å‘è€…ã€‚
</Callout>

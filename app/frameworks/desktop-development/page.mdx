import { Callout } from 'nextra/components'

# 13. 桌面应用开发

## 📋 目录

- [桌面应用开发概览](#桌面应用开发概览)
- [Electron核心开发](#electron核心开发)
- [Tauri现代化方案](#tauri现代化方案)
- [安全性和最佳实践](#安全性和最佳实践)
- [打包和分发](#打包和分发)

## 桌面应用开发概览

<Callout type="info">
桌面应用开发让[Web](https://developer.mozilla.org/en-US/docs/Web)技术能够创建原生桌面应用，为前端开发者提供了更广阔的应用场景。
</Callout>

### 桌面应用技术栈对比

| 技术 | 技术栈 | 应用体积 | 内存占用 | 性能 | 学习成本 | 适用场景 |
|------|--------|----------|----------|------|----------|----------|
| **Electron** | Chromium + Node.js | 大(~100MB+) | 高 | 中等 | 低 | 复杂桌面应用 |
| **Tauri** | Rust + WebView | 小(~10MB) | 低 | 高 | 中等 | 轻量级高性能应用 |
| **Flutter** | Flutter + Dart | 中等(~30MB) | 中等 | 高 | 高 | 跨平台UI一致性 |
| **.NET MAUI** | .NET + C# | 中等(~50MB) | 中等 | 高 | 中等 | 企业级Windows应用 |

### 知名应用案例

| 技术 | 知名应用 | 特点 |
|------|----------|------|
| **Electron** | VS Code, Discord, Slack, WhatsApp | 成熟生态，功能丰富 |
| **Tauri** | Clash Verge, Pake | 轻量高效，安全性好 |
| **Flutter** | Ubuntu Desktop Installer | 跨平台UI一致 |
| **.NET MAUI** | Microsoft Store | 企业级应用 |

### 技术选择指南

| 项目特征 | 推荐技术 | 理由 |
|----------|----------|------|
| **Web团队 + 复杂功能** | Electron | 生态成熟，开发效率高 |
| **性能敏感 + 小体积** | Tauri | 高性能，资源占用少 |
| **跨平台UI一致性** | Flutter Desktop | 统一的UI框架 |
| **企业级Windows应用** | .NET MAUI | 微软生态支持 |

### 快速决策流程

```javascript
// 技术选择决策
function chooseDesktopTechnology(requirements) {
  const { teamSkills, performance, appSize, complexity } = requirements;

  // Web技术栈 + 性能要求高
  if (teamSkills === 'web' && performance === 'high' && appSize === 'small') {
    return 'Tauri';
  }

  // Web技术栈 + 复杂应用
  if (teamSkills === 'web' && complexity === 'high') {
    return 'Electron';
  }

  // 跨平台UI一致性
  if (requirements.uiConsistency === 'critical') {
    return 'Flutter Desktop';
  }

  // 企业级Windows应用
  if (requirements.platform === 'windows' && requirements.enterprise === true) {
    return '.NET MAUI';
  }

  return 'Electron'; // 默认推荐
}
```

## Electron核心开发

### Electron核心架构

```javascript
// 1. 主进程 (main.js)
const { app, BrowserWindow, ipcMain } = require('electron');
const path = require('path');

class ElectronApp {
  constructor() {
    this.mainWindow = null;
    this.setupApp();
  }

  setupApp() {
    app.whenReady().then(() => {
      this.createMainWindow();
      this.setupIPC();
    });

    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });
  }

  createMainWindow() {
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      webPreferences: {
        nodeIntegration: false, // 安全考虑
        contextIsolation: true, // 启用上下文隔离
        preload: path.join(__dirname, 'preload.js')
      }
    });

    // 加载应用
    const isDev = process.env.NODE_ENV === 'development';
    if (isDev) {
      this.mainWindow.loadURL('http://localhost:3000');
    } else {
      this.mainWindow.loadFile(path.join(__dirname, '../build/index.html'));
    }
  }

  setupIPC() {
    // 文件操作
    ipcMain.handle('read-file', async (event, filePath) => {
      try {
        const fs = require('fs').promises;
        const content = await fs.readFile(filePath, 'utf8');
        return { success: true, content };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    ipcMain.handle('write-file', async (event, filePath, content) => {
      try {
        const fs = require('fs').promises;
        await fs.writeFile(filePath, content, 'utf8');
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    // 窗口控制
    ipcMain.handle('window-minimize', () => {
      this.mainWindow.minimize();
    });

    ipcMain.handle('window-close', () => {
      this.mainWindow.close();
    });
  }
}

// 启动应用
new ElectronApp();

// 2. 预加载脚本 (preload.js)
const { contextBridge, ipcRenderer } = require('electron');

// 暴露安全的API到渲染进程
contextBridge.exposeInMainWorld('electronAPI', {
  // 文件操作
  readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
  writeFile: (filePath, content) => ipcRenderer.invoke('write-file', filePath, content),

  // 窗口控制
  minimizeWindow: () => ipcRenderer.invoke('window-minimize'),
  closeWindow: () => ipcRenderer.invoke('window-close')
});

// 3. 渲染进程 (React组件)
import React, { useState } from 'react';

function App() {
  const [fileContent, setFileContent] = useState('');

  const handleSaveFile = async () => {
    const filePath = '/path/to/file.txt';
    const result = await window.electronAPI.writeFile(filePath, fileContent);

    if (result.success) {
      alert('文件保存成功');
    } else {
      alert(`保存文件失败: ${result.error}`);
    }
  };

  return (
    <div className="app">
      <header className="title-bar">
        <div className="title">我的Electron应用</div>
        <div className="window-controls">
          <button onClick={() => window.electronAPI.minimizeWindow()}>−</button>
          <button onClick={() => window.electronAPI.closeWindow()}>×</button>
        </div>
      </header>

      <main className="content">
        <textarea
          value={fileContent}
          onChange={(e) => setFileContent(e.target.value)}
          placeholder="在这里输入内容..."
        />
        <button onClick={handleSaveFile}>保存文件</button>
      </main>
    </div>
  );
}

export default App;
```

## Tauri现代化方案

<Callout type="info">
[Tauri](https://tauri.app/)是使用Rust构建的现代桌面应用框架，提供更小的包体积和更好的性能。
</Callout>

### Tauri核心结构

```rust
// src-tauri/src/main.rs
use tauri::Manager;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize)]
struct SystemInfo {
    os: String,
    arch: String,
    version: String,
}

// 命令函数
#[tauri::command]
async fn get_system_info() -> Result<SystemInfo, String> {
    let info = SystemInfo {
        os: std::env::consts::OS.to_string(),
        arch: std::env::consts::ARCH.to_string(),
        version: "1.0.0".to_string(),
    };
    Ok(info)
}

#[tauri::command]
async fn save_file(path: String, content: String) -> Result<(), String> {
    std::fs::write(&path, content)
        .map_err(|e| format!("Failed to save file: {}", e))?;
    Ok(())
}

#[tauri::command]
async fn read_file(path: String) -> Result<String, String> {
    std::fs::read_to_string(&path)
        .map_err(|e| format!("Failed to read file: {}", e))
}

fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            get_system_info,
            save_file,
            read_file
        ])
        .setup(|app| {
            let window = app.get_window("main").unwrap();
            window.set_title("Tauri App").unwrap();
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 前端集成

```typescript
// src/lib/tauri.ts
import { invoke } from '@tauri-apps/api/tauri';
import { appWindow } from '@tauri-apps/api/window';

export interface SystemInfo {
  os: string;
  arch: string;
  version: string;
}

export class TauriAPI {
  // 系统信息
  static async getSystemInfo(): Promise<SystemInfo> {
    return await invoke('get_system_info');
  }

  // 文件操作
  static async saveFile(path: string, content: string): Promise<void> {
    return await invoke('save_file', { path, content });
  }

  static async readFile(path: string): Promise<string> {
    return await invoke('read_file', { path });
  }

  // 窗口操作
  static async minimizeWindow(): Promise<void> {
    return await appWindow.minimize();
  }

  static async closeWindow(): Promise<void> {
    return await appWindow.close();
  }
}

// React Hook
import { useState, useEffect } from 'react';

export function useTauriAPI() {
  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);

  useEffect(() => {
    TauriAPI.getSystemInfo().then(setSystemInfo);
  }, []);

  const saveFile = async (path: string, content: string) => {
    try {
      await TauriAPI.saveFile(path, content);
      alert('文件保存成功');
    } catch (error) {
      alert('文件保存失败');
    }
  };

  return {
    systemInfo,
    saveFile,
    minimizeWindow: TauriAPI.minimizeWindow,
    closeWindow: TauriAPI.closeWindow,
  };
}
```

```jsx
// src/components/TauriApp.jsx
import React, { useState } from 'react';
import { useTauriAPI } from '../lib/tauri';

export function TauriApp() {
  const { systemInfo, saveFile, minimizeWindow, closeWindow } = useTauriAPI();
  const [fileContent, setFileContent] = useState('');

  const handleSaveFile = async () => {
    await saveFile('/path/to/file.txt', fileContent);
  };

  return (
    <div className="tauri-app">
      <header className="app-header">
        <h1>Tauri 应用</h1>
        <div className="window-controls">
          <button onClick={minimizeWindow}>最小化</button>
          <button onClick={closeWindow}>关闭</button>
        </div>
      </header>

      <main className="app-main">
        {systemInfo && (
          <div>
            <p>操作系统: {systemInfo.os}</p>
            <p>架构: {systemInfo.arch}</p>
          </div>
        )}

        <textarea
          placeholder="文件内容"
          value={fileContent}
          onChange={(e) => setFileContent(e.target.value)}
        />
        <button onClick={handleSaveFile}>保存文件</button>
      </main>
    </div>
  );
}
```

## 安全性和最佳实践

<Callout type="warning">
桌面应用的安全性至关重要，需要从多个层面进行防护。
</Callout>

### Electron安全配置

```javascript
// 安全的BrowserWindow配置
const createSecureWindow = () => {
  return new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,        // 禁用Node.js集成
      contextIsolation: true,        // 启用上下文隔离
      enableRemoteModule: false,     // 禁用remote模块
      preload: path.join(__dirname, 'preload.js'),
      sandbox: true,                 // 启用沙盒模式
      webSecurity: true              // 启用web安全
    }
  });
};

// 安全的预加载脚本
const { contextBridge, ipcRenderer } = require('electron');

const allowedChannels = ['save-file', 'read-file'];

contextBridge.exposeInMainWorld('electronAPI', {
  invoke: (channel, data) => {
    if (allowedChannels.includes(channel)) {
      return ipcRenderer.invoke(channel, data);
    }
    throw new Error(`Channel ${channel} is not allowed`);
  }
});

// 输入验证
class InputValidator {
  static validateFilePath(filePath) {
    const normalizedPath = path.normalize(filePath);
    const allowedDir = path.resolve('./user-data');

    if (!normalizedPath.startsWith(allowedDir)) {
      throw new Error('Invalid file path');
    }
    return normalizedPath;
  }

  static sanitizeInput(input) {
    return input.replace(/[<>\"'&]/g, '');
  }
}

```

### Tauri安全配置

```rust
// src-tauri/src/security.rs
use tauri::command;
use std::path::Path;

// 安全的文件操作
#[command]
pub async fn secure_read_file(path: String) -> Result<String, String> {
    // 验证路径
    let safe_path = validate_file_path(&path)?;

    // 读取文件
    std::fs::read_to_string(safe_path)
        .map_err(|e| format!("Failed to read file: {}", e))
}

fn validate_file_path(path: &str) -> Result<std::path::PathBuf, String> {
    let path = Path::new(path);

    // 防止路径遍历
    if path.components().any(|comp| comp == std::path::Component::ParentDir) {
        return Err("Path traversal not allowed".to_string());
    }

    // 限制在特定目录
    let allowed_dir = std::env::current_dir()
        .map_err(|_| "Failed to get current directory")?
        .join("user_data");

    let canonical_path = path.canonicalize()
        .map_err(|_| "Invalid path")?;

    if !canonical_path.starts_with(&allowed_dir) {
        return Err("Access denied".to_string());
    }

    Ok(canonical_path)
}
```

## 打包和分发

<Callout type="info">
桌面应用的打包和分发需要考虑不同平台的特性和代码签名。
</Callout>

### Electron应用打包

```json
// package.json配置
{
  "name": "my-electron-app",
  "version": "1.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "npm run build:renderer && npm run build:main",
    "pack": "electron-builder",
    "pack:win": "electron-builder --win",
    "pack:mac": "electron-builder --mac",
    "pack:linux": "electron-builder --linux"
  },
  "build": {
    "appId": "com.example.myapp",
    "productName": "My Electron App",
    "directories": {
      "output": "dist-packages"
    },
    "files": [
      "dist/**/*",
      "node_modules/**/*",
      "package.json"
    ],
    "win": {
      "target": "nsis",
      "icon": "assets/icon.ico"
    },
    "mac": {
      "target": "dmg",
      "icon": "assets/icon.icns"
    },
    "linux": {
      "target": "AppImage",
      "icon": "assets/icon.png"
    }
  }
}
```

### Tauri应用打包

```json
// src-tauri/tauri.conf.json
{
  "package": {
    "productName": "My Tauri App",
    "version": "1.0.0"
  },
  "build": {
    "distDir": "../dist",
    "devPath": "http://localhost:3000",
    "beforeBuildCommand": "npm run build"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "fs": {
        "readFile": true,
        "writeFile": true
      },
      "dialog": {
        "open": true,
        "save": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.example.myapp",
      "icon": [
        "icons/icon.icns",
        "icons/icon.ico"
      ]
    },
    "windows": [
      {
        "height": 600,
        "resizable": true,
        "title": "My Tauri App",
        "width": 800
      }
    ]
  }
}
```

### 构建命令

```bash
# Electron构建
npm run build
npm run pack

# Tauri构建
npm run build
cargo tauri build
```

---

<Callout type="success">
桌面应用开发为Web技术提供了新的应用场景，通过合理的技术选择和架构设计，可以创建出高质量的桌面软件。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [Electron 官方文档](https://www.electronjs.org/) - Electron权威学习资源
- [Tauri 官方文档](https://tauri.app/) - Tauri现代桌面应用框架
- [Electron Builder](https://www.electron.build/) - Electron应用打包工具

### 🎓 优质教程
- [Electron 官方教程](https://www.electronjs.org/docs/latest/tutorial/tutorial-prerequisites) - 官方入门教程
- [Tauri 指南](https://tauri.app/v1/guides/) - Tauri开发指南

### 🛠️ 实践项目
- [Electron Apps](https://www.electronjs.org/apps) - Electron应用展示
- [Tauri Examples](https://github.com/tauri-apps/tauri/tree/dev/examples) - Tauri官方示例

<Callout type="tip">
💡 **学习建议**：建议从Electron开始学习桌面应用开发基础，然后探索Tauri等现代化方案，重点关注安全性和性能优化。
</Callout>

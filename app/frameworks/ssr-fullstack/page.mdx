import { Callout } from 'nextra/components'

# 11. æœåŠ¡ç«¯æ¸²æŸ“å’Œå…¨æ ˆæ¡†æ¶

## ğŸ“‹ ç›®å½•

- [SSR/SSG/ISRæ¦‚å¿µæ·±å…¥](#ssrssgisræ¦‚å¿µæ·±å…¥)
- [Next.js 14å…¨æ ˆå¼€å‘](#nextjs-14å…¨æ ˆå¼€å‘)
- [Nuxt.js 3ç°ä»£åŒ–å¼€å‘](#nuxtjs-3ç°ä»£åŒ–å¼€å‘)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [SEOå’Œå…ƒæ•°æ®ç®¡ç†](#seoå’Œå…ƒæ•°æ®ç®¡ç†)
- [éƒ¨ç½²å’Œè¿ç»´](#éƒ¨ç½²å’Œè¿ç»´)

## ğŸ”„ SSR/SSG/ISRæ¦‚å¿µæ·±å…¥

<Callout type="info">
ç°ä»£å…¨æ ˆæ¡†æ¶æä¾›äº†å¤šç§æ¸²æŸ“ç­–ç•¥ï¼Œç†è§£å®ƒä»¬çš„åŒºåˆ«å’Œé€‚ç”¨åœºæ™¯æ˜¯æ„å»ºé«˜æ€§èƒ½Webåº”ç”¨çš„å…³é”®ã€‚
</Callout>

### æ¸²æŸ“ç­–ç•¥å¯¹æ¯”

```javascript
// æ¸²æŸ“ç­–ç•¥è¯¦è§£
const renderingStrategies = {
  // 1. å®¢æˆ·ç«¯æ¸²æŸ“ (CSR - Client-Side Rendering)
  CSR: {
    description: 'åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨JavaScriptæ¸²æŸ“é¡µé¢',
    advantages: [
      'ä¸°å¯Œçš„äº¤äº’ä½“éªŒ',
      'å‡å°‘æœåŠ¡å™¨è´Ÿè½½',
      'é¡µé¢åˆ‡æ¢æµç•…'
    ],
    disadvantages: [
      'SEOä¸å‹å¥½',
      'é¦–å±åŠ è½½æ…¢',
      'ä¾èµ–JavaScript'
    ],
    useCase: 'å¤æ‚çš„å•é¡µåº”ç”¨ï¼Œå¦‚ç®¡ç†åå°'
  },
  
  // 2. æœåŠ¡ç«¯æ¸²æŸ“ (SSR - Server-Side Rendering)
  SSR: {
    description: 'åœ¨æœåŠ¡å™¨ä¸Šæ¸²æŸ“HTMLï¼Œå‘é€å®Œæ•´é¡µé¢åˆ°æµè§ˆå™¨',
    advantages: [
      'SEOå‹å¥½',
      'é¦–å±åŠ è½½å¿«',
      'æ›´å¥½çš„æ€§èƒ½æ„ŸçŸ¥'
    ],
    disadvantages: [
      'æœåŠ¡å™¨è´Ÿè½½é«˜',
      'é¡µé¢åˆ‡æ¢å¯èƒ½è¾ƒæ…¢',
      'å¤æ‚çš„çŠ¶æ€ç®¡ç†'
    ],
    useCase: 'å†…å®¹é©±åŠ¨çš„ç½‘ç«™ï¼Œå¦‚æ–°é—»ã€åšå®¢'
  },
  
  // 3. é™æ€ç«™ç‚¹ç”Ÿæˆ (SSG - Static Site Generation)
  SSG: {
    description: 'æ„å»ºæ—¶é¢„æ¸²æŸ“æ‰€æœ‰é¡µé¢ä¸ºé™æ€HTML',
    advantages: [
      'æå¿«çš„åŠ è½½é€Ÿåº¦',
      'CDNå‹å¥½',
      'é«˜å®‰å…¨æ€§',
      'ä½æœåŠ¡å™¨æˆæœ¬'
    ],
    disadvantages: [
      'æ„å»ºæ—¶é—´é•¿',
      'åŠ¨æ€å†…å®¹æ”¯æŒæœ‰é™',
      'æ›´æ–°éœ€è¦é‡æ–°æ„å»º'
    ],
    useCase: 'æ–‡æ¡£ç½‘ç«™ã€è¥é”€é¡µé¢ã€åšå®¢'
  },
  
  // 4. å¢é‡é™æ€å†ç”Ÿ (ISR - Incremental Static Regeneration)
  ISR: {
    description: 'ç»“åˆSSGå’ŒSSRï¼ŒæŒ‰éœ€æ›´æ–°é™æ€é¡µé¢',
    advantages: [
      'é™æ€é¡µé¢çš„æ€§èƒ½',
      'åŠ¨æ€å†…å®¹æ”¯æŒ',
      'è‡ªåŠ¨ç¼“å­˜ç®¡ç†'
    ],
    disadvantages: [
      'å¤æ‚çš„ç¼“å­˜ç­–ç•¥',
      'å¯èƒ½çš„æ•°æ®ä¸ä¸€è‡´',
      'è°ƒè¯•å›°éš¾'
    ],
    useCase: 'ç”µå•†ç½‘ç«™ã€å†…å®¹ç®¡ç†ç³»ç»Ÿ'
  }
};

// æ¸²æŸ“ç­–ç•¥é€‰æ‹©å†³ç­–æ ‘
function chooseRenderingStrategy(requirements) {
  const {
    seoImportant,
    contentDynamic,
    userInteraction,
    performanceCritical,
    serverResources
  } = requirements;
  
  // SEOé‡è¦ä¸”å†…å®¹ç›¸å¯¹é™æ€
  if (seoImportant && !contentDynamic) {
    return 'SSG';
  }
  
  // SEOé‡è¦ä¸”å†…å®¹åŠ¨æ€
  if (seoImportant && contentDynamic) {
    return serverResources === 'limited' ? 'ISR' : 'SSR';
  }
  
  // é«˜äº¤äº’æ€§åº”ç”¨
  if (userInteraction === 'high') {
    return 'CSR';
  }
  
  // æ€§èƒ½å…³é”®ä¸”å†…å®¹åŠåŠ¨æ€
  if (performanceCritical && contentDynamic) {
    return 'ISR';
  }
  
  // é»˜è®¤æ¨è
  return 'SSR';
}
```

### æ°´åˆ(Hydration)åŸç†

```javascript
// æ°´åˆè¿‡ç¨‹è¯¦è§£
class HydrationManager {
  constructor() {
    this.isHydrating = true;
    this.hydratedComponents = new Set();
    this.pendingEvents = [];
  }
  
  // å¼€å§‹æ°´åˆè¿‡ç¨‹
  startHydration() {
    console.log('å¼€å§‹æ°´åˆè¿‡ç¨‹...');
    
    // 1. æ¢å¤ç»„ä»¶çŠ¶æ€
    this.restoreComponentState();
    
    // 2. ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
    this.attachEventListeners();
    
    // 3. åˆå§‹åŒ–å®¢æˆ·ç«¯ç‰¹å®šåŠŸèƒ½
    this.initializeClientFeatures();
    
    // 4. æ ‡è®°æ°´åˆå®Œæˆ
    this.completeHydration();
  }
  
  restoreComponentState() {
    // ä»æœåŠ¡ç«¯ä¼ é€’çš„æ•°æ®æ¢å¤çŠ¶æ€
    const serverData = window.__INITIAL_DATA__;
    
    if (serverData) {
      // æ¢å¤Redux store
      if (window.__REDUX_STORE__) {
        window.__REDUX_STORE__.replaceState(serverData.reduxState);
      }
      
      // æ¢å¤Reactç»„ä»¶çŠ¶æ€
      if (serverData.componentStates) {
        this.restoreReactStates(serverData.componentStates);
      }
    }
  }
  
  attachEventListeners() {
    // é‡æ–°ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
    document.querySelectorAll('[data-hydrate-events]').forEach(element => {
      const events = JSON.parse(element.dataset.hydrateEvents);
      
      events.forEach(({ type, handler }) => {
        element.addEventListener(type, this.getEventHandler(handler));
      });
    });
  }
  
  initializeClientFeatures() {
    // åˆå§‹åŒ–åªåœ¨å®¢æˆ·ç«¯è¿è¡Œçš„åŠŸèƒ½
    this.initializeAnalytics();
    this.initializeServiceWorker();
    this.initializeWebVitals();
  }
  
  completeHydration() {
    this.isHydrating = false;
    
    // å¤„ç†æ°´åˆæœŸé—´ç§¯ç´¯çš„äº‹ä»¶
    this.processPendingEvents();
    
    // è§¦å‘æ°´åˆå®Œæˆäº‹ä»¶
    window.dispatchEvent(new CustomEvent('hydration-complete'));
    
    console.log('æ°´åˆè¿‡ç¨‹å®Œæˆ');
  }
  
  // æ°´åˆæœŸé—´çš„äº‹ä»¶å¤„ç†
  handleEventDuringHydration(event) {
    if (this.isHydrating) {
      event.preventDefault();
      this.pendingEvents.push(event);
    }
  }
  
  processPendingEvents() {
    this.pendingEvents.forEach(event => {
      // é‡æ–°è§¦å‘äº‹ä»¶
      event.target.dispatchEvent(new event.constructor(event.type, event));
    });
    
    this.pendingEvents = [];
  }
}

// Reactä¸­çš„æ°´åˆä¼˜åŒ–
import { hydrateRoot } from 'react-dom/client';
import { Suspense } from 'react';

function hydrateApp() {
  const container = document.getElementById('root');
  const initialData = window.__INITIAL_DATA__;
  
  // ä½¿ç”¨SuspenseåŒ…è£…åº”ç”¨ä»¥å¤„ç†å¼‚æ­¥ç»„ä»¶
  const App = (
    <Suspense fallback={<div>Loading...</div>}>
      <AppComponent initialData={initialData} />
    </Suspense>
  );
  
  // æ°´åˆåº”ç”¨
  hydrateRoot(container, App, {
    onRecoverableError: (error) => {
      console.error('æ°´åˆè¿‡ç¨‹ä¸­çš„å¯æ¢å¤é”™è¯¯:', error);
    }
  });
}

// å»¶è¿Ÿæ°´åˆä¼˜åŒ–
class LazyHydration {
  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      { rootMargin: '50px' }
    );
  }
  
  // è§‚å¯Ÿéœ€è¦å»¶è¿Ÿæ°´åˆçš„ç»„ä»¶
  observeComponent(element) {
    this.observer.observe(element);
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.hydrateComponent(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  hydrateComponent(element) {
    const componentName = element.dataset.component;
    const props = JSON.parse(element.dataset.props || '{}');
    
    // åŠ¨æ€å¯¼å…¥å¹¶æ°´åˆç»„ä»¶
    import(`./components/${componentName}`)
      .then(({ default: Component }) => {
        hydrateRoot(element, <Component {...props} />);
      })
      .catch(error => {
        console.error(`æ°´åˆç»„ä»¶ ${componentName} å¤±è´¥:`, error);
      });
  }
}
```

## âš¡ Next.js 14å…¨æ ˆå¼€å‘

### App Routeræ·±åº¦åº”ç”¨

<Callout type="warning">
Next.js 14çš„App Routeræ˜¯ä¸€ä¸ªé‡å¤§çš„æ¶æ„å‡çº§ï¼Œæä¾›äº†æ›´å¼ºå¤§çš„è·¯ç”±å’Œå¸ƒå±€ç³»ç»Ÿã€‚
</Callout>

```typescript
// 1. æ–‡ä»¶ç³»ç»Ÿè·¯ç”±å’Œå¸ƒå±€
// app/layout.tsx - æ ¹å¸ƒå±€
import { Inter } from 'next/font/google';
import { Metadata } from 'next';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: {
    template: '%s | My App',
    default: 'My App'
  },
  description: 'ç°ä»£åŒ–çš„å…¨æ ˆåº”ç”¨',
  keywords: ['Next.js', 'React', 'TypeScript'],
  authors: [{ name: 'Your Name' }],
  creator: 'Your Name',
  openGraph: {
    type: 'website',
    locale: 'zh_CN',
    url: 'https://myapp.com',
    siteName: 'My App',
    images: [
      {
        url: '/og-image.jpg',
        width: 1200,
        height: 630,
        alt: 'My App'
      }
    ]
  },
  twitter: {
    card: 'summary_large_image',
    title: 'My App',
    description: 'ç°ä»£åŒ–çš„å…¨æ ˆåº”ç”¨',
    images: ['/twitter-image.jpg']
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1
    }
  }
};

export default function RootLayout({
  children
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh-CN">
      <body className={inter.className}>
        <header>
          <nav>å¯¼èˆªæ </nav>
        </header>
        <main>{children}</main>
        <footer>é¡µè„š</footer>
      </body>
    </html>
  );
}

// app/dashboard/layout.tsx - åµŒå¥—å¸ƒå±€
export default function DashboardLayout({
  children,
  analytics,
  team
}: {
  children: React.ReactNode;
  analytics: React.ReactNode;
  team: React.ReactNode;
}) {
  return (
    <div className="dashboard">
      <aside className="sidebar">
        <DashboardNav />
      </aside>
      <div className="content">
        {children}
        <div className="widgets">
          {analytics}
          {team}
        </div>
      </div>
    </div>
  );
}

// 2. æœåŠ¡å™¨ç»„ä»¶å’Œå®¢æˆ·ç«¯ç»„ä»¶
// app/posts/page.tsx - æœåŠ¡å™¨ç»„ä»¶
import { Suspense } from 'react';
import { PostList } from './components/PostList';
import { PostFilters } from './components/PostFilters';

interface SearchParams {
  page?: string;
  category?: string;
  search?: string;
}

export default async function PostsPage({
  searchParams
}: {
  searchParams: SearchParams;
}) {
  // æœåŠ¡å™¨ç«¯æ•°æ®è·å–
  const posts = await getPosts({
    page: Number(searchParams.page) || 1,
    category: searchParams.category,
    search: searchParams.search
  });
  
  return (
    <div>
      <h1>æ–‡ç« åˆ—è¡¨</h1>
      
      {/* å®¢æˆ·ç«¯ç»„ä»¶ç”¨äºäº¤äº’ */}
      <PostFilters />
      
      {/* ä½¿ç”¨Suspenseå¤„ç†å¼‚æ­¥åŠ è½½ */}
      <Suspense fallback={<PostListSkeleton />}>
        <PostList posts={posts} />
      </Suspense>
    </div>
  );
}

// app/posts/components/PostFilters.tsx - å®¢æˆ·ç«¯ç»„ä»¶
'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { useState, useCallback } from 'react';

export function PostFilters() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [search, setSearch] = useState(searchParams.get('search') || '');
  
  const updateFilters = useCallback((updates: Record<string, string>) => {
    const params = new URLSearchParams(searchParams);
    
    Object.entries(updates).forEach(([key, value]) => {
      if (value) {
        params.set(key, value);
      } else {
        params.delete(key);
      }
    });
    
    router.push(`/posts?${params.toString()}`);
  }, [router, searchParams]);
  
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    updateFilters({ search, page: '1' });
  };
  
  return (
    <form onSubmit={handleSearch} className="filters">
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="æœç´¢æ–‡ç« ..."
      />
      
      <select
        value={searchParams.get('category') || ''}
        onChange={(e) => updateFilters({ category: e.target.value, page: '1' })}
      >
        <option value="">æ‰€æœ‰åˆ†ç±»</option>
        <option value="tech">æŠ€æœ¯</option>
        <option value="design">è®¾è®¡</option>
        <option value="business">å•†ä¸š</option>
      </select>
      
      <button type="submit">æœç´¢</button>
    </form>
  );
}

// 3. APIè·¯ç”±å’Œä¸­é—´ä»¶
// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

const PostSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().min(1),
  category: z.string(),
  tags: z.array(z.string()).optional()
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = Number(searchParams.get('page')) || 1;
    const limit = Number(searchParams.get('limit')) || 10;
    const category = searchParams.get('category');
    const search = searchParams.get('search');
    
    const posts = await getPosts({
      page,
      limit,
      category,
      search
    });
    
    return NextResponse.json({
      data: posts,
      pagination: {
        page,
        limit,
        total: posts.length
      }
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'è·å–æ–‡ç« å¤±è´¥' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = PostSchema.parse(body);
    
    const post = await createPost(validatedData);
    
    return NextResponse.json(post, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'æ•°æ®éªŒè¯å¤±è´¥', details: error.errors },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'åˆ›å»ºæ–‡ç« å¤±è´¥' },
      { status: 500 }
    );
  }
}

// middleware.ts - ä¸­é—´ä»¶
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // è®¤è¯æ£€æŸ¥
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    const token = request.cookies.get('auth-token');
    
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
  }
  
  // APIé™æµ
  if (request.nextUrl.pathname.startsWith('/api/')) {
    const ip = request.ip || 'unknown';
    const rateLimitResult = checkRateLimit(ip);
    
    if (!rateLimitResult.allowed) {
      return NextResponse.json(
        { error: 'è¯·æ±‚è¿‡äºé¢‘ç¹' },
        { status: 429 }
      );
    }
  }
  
  // åœ°ç†ä½ç½®é‡å®šå‘
  const country = request.geo?.country;
  if (country === 'CN' && !request.nextUrl.pathname.startsWith('/cn')) {
    return NextResponse.redirect(new URL('/cn', request.url));
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/api/:path*',
    '/((?!_next/static|_next/image|favicon.ico).*)'
  ]
};

// 4. æ•°æ®è·å–å’Œç¼“å­˜
// lib/data.ts
import { unstable_cache } from 'next/cache';

// ç¼“å­˜æ•°æ®è·å–å‡½æ•°
export const getCachedPosts = unstable_cache(
  async (filters: PostFilters) => {
    const posts = await db.post.findMany({
      where: {
        ...(filters.category && { category: filters.category }),
        ...(filters.search && {
          OR: [
            { title: { contains: filters.search } },
            { content: { contains: filters.search } }
          ]
        })
      },
      include: {
        author: true,
        tags: true
      },
      orderBy: { createdAt: 'desc' }
    });
    
    return posts;
  },
  ['posts'],
  {
    revalidate: 3600, // 1å°æ—¶åé‡æ–°éªŒè¯
    tags: ['posts']
  }
);

// æ‰‹åŠ¨é‡æ–°éªŒè¯ç¼“å­˜
import { revalidateTag } from 'next/cache';

export async function createPost(data: PostData) {
  const post = await db.post.create({ data });
  
  // é‡æ–°éªŒè¯ç›¸å…³ç¼“å­˜
  revalidateTag('posts');
  
  return post;
}

// 5. æµå¼æ¸²æŸ“
// app/posts/[id]/page.tsx
import { Suspense } from 'react';

export default function PostPage({ params }: { params: { id: string } }) {
  return (
    <div>
      {/* ç«‹å³æ¸²æŸ“çš„å†…å®¹ */}
      <PostHeader postId={params.id} />
      
      {/* æµå¼æ¸²æŸ“çš„å†…å®¹ */}
      <Suspense fallback={<PostContentSkeleton />}>
        <PostContent postId={params.id} />
      </Suspense>
      
      <Suspense fallback={<CommentsSkeleton />}>
        <Comments postId={params.id} />
      </Suspense>
      
      <Suspense fallback={<RelatedPostsSkeleton />}>
        <RelatedPosts postId={params.id} />
      </Suspense>
    </div>
  );
}

async function PostContent({ postId }: { postId: string }) {
  // æ¨¡æ‹Ÿæ…¢é€Ÿæ•°æ®è·å–
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const post = await getPost(postId);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

## ğŸ¨ Nuxt.js 3ç°ä»£åŒ–å¼€å‘

### Nuxt 3æ ¸å¿ƒç‰¹æ€§

```vue
<!-- 1. è‡ªåŠ¨å¯¼å…¥å’Œç»„ä»¶ -->
<!-- pages/index.vue -->
<template>
  <div>
    <h1>{{ title }}</h1>
    
    <!-- è‡ªåŠ¨å¯¼å…¥çš„ç»„ä»¶ -->
    <UserCard 
      v-for="user in users" 
      :key="user.id" 
      :user="user" 
    />
    
    <!-- å†…ç½®ç»„ä»¶ -->
    <NuxtLink to="/about">å…³äºæˆ‘ä»¬</NuxtLink>
    <NuxtImg src="/hero.jpg" alt="Hero Image" />
  </div>
</template>

<script setup>
// è‡ªåŠ¨å¯¼å…¥çš„ç»„åˆå¼å‡½æ•°
const title = ref('æ¬¢è¿æ¥åˆ°æˆ‘çš„ç½‘ç«™');

// æœåŠ¡ç«¯æ•°æ®è·å–
const { data: users } = await $fetch('/api/users');

// SEOå’Œå…ƒæ•°æ®
useSeoMeta({
  title: 'é¦–é¡µ',
  description: 'è¿™æ˜¯æˆ‘çš„ç½‘ç«™é¦–é¡µ',
  ogTitle: 'é¦–é¡µ',
  ogDescription: 'è¿™æ˜¯æˆ‘çš„ç½‘ç«™é¦–é¡µ',
  ogImage: '/og-image.jpg',
  twitterCard: 'summary_large_image'
});

// é¡µé¢çº§åˆ«çš„ä¸­é—´ä»¶
definePageMeta({
  middleware: 'auth',
  layout: 'default'
});
</script>

<!-- 2. æœåŠ¡å™¨API -->
<!-- server/api/users.get.ts -->
export default defineEventHandler(async (event) => {
  const query = getQuery(event);
  const { page = 1, limit = 10 } = query;
  
  try {
    const users = await getUsersFromDB({
      page: Number(page),
      limit: Number(limit)
    });
    
    return {
      data: users,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total: users.length
      }
    };
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'è·å–ç”¨æˆ·å¤±è´¥'
    });
  }
});

<!-- server/api/users.post.ts -->
export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  
  // æ•°æ®éªŒè¯
  const schema = z.object({
    name: z.string().min(1),
    email: z.string().email(),
    role: z.enum(['admin', 'user'])
  });
  
  try {
    const validatedData = schema.parse(body);
    const user = await createUser(validatedData);
    
    return user;
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw createError({
        statusCode: 400,
        statusMessage: 'æ•°æ®éªŒè¯å¤±è´¥',
        data: error.errors
      });
    }
    
    throw createError({
      statusCode: 500,
      statusMessage: 'åˆ›å»ºç”¨æˆ·å¤±è´¥'
    });
  }
});

<!-- 3. ä¸­é—´ä»¶å’Œæ’ä»¶ -->
<!-- middleware/auth.ts -->
export default defineNuxtRouteMiddleware((to, from) => {
  const { $auth } = useNuxtApp();
  
  if (!$auth.user) {
    return navigateTo('/login');
  }
});

<!-- plugins/auth.client.ts -->
export default defineNuxtPlugin(async () => {
  const user = ref(null);
  const token = useCookie('auth-token');
  
  const login = async (credentials: LoginCredentials) => {
    const { data } = await $fetch('/api/auth/login', {
      method: 'POST',
      body: credentials
    });
    
    user.value = data.user;
    token.value = data.token;
  };
  
  const logout = () => {
    user.value = null;
    token.value = null;
    navigateTo('/');
  };
  
  const checkAuth = async () => {
    if (token.value) {
      try {
        const { data } = await $fetch('/api/auth/me', {
          headers: {
            Authorization: `Bearer ${token.value}`
          }
        });
        user.value = data;
      } catch (error) {
        token.value = null;
      }
    }
  };
  
  // åˆå§‹åŒ–æ—¶æ£€æŸ¥è®¤è¯çŠ¶æ€
  await checkAuth();
  
  return {
    provide: {
      auth: {
        user: readonly(user),
        login,
        logout,
        checkAuth
      }
    }
  };
});

<!-- 4. çŠ¶æ€ç®¡ç† -->
<!-- stores/user.ts -->
export const useUserStore = defineStore('user', () => {
  const users = ref<User[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);
  
  const fetchUsers = async () => {
    loading.value = true;
    error.value = null;
    
    try {
      const { data } = await $fetch('/api/users');
      users.value = data;
    } catch (err) {
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  };
  
  const addUser = async (userData: CreateUserData) => {
    try {
      const newUser = await $fetch('/api/users', {
        method: 'POST',
        body: userData
      });
      
      users.value.unshift(newUser);
      return newUser;
    } catch (err) {
      error.value = err.message;
      throw err;
    }
  };
  
  const filteredUsers = computed(() => {
    return users.value.filter(user => user.status === 'active');
  });
  
  return {
    users: readonly(users),
    loading: readonly(loading),
    error: readonly(error),
    filteredUsers,
    fetchUsers,
    addUser
  };
});

<!-- 5. é…ç½®æ–‡ä»¶ -->
<!-- nuxt.config.ts -->
export default defineNuxtConfig({
  // å¼€å‘å·¥å…·
  devtools: { enabled: true },
  
  // TypeScripté…ç½®
  typescript: {
    strict: true,
    typeCheck: true
  },
  
  // CSSæ¡†æ¶
  css: ['~/assets/css/main.css'],
  
  // æ¨¡å—
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
    '@nuxtjs/color-mode',
    '@vueuse/nuxt',
    '@nuxt/image'
  ],
  
  // è¿è¡Œæ—¶é…ç½®
  runtimeConfig: {
    // ç§æœ‰é…ç½®ï¼ˆä»…æœåŠ¡ç«¯ï¼‰
    apiSecret: process.env.API_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    
    // å…¬å…±é…ç½®ï¼ˆå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ï¼‰
    public: {
      apiBase: process.env.API_BASE || '/api',
      appName: 'My Nuxt App'
    }
  },
  
  // æ¸²æŸ“é…ç½®
  nitro: {
    preset: 'vercel',
    compressPublicAssets: true
  },
  
  // å®éªŒæ€§åŠŸèƒ½
  experimental: {
    payloadExtraction: false,
    viewTransition: true
  },
  
  // æ„å»ºé…ç½®
  build: {
    transpile: ['@headlessui/vue']
  },
  
  // è·¯ç”±é…ç½®
  router: {
    options: {
      scrollBehaviorType: 'smooth'
    }
  }
});
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½

```javascript
// 1. åŠ¨æ€å¯¼å…¥å’Œä»£ç åˆ†å‰²
// Next.jsä¸­çš„åŠ¨æ€å¯¼å…¥
import dynamic from 'next/dynamic';
import { Suspense } from 'react';

// ç»„ä»¶çº§ä»£ç åˆ†å‰²
const DynamicChart = dynamic(() => import('../components/Chart'), {
  loading: () => <p>Loading chart...</p>,
  ssr: false // ç¦ç”¨æœåŠ¡ç«¯æ¸²æŸ“
});

const DynamicModal = dynamic(() => import('../components/Modal'), {
  loading: () => <div>Loading modal...</div>
});

// æ¡ä»¶åŠ è½½
const AdminPanel = dynamic(() => import('../components/AdminPanel'), {
  loading: () => <div>Loading admin panel...</div>
});

function Dashboard({ user }) {
  return (
    <div>
      <h1>Dashboard</h1>

      {/* æ€»æ˜¯åŠ è½½çš„ç»„ä»¶ */}
      <UserProfile user={user} />

      {/* æ‡’åŠ è½½çš„å›¾è¡¨ç»„ä»¶ */}
      <Suspense fallback={<ChartSkeleton />}>
        <DynamicChart data={user.analytics} />
      </Suspense>

      {/* æ¡ä»¶æ‡’åŠ è½½ */}
      {user.role === 'admin' && (
        <Suspense fallback={<AdminSkeleton />}>
          <AdminPanel />
        </Suspense>
      )}
    </div>
  );
}

// 2. è·¯ç”±çº§ä»£ç åˆ†å‰²
// pages/products/[id].js
import { lazy, Suspense } from 'react';

const ProductReviews = lazy(() => import('../../components/ProductReviews'));
const RelatedProducts = lazy(() => import('../../components/RelatedProducts'));

export default function ProductPage({ product }) {
  return (
    <div>
      <ProductInfo product={product} />

      <Suspense fallback={<ReviewsSkeleton />}>
        <ProductReviews productId={product.id} />
      </Suspense>

      <Suspense fallback={<RelatedSkeleton />}>
        <RelatedProducts category={product.category} />
      </Suspense>
    </div>
  );
}

// 3. ç¬¬ä¸‰æ–¹åº“çš„æ‡’åŠ è½½
class LazyLibraryLoader {
  constructor() {
    this.loadedLibraries = new Set();
    this.loadingPromises = new Map();
  }

  async loadLibrary(name, loader) {
    if (this.loadedLibraries.has(name)) {
      return;
    }

    if (this.loadingPromises.has(name)) {
      return this.loadingPromises.get(name);
    }

    const promise = loader().then(lib => {
      this.loadedLibraries.add(name);
      this.loadingPromises.delete(name);
      return lib;
    });

    this.loadingPromises.set(name, promise);
    return promise;
  }

  // é¢„åŠ è½½å…³é”®åº“
  preloadLibraries() {
    // åœ¨ç©ºé—²æ—¶é—´é¢„åŠ è½½
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => {
        this.loadLibrary('charts', () => import('chart.js'));
        this.loadLibrary('editor', () => import('@monaco-editor/react'));
      });
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const libraryLoader = new LazyLibraryLoader();

function ChartComponent({ data }) {
  const [chartLib, setChartLib] = useState(null);

  useEffect(() => {
    libraryLoader.loadLibrary('charts', () => import('chart.js'))
      .then(lib => setChartLib(lib));
  }, []);

  if (!chartLib) {
    return <div>Loading chart library...</div>;
  }

  return <Chart data={data} library={chartLib} />;
}
```

### ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

```javascript
// 1. å¤šå±‚ç¼“å­˜æ¶æ„
class CacheManager {
  constructor() {
    this.memoryCache = new Map();
    this.sessionCache = sessionStorage;
    this.persistentCache = localStorage;
    this.serviceWorkerCache = 'sw-cache-v1';
  }

  // å†…å­˜ç¼“å­˜ï¼ˆæœ€å¿«ï¼Œä½†é¡µé¢åˆ·æ–°åä¸¢å¤±ï¼‰
  setMemoryCache(key, value, ttl = 300000) { // 5åˆ†é’Ÿ
    const expiry = Date.now() + ttl;
    this.memoryCache.set(key, { value, expiry });
  }

  getMemoryCache(key) {
    const item = this.memoryCache.get(key);
    if (!item) return null;

    if (Date.now() > item.expiry) {
      this.memoryCache.delete(key);
      return null;
    }

    return item.value;
  }

  // ä¼šè¯ç¼“å­˜ï¼ˆé¡µé¢å…³é—­åä¸¢å¤±ï¼‰
  setSessionCache(key, value) {
    try {
      this.sessionCache.setItem(key, JSON.stringify({
        value,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.warn('Session cache storage failed:', error);
    }
  }

  getSessionCache(key, maxAge = 3600000) { // 1å°æ—¶
    try {
      const item = this.sessionCache.getItem(key);
      if (!item) return null;

      const { value, timestamp } = JSON.parse(item);

      if (Date.now() - timestamp > maxAge) {
        this.sessionCache.removeItem(key);
        return null;
      }

      return value;
    } catch (error) {
      return null;
    }
  }

  // æŒä¹…ç¼“å­˜ï¼ˆæµè§ˆå™¨å…³é—­åä»ä¿ç•™ï¼‰
  setPersistentCache(key, value, ttl = 86400000) { // 24å°æ—¶
    try {
      this.persistentCache.setItem(key, JSON.stringify({
        value,
        expiry: Date.now() + ttl
      }));
    } catch (error) {
      console.warn('Persistent cache storage failed:', error);
    }
  }

  getPersistentCache(key) {
    try {
      const item = this.persistentCache.getItem(key);
      if (!item) return null;

      const { value, expiry } = JSON.parse(item);

      if (Date.now() > expiry) {
        this.persistentCache.removeItem(key);
        return null;
      }

      return value;
    } catch (error) {
      return null;
    }
  }

  // Service Workerç¼“å­˜
  async setServiceWorkerCache(key, response) {
    if ('serviceWorker' in navigator && 'caches' in window) {
      try {
        const cache = await caches.open(this.serviceWorkerCache);
        await cache.put(key, response.clone());
      } catch (error) {
        console.warn('Service Worker cache failed:', error);
      }
    }
  }

  async getServiceWorkerCache(key) {
    if ('caches' in window) {
      try {
        const cache = await caches.open(this.serviceWorkerCache);
        return await cache.match(key);
      } catch (error) {
        return null;
      }
    }
    return null;
  }

  // æ™ºèƒ½ç¼“å­˜ç­–ç•¥
  async get(key, fetcher, options = {}) {
    const {
      useMemory = true,
      useSession = true,
      usePersistent = true,
      useServiceWorker = false,
      ttl = 300000
    } = options;

    // 1. å°è¯•å†…å­˜ç¼“å­˜
    if (useMemory) {
      const memoryResult = this.getMemoryCache(key);
      if (memoryResult) return memoryResult;
    }

    // 2. å°è¯•ä¼šè¯ç¼“å­˜
    if (useSession) {
      const sessionResult = this.getSessionCache(key);
      if (sessionResult) {
        if (useMemory) this.setMemoryCache(key, sessionResult, ttl);
        return sessionResult;
      }
    }

    // 3. å°è¯•æŒä¹…ç¼“å­˜
    if (usePersistent) {
      const persistentResult = this.getPersistentCache(key);
      if (persistentResult) {
        if (useMemory) this.setMemoryCache(key, persistentResult, ttl);
        if (useSession) this.setSessionCache(key, persistentResult);
        return persistentResult;
      }
    }

    // 4. å°è¯•Service Workerç¼“å­˜
    if (useServiceWorker) {
      const swResult = await this.getServiceWorkerCache(key);
      if (swResult) {
        const data = await swResult.json();
        if (useMemory) this.setMemoryCache(key, data, ttl);
        if (useSession) this.setSessionCache(key, data);
        return data;
      }
    }

    // 5. è·å–æ–°æ•°æ®
    try {
      const freshData = await fetcher();

      // å­˜å‚¨åˆ°å„çº§ç¼“å­˜
      if (useMemory) this.setMemoryCache(key, freshData, ttl);
      if (useSession) this.setSessionCache(key, freshData);
      if (usePersistent) this.setPersistentCache(key, freshData, ttl);

      return freshData;
    } catch (error) {
      console.error('Failed to fetch fresh data:', error);
      throw error;
    }
  }
}

// 2. React Queryé›†æˆ
import { useQuery, useQueryClient } from '@tanstack/react-query';

const cacheManager = new CacheManager();

function useOptimizedQuery(key, fetcher, options = {}) {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: key,
    queryFn: () => cacheManager.get(
      key.join('-'),
      fetcher,
      options.cache
    ),
    staleTime: options.staleTime || 5 * 60 * 1000, // 5åˆ†é’Ÿ
    cacheTime: options.cacheTime || 30 * 60 * 1000, // 30åˆ†é’Ÿ
    refetchOnWindowFocus: false,
    ...options
  });
}

// ä½¿ç”¨ç¤ºä¾‹
function UserProfile({ userId }) {
  const { data: user, isLoading, error } = useOptimizedQuery(
    ['user', userId],
    () => fetch(`/api/users/${userId}`).then(res => res.json()),
    {
      cache: {
        useMemory: true,
        useSession: true,
        usePersistent: true,
        ttl: 600000 // 10åˆ†é’Ÿ
      },
      staleTime: 300000 // 5åˆ†é’Ÿ
    }
  );

  if (isLoading) return <UserSkeleton />;
  if (error) return <ErrorMessage error={error} />;

  return <UserCard user={user} />;
}
```

## ğŸ” SEOå’Œå…ƒæ•°æ®ç®¡ç†

### ç»“æ„åŒ–æ•°æ®å’ŒSchema.org

```javascript
// 1. ç»“æ„åŒ–æ•°æ®ç”Ÿæˆå™¨
class StructuredDataGenerator {
  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://example.com';
  }

  // æ–‡ç« ç»“æ„åŒ–æ•°æ®
  generateArticleSchema(article) {
    return {
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: article.title,
      description: article.excerpt,
      image: article.featuredImage ? [
        `${this.baseUrl}${article.featuredImage}`
      ] : [],
      datePublished: article.publishedAt,
      dateModified: article.updatedAt,
      author: {
        '@type': 'Person',
        name: article.author.name,
        url: `${this.baseUrl}/authors/${article.author.slug}`
      },
      publisher: {
        '@type': 'Organization',
        name: 'My Blog',
        logo: {
          '@type': 'ImageObject',
          url: `${this.baseUrl}/logo.png`
        }
      },
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': `${this.baseUrl}/articles/${article.slug}`
      }
    };
  }

  // äº§å“ç»“æ„åŒ–æ•°æ®
  generateProductSchema(product) {
    return {
      '@context': 'https://schema.org',
      '@type': 'Product',
      name: product.name,
      description: product.description,
      image: product.images.map(img => `${this.baseUrl}${img}`),
      brand: {
        '@type': 'Brand',
        name: product.brand
      },
      offers: {
        '@type': 'Offer',
        price: product.price,
        priceCurrency: 'CNY',
        availability: product.inStock
          ? 'https://schema.org/InStock'
          : 'https://schema.org/OutOfStock',
        seller: {
          '@type': 'Organization',
          name: 'My Store'
        }
      },
      aggregateRating: product.reviews.length > 0 ? {
        '@type': 'AggregateRating',
        ratingValue: product.averageRating,
        reviewCount: product.reviews.length
      } : undefined
    };
  }

  // é¢åŒ…å±‘å¯¼èˆª
  generateBreadcrumbSchema(breadcrumbs) {
    return {
      '@context': 'https://schema.org',
      '@type': 'BreadcrumbList',
      itemListElement: breadcrumbs.map((crumb, index) => ({
        '@type': 'ListItem',
        position: index + 1,
        name: crumb.name,
        item: `${this.baseUrl}${crumb.path}`
      }))
    };
  }

  // ç»„ç»‡ä¿¡æ¯
  generateOrganizationSchema() {
    return {
      '@context': 'https://schema.org',
      '@type': 'Organization',
      name: 'My Company',
      url: this.baseUrl,
      logo: `${this.baseUrl}/logo.png`,
      contactPoint: {
        '@type': 'ContactPoint',
        telephone: '+86-123-456-7890',
        contactType: 'customer service',
        availableLanguage: ['Chinese', 'English']
      },
      sameAs: [
        'https://twitter.com/mycompany',
        'https://linkedin.com/company/mycompany',
        'https://github.com/mycompany'
      ]
    };
  }
}

// 2. Next.jsä¸­çš„SEOç»„ä»¶
import Head from 'next/head';

function SEOHead({
  title,
  description,
  canonical,
  openGraph,
  structuredData,
  noindex = false
}) {
  const fullTitle = title ? `${title} | My Site` : 'My Site';
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL;

  return (
    <Head>
      {/* åŸºç¡€å…ƒæ•°æ® */}
      <title>{fullTitle}</title>
      <meta name="description" content={description} />
      {canonical && <link rel="canonical" href={`${baseUrl}${canonical}`} />}

      {/* æœºå™¨äººæŒ‡ä»¤ */}
      <meta
        name="robots"
        content={noindex ? 'noindex,nofollow' : 'index,follow'}
      />

      {/* Open Graph */}
      <meta property="og:title" content={openGraph?.title || title} />
      <meta property="og:description" content={openGraph?.description || description} />
      <meta property="og:type" content={openGraph?.type || 'website'} />
      <meta property="og:url" content={`${baseUrl}${canonical}`} />
      {openGraph?.image && (
        <>
          <meta property="og:image" content={`${baseUrl}${openGraph.image}`} />
          <meta property="og:image:width" content="1200" />
          <meta property="og:image:height" content="630" />
        </>
      )}

      {/* Twitter Card */}
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content={openGraph?.title || title} />
      <meta name="twitter:description" content={openGraph?.description || description} />
      {openGraph?.image && (
        <meta name="twitter:image" content={`${baseUrl}${openGraph.image}`} />
      )}

      {/* ç»“æ„åŒ–æ•°æ® */}
      {structuredData && (
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify(structuredData)
          }}
        />
      )}
    </Head>
  );
}

// 3. åŠ¨æ€SEO Hook
function useSEO() {
  const router = useRouter();
  const [seoData, setSeoData] = useState({});

  const updateSEO = useCallback((data) => {
    setSeoData(prev => ({ ...prev, ...data }));
  }, []);

  // æ ¹æ®è·¯ç”±è‡ªåŠ¨ç”ŸæˆSEOæ•°æ®
  useEffect(() => {
    const generateAutoSEO = () => {
      const path = router.asPath;
      const segments = path.split('/').filter(Boolean);

      // ç”Ÿæˆé¢åŒ…å±‘
      const breadcrumbs = segments.map((segment, index) => ({
        name: segment.charAt(0).toUpperCase() + segment.slice(1),
        path: '/' + segments.slice(0, index + 1).join('/')
      }));

      updateSEO({
        canonical: path,
        breadcrumbs
      });
    };

    generateAutoSEO();
  }, [router.asPath, updateSEO]);

  return { seoData, updateSEO };
}

// ä½¿ç”¨ç¤ºä¾‹
function ArticlePage({ article }) {
  const { updateSEO } = useSEO();
  const structuredDataGenerator = new StructuredDataGenerator();

  useEffect(() => {
    updateSEO({
      title: article.title,
      description: article.excerpt,
      openGraph: {
        title: article.title,
        description: article.excerpt,
        type: 'article',
        image: article.featuredImage
      },
      structuredData: structuredDataGenerator.generateArticleSchema(article)
    });
  }, [article, updateSEO]);

  return (
    <article>
      <h1>{article.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: article.content }} />
    </article>
  );
}
```

---

<Callout type="success">
ç°ä»£å…¨æ ˆæ¡†æ¶å¦‚Next.jså’ŒNuxt.jsæä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼Œä»å¼€å‘åˆ°éƒ¨ç½²çš„å…¨æµç¨‹æ”¯æŒï¼Œå¤§å¤§æå‡äº†å…¨æ ˆå¼€å‘çš„æ•ˆç‡ã€‚
</Callout>

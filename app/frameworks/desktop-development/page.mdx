import { Callout } from 'nextra/components'

# 13. æ¡Œé¢åº”ç”¨å¼€å‘

## ğŸ“‹ ç›®å½•

- [æ¡Œé¢åº”ç”¨å¼€å‘æ¦‚è§ˆ](#æ¡Œé¢åº”ç”¨å¼€å‘æ¦‚è§ˆ)
- [Electronæ·±å…¥å¼€å‘](#electronæ·±å…¥å¼€å‘)
- [Tauriç°ä»£åŒ–æ–¹æ¡ˆ](#tauriç°ä»£åŒ–æ–¹æ¡ˆ)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [å®‰å…¨æ€§å’Œæœ€ä½³å®è·µ](#å®‰å…¨æ€§å’Œæœ€ä½³å®è·µ)
- [æ‰“åŒ…å’Œåˆ†å‘](#æ‰“åŒ…å’Œåˆ†å‘)

## æ¡Œé¢åº”ç”¨å¼€å‘æ¦‚è§ˆ

<Callout type="info">
æ¡Œé¢åº”ç”¨å¼€å‘è®©[Web](https://developer.mozilla.org/en-US/docs/Web)æŠ€æœ¯èƒ½å¤Ÿåˆ›å»ºåŸç”Ÿæ¡Œé¢åº”ç”¨ï¼Œä¸ºå‰ç«¯å¼€å‘è€…æä¾›äº†æ›´å¹¿é˜”çš„åº”ç”¨åœºæ™¯ã€‚
</Callout>

### æ¡Œé¢åº”ç”¨æŠ€æœ¯æ ˆå¯¹æ¯”

```javascript
// æ¡Œé¢åº”ç”¨å¼€å‘æŠ€æœ¯å¯¹æ¯”
const desktopTechnologies = {
  // Electron
  electron: {
    æŠ€æœ¯æ ˆ: 'Chromium + Node.js',
    å¼€å‘è¯­è¨€: 'JavaScript/TypeScript + HTML/CSS',
    ä¼˜åŠ¿: [
      'æˆç†Ÿç¨³å®šçš„ç”Ÿæ€ç³»ç»Ÿ',
      'ä¸°å¯Œçš„APIå’Œæ’ä»¶',
      'è·¨å¹³å°æ”¯æŒå®Œå–„',
      'å¤§é‡æˆåŠŸæ¡ˆä¾‹'
    ],
    åŠ£åŠ¿: [
      'åº”ç”¨ä½“ç§¯è¾ƒå¤§',
      'å†…å­˜å ç”¨é«˜',
      'æ€§èƒ½ç›¸å¯¹è¾ƒå·®'
    ],
    é€‚ç”¨åœºæ™¯: 'å¤æ‚çš„æ¡Œé¢åº”ç”¨',
    çŸ¥ååº”ç”¨: ['VS Code', 'Discord', 'Slack', 'WhatsApp']
  },
  
  // Tauri
  tauri: {
    æŠ€æœ¯æ ˆ: 'Rust + WebView',
    å¼€å‘è¯­è¨€: 'Rust + JavaScript/TypeScript',
    ä¼˜åŠ¿: [
      'åº”ç”¨ä½“ç§¯å°',
      'å†…å­˜å ç”¨ä½',
      'æ€§èƒ½ä¼˜ç§€',
      'å®‰å…¨æ€§é«˜'
    ],
    åŠ£åŠ¿: [
      'ç”Ÿæ€ç›¸å¯¹è¾ƒæ–°',
      'éœ€è¦å­¦ä¹ Rust',
      'WebViewå…¼å®¹æ€§é—®é¢˜'
    ],
    é€‚ç”¨åœºæ™¯: 'è½»é‡çº§é«˜æ€§èƒ½åº”ç”¨',
    çŸ¥ååº”ç”¨: ['Clash Verge', 'Pake']
  },
  
  // Flutter Desktop
  flutter: {
    æŠ€æœ¯æ ˆ: 'Flutter + Dart',
    å¼€å‘è¯­è¨€: 'Dart',
    ä¼˜åŠ¿: [
      'ç»Ÿä¸€çš„UIæ¡†æ¶',
      'é«˜æ€§èƒ½æ¸²æŸ“',
      'è·¨å¹³å°ä¸€è‡´æ€§'
    ],
    åŠ£åŠ¿: [
      'å­¦ä¹ æˆæœ¬é«˜',
      'ç”Ÿæ€ç›¸å¯¹è¾ƒå°',
      'Webé›†æˆå¤æ‚'
    ],
    é€‚ç”¨åœºæ™¯: 'éœ€è¦ç»Ÿä¸€UIçš„è·¨å¹³å°åº”ç”¨'
  },
  
  // .NET MAUI
  maui: {
    æŠ€æœ¯æ ˆ: '.NET + C#',
    å¼€å‘è¯­è¨€: 'C#/F#',
    ä¼˜åŠ¿: [
      'å¾®è½¯ç”Ÿæ€æ”¯æŒ',
      'ä¼ä¸šçº§å¼€å‘',
      'æ€§èƒ½ä¼˜ç§€'
    ],
    åŠ£åŠ¿: [
      'ä¸»è¦é¢å‘Windows',
      'å­¦ä¹ æˆæœ¬é«˜'
    ],
    é€‚ç”¨åœºæ™¯: 'ä¼ä¸šçº§Windowsåº”ç”¨'
  }
};

// æŠ€æœ¯é€‰æ‹©å†³ç­–æ ‘
function chooseDesktopTechnology(requirements) {
  const {
    teamSkills,
    performanceRequirements,
    appComplexity,
    targetPlatforms,
    developmentTime,
    appSize
  } = requirements;
  
  // WebæŠ€æœ¯æ ˆå›¢é˜Ÿ
  if (teamSkills.includes('web')) {
    // æ€§èƒ½è¦æ±‚é«˜ä¸”åº”ç”¨ä½“ç§¯æ•æ„Ÿ
    if (performanceRequirements === 'high' && appSize === 'small') {
      return {
        recommendation: 'Tauri',
        reason: 'é«˜æ€§èƒ½ã€å°ä½“ç§¯ï¼Œä½†éœ€è¦å­¦ä¹ Rust'
      };
    }
    
    // å¤æ‚åº”ç”¨æˆ–å¿«é€Ÿå¼€å‘
    if (appComplexity === 'high' || developmentTime === 'short') {
      return {
        recommendation: 'Electron',
        reason: 'æˆç†Ÿç”Ÿæ€ï¼Œå¼€å‘æ•ˆç‡é«˜'
      };
    }
  }
  
  // ç§»åŠ¨ç«¯ç»éªŒä¸°å¯Œ
  if (teamSkills.includes('flutter')) {
    return {
      recommendation: 'Flutter Desktop',
      reason: 'ç»Ÿä¸€æŠ€æœ¯æ ˆï¼Œè·¨å¹³å°ä¸€è‡´æ€§'
    };
  }
  
  // ä¼ä¸šçº§.NETå›¢é˜Ÿ
  if (teamSkills.includes('dotnet')) {
    return {
      recommendation: '.NET MAUI',
      reason: 'ä¼ä¸šçº§æ”¯æŒï¼ŒWindowsç”Ÿæ€ä¼˜åŠ¿'
    };
  }
  
  // é»˜è®¤æ¨è
  return {
    recommendation: 'Electron',
    reason: 'æœ€æˆç†Ÿçš„Webåˆ°æ¡Œé¢è§£å†³æ–¹æ¡ˆ'
  };
}
```

## Electronæ·±å…¥å¼€å‘

### Electronæ¶æ„å’Œè¿›ç¨‹é€šä¿¡

```javascript
// 1. ä¸»è¿›ç¨‹ (main.js)
const { app, BrowserWindow, ipcMain, Menu, dialog, shell } = require('electron');
const path = require('path');
const isDev = process.env.NODE_ENV === 'development';

class ElectronApp {
  constructor() {
    this.mainWindow = null;
    this.setupApp();
  }
  
  setupApp() {
    // åº”ç”¨å‡†å¤‡å°±ç»ª
    app.whenReady().then(() => {
      this.createMainWindow();
      this.setupMenu();
      this.setupIPC();
      
      // macOSç‰¹æ®Šå¤„ç†
      app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
          this.createMainWindow();
        }
      });
    });
    
    // æ‰€æœ‰çª—å£å…³é—­
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit();
      }
    });
    
    // åº”ç”¨é€€å‡ºå‰
    app.on('before-quit', (event) => {
      // ä¿å­˜åº”ç”¨çŠ¶æ€
      this.saveAppState();
    });
  }
  
  createMainWindow() {
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false, // å®‰å…¨è€ƒè™‘
        contextIsolation: true, // å¯ç”¨ä¸Šä¸‹æ–‡éš”ç¦»
        enableRemoteModule: false, // ç¦ç”¨remoteæ¨¡å—
        preload: path.join(__dirname, 'preload.js') // é¢„åŠ è½½è„šæœ¬
      },
      titleBarStyle: 'hiddenInset', // macOSæ ·å¼
      show: false // å…ˆéšè—ï¼ŒåŠ è½½å®Œæˆåæ˜¾ç¤º
    });
    
    // åŠ è½½åº”ç”¨
    if (isDev) {
      this.mainWindow.loadURL('http://localhost:3000');
      this.mainWindow.webContents.openDevTools();
    } else {
      this.mainWindow.loadFile(path.join(__dirname, '../build/index.html'));
    }
    
    // çª—å£äº‹ä»¶
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow.show();
      
      // æ¢å¤çª—å£çŠ¶æ€
      this.restoreWindowState();
    });
    
    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
    
    // é˜»æ­¢æ–°çª—å£æ‰“å¼€
    this.mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: 'deny' };
    });
  }
  
  setupMenu() {
    const template = [
      {
        label: 'æ–‡ä»¶',
        submenu: [
          {
            label: 'æ–°å»º',
            accelerator: 'CmdOrCtrl+N',
            click: () => {
              this.mainWindow.webContents.send('menu-new-file');
            }
          },
          {
            label: 'æ‰“å¼€',
            accelerator: 'CmdOrCtrl+O',
            click: async () => {
              const result = await dialog.showOpenDialog(this.mainWindow, {
                properties: ['openFile'],
                filters: [
                  { name: 'Text Files', extensions: ['txt', 'md'] },
                  { name: 'All Files', extensions: ['*'] }
                ]
              });
              
              if (!result.canceled) {
                this.mainWindow.webContents.send('menu-open-file', result.filePaths[0]);
              }
            }
          },
          { type: 'separator' },
          {
            label: 'é€€å‡º',
            accelerator: process.platform === 'darwin' ? 'Cmd+Q' : 'Ctrl+Q',
            click: () => {
              app.quit();
            }
          }
        ]
      },
      {
        label: 'ç¼–è¾‘',
        submenu: [
          { role: 'undo', label: 'æ’¤é”€' },
          { role: 'redo', label: 'é‡åš' },
          { type: 'separator' },
          { role: 'cut', label: 'å‰ªåˆ‡' },
          { role: 'copy', label: 'å¤åˆ¶' },
          { role: 'paste', label: 'ç²˜è´´' }
        ]
      },
      {
        label: 'è§†å›¾',
        submenu: [
          { role: 'reload', label: 'é‡æ–°åŠ è½½' },
          { role: 'forceReload', label: 'å¼ºåˆ¶é‡æ–°åŠ è½½' },
          { role: 'toggleDevTools', label: 'å¼€å‘è€…å·¥å…·' },
          { type: 'separator' },
          { role: 'resetZoom', label: 'å®é™…å¤§å°' },
          { role: 'zoomIn', label: 'æ”¾å¤§' },
          { role: 'zoomOut', label: 'ç¼©å°' },
          { type: 'separator' },
          { role: 'togglefullscreen', label: 'å…¨å±' }
        ]
      }
    ];
    
    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
  }
  
  setupIPC() {
    // æ–‡ä»¶æ“ä½œ
    ipcMain.handle('read-file', async (event, filePath) => {
      try {
        const fs = require('fs').promises;
        const content = await fs.readFile(filePath, 'utf8');
        return { success: true, content };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
    
    ipcMain.handle('write-file', async (event, filePath, content) => {
      try {
        const fs = require('fs').promises;
        await fs.writeFile(filePath, content, 'utf8');
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
    
    // ç³»ç»Ÿä¿¡æ¯
    ipcMain.handle('get-system-info', () => {
      const os = require('os');
      return {
        platform: process.platform,
        arch: process.arch,
        version: process.getSystemVersion(),
        memory: os.totalmem(),
        cpus: os.cpus().length
      };
    });
    
    // åº”ç”¨ä¿¡æ¯
    ipcMain.handle('get-app-info', () => {
      return {
        name: app.getName(),
        version: app.getVersion(),
        path: app.getAppPath()
      };
    });
    
    // çª—å£æ§åˆ¶
    ipcMain.handle('window-minimize', () => {
      this.mainWindow.minimize();
    });
    
    ipcMain.handle('window-maximize', () => {
      if (this.mainWindow.isMaximized()) {
        this.mainWindow.unmaximize();
      } else {
        this.mainWindow.maximize();
      }
    });
    
    ipcMain.handle('window-close', () => {
      this.mainWindow.close();
    });
  }
  
  saveAppState() {
    const bounds = this.mainWindow.getBounds();
    const isMaximized = this.mainWindow.isMaximized();
    
    // ä¿å­˜åˆ°ç”¨æˆ·æ•°æ®ç›®å½•
    const Store = require('electron-store');
    const store = new Store();
    
    store.set('windowBounds', bounds);
    store.set('windowMaximized', isMaximized);
  }
  
  restoreWindowState() {
    const Store = require('electron-store');
    const store = new Store();
    
    const bounds = store.get('windowBounds');
    const isMaximized = store.get('windowMaximized');
    
    if (bounds) {
      this.mainWindow.setBounds(bounds);
    }
    
    if (isMaximized) {
      this.mainWindow.maximize();
    }
  }
}

// å¯åŠ¨åº”ç”¨
new ElectronApp();

// 2. é¢„åŠ è½½è„šæœ¬ (preload.js)
const { contextBridge, ipcRenderer } = require('electron');

// æš´éœ²å®‰å…¨çš„APIåˆ°æ¸²æŸ“è¿›ç¨‹
contextBridge.exposeInMainWorld('electronAPI', {
  // æ–‡ä»¶æ“ä½œ
  readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
  writeFile: (filePath, content) => ipcRenderer.invoke('write-file', filePath, content),
  
  // ç³»ç»Ÿä¿¡æ¯
  getSystemInfo: () => ipcRenderer.invoke('get-system-info'),
  getAppInfo: () => ipcRenderer.invoke('get-app-info'),
  
  // çª—å£æ§åˆ¶
  minimizeWindow: () => ipcRenderer.invoke('window-minimize'),
  maximizeWindow: () => ipcRenderer.invoke('window-maximize'),
  closeWindow: () => ipcRenderer.invoke('window-close'),
  
  // äº‹ä»¶ç›‘å¬
  onMenuAction: (callback) => {
    ipcRenderer.on('menu-new-file', callback);
    ipcRenderer.on('menu-open-file', callback);
  },
  
  // ç§»é™¤ç›‘å¬å™¨
  removeAllListeners: (channel) => {
    ipcRenderer.removeAllListeners(channel);
  }
});

// 3. æ¸²æŸ“è¿›ç¨‹ (Reactç»„ä»¶)
import React, { useState, useEffect } from 'react';

function App() {
  const [systemInfo, setSystemInfo] = useState(null);
  const [appInfo, setAppInfo] = useState(null);
  const [fileContent, setFileContent] = useState('');
  
  useEffect(() => {
    // è·å–ç³»ç»Ÿä¿¡æ¯
    window.electronAPI.getSystemInfo().then(setSystemInfo);
    window.electronAPI.getAppInfo().then(setAppInfo);
    
    // ç›‘å¬èœå•äº‹ä»¶
    window.electronAPI.onMenuAction((event, data) => {
      if (event.type === 'menu-new-file') {
        setFileContent('');
      } else if (event.type === 'menu-open-file') {
        handleOpenFile(data);
      }
    });
    
    return () => {
      window.electronAPI.removeAllListeners('menu-new-file');
      window.electronAPI.removeAllListeners('menu-open-file');
    };
  }, []);
  
  const handleOpenFile = async (filePath) => {
    const result = await window.electronAPI.readFile(filePath);
    if (result.success) {
      setFileContent(result.content);
    } else {
      alert(`æ‰“å¼€æ–‡ä»¶å¤±è´¥: ${result.error}`);
    }
  };
  
  const handleSaveFile = async () => {
    // è¿™é‡Œåº”è¯¥æœ‰æ–‡ä»¶è·¯å¾„é€‰æ‹©é€»è¾‘
    const filePath = '/path/to/file.txt';
    const result = await window.electronAPI.writeFile(filePath, fileContent);
    
    if (result.success) {
      alert('æ–‡ä»¶ä¿å­˜æˆåŠŸ');
    } else {
      alert(`ä¿å­˜æ–‡ä»¶å¤±è´¥: ${result.error}`);
    }
  };
  
  return (
    <div className="app">
      <header className="title-bar">
        <div className="title">æˆ‘çš„Electronåº”ç”¨</div>
        <div className="window-controls">
          <button onClick={() => window.electronAPI.minimizeWindow()}>
            âˆ’
          </button>
          <button onClick={() => window.electronAPI.maximizeWindow()}>
            â–¡
          </button>
          <button onClick={() => window.electronAPI.closeWindow()}>
            Ã—
          </button>
        </div>
      </header>
      
      <main className="content">
        <div className="info-panel">
          {systemInfo && (
            <div>
              <h3>ç³»ç»Ÿä¿¡æ¯</h3>
              <p>å¹³å°: {systemInfo.platform}</p>
              <p>æ¶æ„: {systemInfo.arch}</p>
              <p>CPUæ ¸å¿ƒ: {systemInfo.cpus}</p>
            </div>
          )}
          
          {appInfo && (
            <div>
              <h3>åº”ç”¨ä¿¡æ¯</h3>
              <p>åç§°: {appInfo.name}</p>
              <p>ç‰ˆæœ¬: {appInfo.version}</p>
            </div>
          )}
        </div>
        
        <div className="editor">
          <textarea
            value={fileContent}
            onChange={(e) => setFileContent(e.target.value)}
            placeholder="åœ¨è¿™é‡Œè¾“å…¥å†…å®¹..."
          />
          <button onClick={handleSaveFile}>ä¿å­˜æ–‡ä»¶</button>
        </div>
      </main>
    </div>
  );
}

export default App;
```

### Electronæ€§èƒ½ä¼˜åŒ–

```javascript
// 1. è¿›ç¨‹ç®¡ç†ä¼˜åŒ–
class ProcessManager {
  constructor() {
    this.workers = new Map();
    this.maxWorkers = require('os').cpus().length;
  }
  
  // åˆ›å»ºå·¥ä½œè¿›ç¨‹
  createWorker(name, scriptPath) {
    if (this.workers.size >= this.maxWorkers) {
      throw new Error('å·²è¾¾åˆ°æœ€å¤§å·¥ä½œè¿›ç¨‹æ•°');
    }
    
    const { fork } = require('child_process');
    const worker = fork(scriptPath);
    
    worker.on('message', (message) => {
      this.handleWorkerMessage(name, message);
    });
    
    worker.on('error', (error) => {
      console.error(`å·¥ä½œè¿›ç¨‹ ${name} é”™è¯¯:`, error);
      this.restartWorker(name, scriptPath);
    });
    
    worker.on('exit', (code) => {
      console.log(`å·¥ä½œè¿›ç¨‹ ${name} é€€å‡ºï¼Œä»£ç : ${code}`);
      this.workers.delete(name);
    });
    
    this.workers.set(name, worker);
    return worker;
  }
  
  // å‘é€ä»»åŠ¡åˆ°å·¥ä½œè¿›ç¨‹
  sendTask(workerName, task) {
    const worker = this.workers.get(workerName);
    if (worker) {
      worker.send(task);
    }
  }
  
  // é‡å¯å·¥ä½œè¿›ç¨‹
  restartWorker(name, scriptPath) {
    const worker = this.workers.get(name);
    if (worker) {
      worker.kill();
      this.workers.delete(name);
    }
    
    setTimeout(() => {
      this.createWorker(name, scriptPath);
    }, 1000);
  }
  
  // æ¸…ç†æ‰€æœ‰å·¥ä½œè¿›ç¨‹
  cleanup() {
    for (const [name, worker] of this.workers) {
      worker.kill();
    }
    this.workers.clear();
  }
}

// 2. å†…å­˜ç®¡ç†
class MemoryManager {
  constructor() {
    this.memoryThreshold = 500 * 1024 * 1024; // 500MB
    this.checkInterval = 30000; // 30ç§’
    this.startMonitoring();
  }
  
  startMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage();
    }, this.checkInterval);
  }
  
  checkMemoryUsage() {
    const usage = process.memoryUsage();
    
    console.log('å†…å­˜ä½¿ç”¨æƒ…å†µ:', {
      rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,
      external: `${Math.round(usage.external / 1024 / 1024)}MB`
    });
    
    if (usage.heapUsed > this.memoryThreshold) {
      console.warn('å†…å­˜ä½¿ç”¨è¿‡é«˜ï¼Œè§¦å‘åƒåœ¾å›æ”¶');
      this.forceGarbageCollection();
    }
  }
  
  forceGarbageCollection() {
    if (global.gc) {
      global.gc();
    } else {
      console.warn('åƒåœ¾å›æ”¶ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨ --expose-gc å¯åŠ¨');
    }
  }
  
  // æ¸…ç†å¤§å¯¹è±¡
  clearLargeObjects() {
    // æ¸…ç†ç¼“å­˜
    if (global.imageCache) {
      global.imageCache.clear();
    }
    
    // æ¸…ç†ä¸´æ—¶æ•°æ®
    if (global.tempData) {
      global.tempData = null;
    }
  }
}

// 3. æ¸²æŸ“ä¼˜åŒ–
class RenderOptimizer {
  constructor(webContents) {
    this.webContents = webContents;
    this.setupOptimizations();
  }
  
  setupOptimizations() {
    // ç¦ç”¨ä¸å¿…è¦çš„åŠŸèƒ½
    this.webContents.session.setPermissionRequestHandler((webContents, permission, callback) => {
      const allowedPermissions = ['notifications', 'clipboard-read'];
      callback(allowedPermissions.includes(permission));
    });
    
    // é¢„åŠ è½½å…³é”®èµ„æº
    this.preloadCriticalResources();
    
    // è®¾ç½®ç¼“å­˜ç­–ç•¥
    this.setupCacheStrategy();
  }
  
  preloadCriticalResources() {
    // é¢„åŠ è½½å­—ä½“
    this.webContents.executeJavaScript(`
      const fonts = [
        'Arial',
        'Helvetica',
        'Times New Roman'
      ];
      
      fonts.forEach(font => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'font';
        link.href = font;
        document.head.appendChild(link);
      });
    `);
  }
  
  setupCacheStrategy() {
    const { session } = this.webContents;
    
    // è®¾ç½®ç¼“å­˜å¤§å°
    session.setCacheSize(100 * 1024 * 1024); // 100MB
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    setInterval(() => {
      session.clearCache();
    }, 24 * 60 * 60 * 1000); // 24å°æ—¶
  }
  
  // ä¼˜åŒ–å›¾ç‰‡åŠ è½½
  optimizeImageLoading() {
    this.webContents.executeJavaScript(`
      // æ‡’åŠ è½½å›¾ç‰‡
      const images = document.querySelectorAll('img[data-src]');
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            imageObserver.unobserve(img);
          }
        });
      });
      
      images.forEach(img => imageObserver.observe(img));
    `);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const processManager = new ProcessManager();
const memoryManager = new MemoryManager();

// åœ¨ä¸»è¿›ç¨‹ä¸­ä½¿ç”¨
app.whenReady().then(() => {
  const mainWindow = new BrowserWindow({
    // ... çª—å£é…ç½®
  });
  
  const renderOptimizer = new RenderOptimizer(mainWindow.webContents);
  
  // åˆ›å»ºå·¥ä½œè¿›ç¨‹å¤„ç†é‡ä»»åŠ¡
  processManager.createWorker('imageProcessor', './workers/imageProcessor.js');
  processManager.createWorker('dataProcessor', './workers/dataProcessor.js');
});

// åº”ç”¨é€€å‡ºæ—¶æ¸…ç†
app.on('before-quit', () => {
  processManager.cleanup();
});
```

## Tauriç°ä»£åŒ–æ–¹æ¡ˆ

<Callout type="info">
[Tauri](https://tauri.app/)æ˜¯ä½¿ç”¨Rustæ„å»ºçš„ç°ä»£æ¡Œé¢åº”ç”¨æ¡†æ¶ï¼Œæä¾›æ›´å°çš„åŒ…ä½“ç§¯å’Œæ›´å¥½çš„æ€§èƒ½ã€‚
</Callout>

### Taurié¡¹ç›®ç»“æ„

```rust
// src-tauri/src/main.rs
#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]

use tauri::{CustomMenuItem, Menu, MenuItem, Submenu, Manager, Window};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct AppConfig {
    theme: String,
    language: String,
    auto_update: bool,
}

// å‘½ä»¤å‡½æ•°
#[tauri::command]
async fn get_system_info() -> Result<SystemInfo, String> {
    let info = SystemInfo {
        os: std::env::consts::OS.to_string(),
        arch: std::env::consts::ARCH.to_string(),
        version: "1.0.0".to_string(),
    };
    Ok(info)
}

#[tauri::command]
async fn save_file(path: String, content: String) -> Result<(), String> {
    std::fs::write(&path, content)
        .map_err(|e| format!("Failed to save file: {}", e))?;
    Ok(())
}

#[tauri::command]
async fn read_file(path: String) -> Result<String, String> {
    std::fs::read_to_string(&path)
        .map_err(|e| format!("Failed to read file: {}", e))
}

#[tauri::command]
async fn show_notification(title: String, body: String) -> Result<(), String> {
    use tauri::api::notification::Notification;

    Notification::new("com.example.app")
        .title(&title)
        .body(&body)
        .show()
        .map_err(|e| format!("Failed to show notification: {}", e))?;

    Ok(())
}

#[derive(Debug, Serialize)]
struct SystemInfo {
    os: String,
    arch: String,
    version: String,
}

// çª—å£äº‹ä»¶å¤„ç†
fn handle_window_event(event: tauri::WindowEvent) {
    match event {
        tauri::WindowEvent::CloseRequested { api, .. } => {
            // è‡ªå®šä¹‰å…³é—­è¡Œä¸º
            println!("Window close requested");
            // api.prevent_close(); // é˜»æ­¢å…³é—­
        }
        tauri::WindowEvent::Resized(size) => {
            println!("Window resized to: {:?}", size);
        }
        tauri::WindowEvent::Moved(position) => {
            println!("Window moved to: {:?}", position);
        }
        _ => {}
    }
}

// èœå•åˆ›å»º
fn create_menu() -> Menu {
    let quit = CustomMenuItem::new("quit".to_string(), "Quit");
    let close = CustomMenuItem::new("close".to_string(), "Close");
    let submenu = Submenu::new("File", Menu::new().add_item(close).add_item(quit));

    Menu::new()
        .add_native_item(MenuItem::Copy)
        .add_item(CustomMenuItem::new("hide", "Hide"))
        .add_submenu(submenu)
}

fn main() {
    let menu = create_menu();

    tauri::Builder::default()
        .menu(menu)
        .on_menu_event(|event| {
            match event.menu_item_id() {
                "quit" => {
                    std::process::exit(0);
                }
                "close" => {
                    event.window().close().unwrap();
                }
                "hide" => {
                    event.window().hide().unwrap();
                }
                _ => {}
            }
        })
        .on_window_event(|event| handle_window_event(event.event().clone()))
        .invoke_handler(tauri::generate_handler![
            get_system_info,
            save_file,
            read_file,
            show_notification
        ])
        .setup(|app| {
            // åº”ç”¨åˆå§‹åŒ–
            let window = app.get_window("main").unwrap();

            // è®¾ç½®çª—å£å±æ€§
            window.set_title("Tauri App").unwrap();
            window.center().unwrap();

            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

```toml
# src-tauri/Cargo.toml
[package]
name = "tauri-app"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
license = ""
repository = ""
edition = "2021"
rust-version = "1.60"

[build-dependencies]
tauri-build = { version = "1.0", features = [] }

[dependencies]
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
tauri = { version = "1.0", features = ["api-all"] }
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.11", features = ["json"] }

[features]
default = ["custom-protocol"]
custom-protocol = ["tauri/custom-protocol"]
```

### å‰ç«¯é›†æˆ

```typescript
// src/lib/tauri.ts
import { invoke } from '@tauri-apps/api/tauri';
import { listen } from '@tauri-apps/api/event';
import { appWindow } from '@tauri-apps/api/window';

export interface SystemInfo {
  os: string;
  arch: string;
  version: string;
}

export class TauriAPI {
  // ç³»ç»Ÿä¿¡æ¯
  static async getSystemInfo(): Promise<SystemInfo> {
    return await invoke('get_system_info');
  }

  // æ–‡ä»¶æ“ä½œ
  static async saveFile(path: string, content: string): Promise<void> {
    return await invoke('save_file', { path, content });
  }

  static async readFile(path: string): Promise<string> {
    return await invoke('read_file', { path });
  }

  // é€šçŸ¥
  static async showNotification(title: string, body: string): Promise<void> {
    return await invoke('show_notification', { title, body });
  }

  // çª—å£æ“ä½œ
  static async minimizeWindow(): Promise<void> {
    return await appWindow.minimize();
  }

  static async maximizeWindow(): Promise<void> {
    return await appWindow.maximize();
  }

  static async closeWindow(): Promise<void> {
    return await appWindow.close();
  }

  // äº‹ä»¶ç›‘å¬
  static async listenToEvents() {
    // ç›‘å¬çª—å£äº‹ä»¶
    await listen('tauri://window-resized', (event) => {
      console.log('Window resized:', event.payload);
    });

    await listen('tauri://window-moved', (event) => {
      console.log('Window moved:', event.payload);
    });

    // ç›‘å¬è‡ªå®šä¹‰äº‹ä»¶
    await listen('app://notification', (event) => {
      console.log('Notification received:', event.payload);
    });
  }
}

// React Hook
import { useState, useEffect } from 'react';

export function useTauriAPI() {
  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadSystemInfo = async () => {
      try {
        const info = await TauriAPI.getSystemInfo();
        setSystemInfo(info);
      } catch (error) {
        console.error('Failed to load system info:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadSystemInfo();
    TauriAPI.listenToEvents();
  }, []);

  const saveFile = async (path: string, content: string) => {
    try {
      await TauriAPI.saveFile(path, content);
      await TauriAPI.showNotification('æˆåŠŸ', 'æ–‡ä»¶ä¿å­˜æˆåŠŸ');
    } catch (error) {
      console.error('Failed to save file:', error);
      await TauriAPI.showNotification('é”™è¯¯', 'æ–‡ä»¶ä¿å­˜å¤±è´¥');
    }
  };

  const readFile = async (path: string): Promise<string | null> => {
    try {
      return await TauriAPI.readFile(path);
    } catch (error) {
      console.error('Failed to read file:', error);
      return null;
    }
  };

  return {
    systemInfo,
    isLoading,
    saveFile,
    readFile,
    minimizeWindow: TauriAPI.minimizeWindow,
    maximizeWindow: TauriAPI.maximizeWindow,
    closeWindow: TauriAPI.closeWindow,
  };
}
```

```jsx
// src/components/TauriApp.jsx
import React, { useState } from 'react';
import { useTauriAPI } from '../lib/tauri';

export function TauriApp() {
  const {
    systemInfo,
    isLoading,
    saveFile,
    readFile,
    minimizeWindow,
    maximizeWindow,
    closeWindow,
  } = useTauriAPI();

  const [fileContent, setFileContent] = useState('');
  const [filePath, setFilePath] = useState('');

  const handleSaveFile = async () => {
    if (filePath && fileContent) {
      await saveFile(filePath, fileContent);
    }
  };

  const handleReadFile = async () => {
    if (filePath) {
      const content = await readFile(filePath);
      if (content) {
        setFileContent(content);
      }
    }
  };

  if (isLoading) {
    return <div className="loading">åŠ è½½ä¸­...</div>;
  }

  return (
    <div className="tauri-app">
      <header className="app-header">
        <h1>Tauri åº”ç”¨</h1>
        <div className="window-controls">
          <button onClick={minimizeWindow}>æœ€å°åŒ–</button>
          <button onClick={maximizeWindow}>æœ€å¤§åŒ–</button>
          <button onClick={closeWindow}>å…³é—­</button>
        </div>
      </header>

      <main className="app-main">
        <section className="system-info">
          <h2>ç³»ç»Ÿä¿¡æ¯</h2>
          {systemInfo && (
            <div>
              <p>æ“ä½œç³»ç»Ÿ: {systemInfo.os}</p>
              <p>æ¶æ„: {systemInfo.arch}</p>
              <p>ç‰ˆæœ¬: {systemInfo.version}</p>
            </div>
          )}
        </section>

        <section className="file-operations">
          <h2>æ–‡ä»¶æ“ä½œ</h2>
          <div className="file-controls">
            <input
              type="text"
              placeholder="æ–‡ä»¶è·¯å¾„"
              value={filePath}
              onChange={(e) => setFilePath(e.target.value)}
            />
            <button onClick={handleReadFile}>è¯»å–æ–‡ä»¶</button>
            <button onClick={handleSaveFile}>ä¿å­˜æ–‡ä»¶</button>
          </div>
          <textarea
            placeholder="æ–‡ä»¶å†…å®¹"
            value={fileContent}
            onChange={(e) => setFileContent(e.target.value)}
            rows={10}
            cols={50}
          />
        </section>
      </main>
    </div>
  );
}
```

## å®‰å…¨æ€§å’Œæœ€ä½³å®è·µ

<Callout type="warning">
æ¡Œé¢åº”ç”¨çš„å®‰å…¨æ€§è‡³å…³é‡è¦ï¼Œéœ€è¦ä»å¤šä¸ªå±‚é¢è¿›è¡Œé˜²æŠ¤ï¼ŒåŒ…æ‹¬ä»£ç å®‰å…¨ã€æ•°æ®ä¿æŠ¤ã€ç½‘ç»œå®‰å…¨ç­‰ã€‚
</Callout>

### Electronå®‰å…¨æœ€ä½³å®è·µ

```javascript
// 1. å®‰å…¨çš„BrowserWindowé…ç½®
const createSecureWindow = () => {
  return new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      // ç¦ç”¨Node.jsé›†æˆ
      nodeIntegration: false,

      // å¯ç”¨ä¸Šä¸‹æ–‡éš”ç¦»
      contextIsolation: true,

      // ç¦ç”¨è¿œç¨‹æ¨¡å—
      enableRemoteModule: false,

      // é¢„åŠ è½½è„šæœ¬
      preload: path.join(__dirname, 'preload.js'),

      // ç¦ç”¨å®éªŒæ€§åŠŸèƒ½
      experimentalFeatures: false,

      // å¯ç”¨æ²™ç›’æ¨¡å¼
      sandbox: true,

      // ç¦ç”¨webSecurityï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰
      webSecurity: !isDevelopment,

      // ç¦ç”¨allowRunningInsecureContent
      allowRunningInsecureContent: false,
    }
  });
};

// 2. å®‰å…¨çš„é¢„åŠ è½½è„šæœ¬
// preload.js
const { contextBridge, ipcRenderer } = require('electron');

// ç™½åå•API
const allowedChannels = [
  'get-app-version',
  'save-file',
  'read-file',
  'show-message-box'
];

contextBridge.exposeInMainWorld('electronAPI', {
  // å®‰å…¨çš„IPCé€šä¿¡
  invoke: (channel, data) => {
    if (allowedChannels.includes(channel)) {
      return ipcRenderer.invoke(channel, data);
    }
    throw new Error(`Channel ${channel} is not allowed`);
  },

  // å®‰å…¨çš„äº‹ä»¶ç›‘å¬
  on: (channel, callback) => {
    if (allowedChannels.includes(channel)) {
      ipcRenderer.on(channel, callback);
    }
  },

  // ç§»é™¤ç›‘å¬å™¨
  removeAllListeners: (channel) => {
    if (allowedChannels.includes(channel)) {
      ipcRenderer.removeAllListeners(channel);
    }
  }
});

// 3. å†…å®¹å®‰å…¨ç­–ç•¥ (CSP)
const setupCSP = (window) => {
  const csp = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "font-src 'self'",
    "connect-src 'self' https://api.example.com",
    "frame-src 'none'",
    "object-src 'none'"
  ].join('; ');

  window.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [csp]
      }
    });
  });
};

// 4. è¾“å…¥éªŒè¯å’Œæ¸…ç†
class InputValidator {
  static validateFilePath(filePath) {
    // é˜²æ­¢è·¯å¾„éå†æ”»å‡»
    const normalizedPath = path.normalize(filePath);
    const allowedDir = path.resolve('./user-data');

    if (!normalizedPath.startsWith(allowedDir)) {
      throw new Error('Invalid file path');
    }

    return normalizedPath;
  }

  static sanitizeInput(input) {
    if (typeof input !== 'string') {
      throw new Error('Input must be a string');
    }

    // ç§»é™¤å±é™©å­—ç¬¦
    return input.replace(/[<>\"'&]/g, '');
  }

  static validateURL(url) {
    try {
      const parsedURL = new URL(url);
      const allowedProtocols = ['https:', 'http:'];
      const allowedHosts = ['api.example.com', 'cdn.example.com'];

      if (!allowedProtocols.includes(parsedURL.protocol)) {
        throw new Error('Invalid protocol');
      }

      if (!allowedHosts.includes(parsedURL.hostname)) {
        throw new Error('Invalid hostname');
      }

      return url;
    } catch (error) {
      throw new Error('Invalid URL');
    }
  }
}

// 5. åŠ å¯†å­˜å‚¨
const crypto = require('crypto');
const fs = require('fs').promises;

class SecureStorage {
  constructor(password) {
    this.algorithm = 'aes-256-gcm';
    this.key = crypto.scryptSync(password, 'salt', 32);
  }

  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key, iv);

    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }

  decrypt(encryptedData) {
    const { encrypted, iv, authTag } = encryptedData;
    const decipher = crypto.createDecipher(
      this.algorithm,
      this.key,
      Buffer.from(iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  async saveSecureData(filePath, data) {
    const encryptedData = this.encrypt(JSON.stringify(data));
    await fs.writeFile(filePath, JSON.stringify(encryptedData));
  }

  async loadSecureData(filePath) {
    const encryptedData = JSON.parse(await fs.readFile(filePath, 'utf8'));
    const decryptedData = this.decrypt(encryptedData);
    return JSON.parse(decryptedData);
  }
}

// 6. è‡ªåŠ¨æ›´æ–°å®‰å…¨
const { autoUpdater } = require('electron-updater');

class SecureUpdater {
  constructor() {
    // é…ç½®æ›´æ–°æœåŠ¡å™¨
    autoUpdater.setFeedURL({
      provider: 'github',
      owner: 'your-username',
      repo: 'your-repo',
      private: false
    });

    // éªŒè¯æ›´æ–°ç­¾å
    autoUpdater.verifySignature = true;

    this.setupEventHandlers();
  }

  setupEventHandlers() {
    autoUpdater.on('checking-for-update', () => {
      console.log('Checking for update...');
    });

    autoUpdater.on('update-available', (info) => {
      console.log('Update available:', info);
      // éªŒè¯æ›´æ–°ä¿¡æ¯
      if (this.validateUpdateInfo(info)) {
        this.downloadUpdate();
      }
    });

    autoUpdater.on('update-not-available', (info) => {
      console.log('Update not available:', info);
    });

    autoUpdater.on('error', (err) => {
      console.error('Update error:', err);
    });

    autoUpdater.on('download-progress', (progressObj) => {
      console.log('Download progress:', progressObj.percent);
    });

    autoUpdater.on('update-downloaded', (info) => {
      console.log('Update downloaded:', info);
      // æç¤ºç”¨æˆ·é‡å¯åº”ç”¨
      this.promptUserToRestart();
    });
  }

  validateUpdateInfo(info) {
    // éªŒè¯ç‰ˆæœ¬å·æ ¼å¼
    const versionRegex = /^\d+\.\d+\.\d+$/;
    if (!versionRegex.test(info.version)) {
      return false;
    }

    // éªŒè¯æ–‡ä»¶å¤§å°åˆç†æ€§
    if (info.files[0].size > 500 * 1024 * 1024) { // 500MB
      return false;
    }

    return true;
  }

  async downloadUpdate() {
    try {
      await autoUpdater.downloadUpdate();
    } catch (error) {
      console.error('Download failed:', error);
    }
  }

  promptUserToRestart() {
    const { dialog } = require('electron');

    dialog.showMessageBox({
      type: 'info',
      title: 'æ›´æ–°ä¸‹è½½å®Œæˆ',
      message: 'æ–°ç‰ˆæœ¬å·²ä¸‹è½½å®Œæˆï¼Œæ˜¯å¦ç«‹å³é‡å¯åº”ç”¨ï¼Ÿ',
      buttons: ['ç«‹å³é‡å¯', 'ç¨åé‡å¯']
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.quitAndInstall();
      }
    });
  }

  checkForUpdates() {
    autoUpdater.checkForUpdatesAndNotify();
  }
}
```

### Tauriå®‰å…¨é…ç½®

```rust
// src-tauri/src/security.rs
use tauri::{command, Window, State};
use std::collections::HashMap;
use std::sync::Mutex;

// æƒé™ç®¡ç†
pub struct PermissionManager {
    permissions: Mutex<HashMap<String, Vec<String>>>,
}

impl PermissionManager {
    pub fn new() -> Self {
        Self {
            permissions: Mutex::new(HashMap::new()),
        }
    }

    pub fn grant_permission(&self, user: String, permission: String) {
        let mut perms = self.permissions.lock().unwrap();
        perms.entry(user).or_insert_with(Vec::new).push(permission);
    }

    pub fn has_permission(&self, user: &str, permission: &str) -> bool {
        let perms = self.permissions.lock().unwrap();
        perms.get(user)
            .map(|user_perms| user_perms.contains(&permission.to_string()))
            .unwrap_or(false)
    }
}

// å®‰å…¨çš„æ–‡ä»¶æ“ä½œ
#[command]
pub async fn secure_read_file(
    path: String,
    permission_manager: State<'_, PermissionManager>,
) -> Result<String, String> {
    // éªŒè¯æƒé™
    if !permission_manager.has_permission("current_user", "read_file") {
        return Err("Permission denied".to_string());
    }

    // éªŒè¯è·¯å¾„
    let safe_path = validate_file_path(&path)?;

    // è¯»å–æ–‡ä»¶
    std::fs::read_to_string(safe_path)
        .map_err(|e| format!("Failed to read file: {}", e))
}

fn validate_file_path(path: &str) -> Result<std::path::PathBuf, String> {
    use std::path::Path;

    let path = Path::new(path);

    // é˜²æ­¢è·¯å¾„éå†
    if path.components().any(|comp| comp == std::path::Component::ParentDir) {
        return Err("Path traversal not allowed".to_string());
    }

    // é™åˆ¶åœ¨ç‰¹å®šç›®å½•
    let allowed_dir = std::env::current_dir()
        .map_err(|_| "Failed to get current directory")?
        .join("user_data");

    let canonical_path = path.canonicalize()
        .map_err(|_| "Invalid path")?;

    if !canonical_path.starts_with(&allowed_dir) {
        return Err("Access denied".to_string());
    }

    Ok(canonical_path)
}
```

## æ‰“åŒ…å’Œåˆ†å‘

<Callout type="info">
æ¡Œé¢åº”ç”¨çš„æ‰“åŒ…å’Œåˆ†å‘éœ€è¦è€ƒè™‘ä¸åŒå¹³å°çš„ç‰¹æ€§ã€ä»£ç ç­¾åã€è‡ªåŠ¨æ›´æ–°ç­‰å¤šä¸ªæ–¹é¢ã€‚
</Callout>

### Electronåº”ç”¨æ‰“åŒ…

```json
// package.jsoné…ç½®
{
  "name": "my-electron-app",
  "version": "1.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "npm run build:renderer && npm run build:main",
    "build:renderer": "webpack --mode production",
    "build:main": "webpack --config webpack.main.config.js --mode production",
    "pack": "electron-builder",
    "pack:win": "electron-builder --win",
    "pack:mac": "electron-builder --mac",
    "pack:linux": "electron-builder --linux",
    "dist": "npm run build && electron-builder",
    "publish": "npm run build && electron-builder --publish=always"
  },
  "build": {
    "appId": "com.example.myapp",
    "productName": "My Electron App",
    "directories": {
      "output": "dist-packages"
    },
    "files": [
      "dist/**/*",
      "node_modules/**/*",
      "package.json"
    ],
    "extraResources": [
      {
        "from": "assets/",
        "to": "assets/",
        "filter": ["**/*"]
      }
    ],
    "win": {
      "target": [
        {
          "target": "nsis",
          "arch": ["x64", "ia32"]
        },
        {
          "target": "portable",
          "arch": ["x64"]
        }
      ],
      "icon": "assets/icon.ico",
      "certificateFile": "certificates/cert.p12",
      "certificatePassword": "password",
      "publisherName": "Your Company Name"
    },
    "mac": {
      "target": [
        {
          "target": "dmg",
          "arch": ["x64", "arm64"]
        },
        {
          "target": "zip",
          "arch": ["x64", "arm64"]
        }
      ],
      "icon": "assets/icon.icns",
      "category": "public.app-category.productivity",
      "hardenedRuntime": true,
      "entitlements": "assets/entitlements.mac.plist",
      "entitlementsInherit": "assets/entitlements.mac.plist"
    },
    "linux": {
      "target": [
        {
          "target": "AppImage",
          "arch": ["x64"]
        },
        {
          "target": "deb",
          "arch": ["x64"]
        },
        {
          "target": "rpm",
          "arch": ["x64"]
        }
      ],
      "icon": "assets/icon.png",
      "category": "Office"
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true,
      "createDesktopShortcut": true,
      "createStartMenuShortcut": true,
      "shortcutName": "My Electron App"
    },
    "publish": [
      {
        "provider": "github",
        "owner": "your-username",
        "repo": "your-repo",
        "private": false
      }
    ]
  }
}
```

```javascript
// è‡ªåŠ¨åŒ–æ„å»ºè„šæœ¬
// scripts/build.js
const builder = require('electron-builder');
const fs = require('fs');
const path = require('path');

class BuildManager {
  constructor() {
    this.platforms = {
      win: builder.Platform.WINDOWS,
      mac: builder.Platform.MAC,
      linux: builder.Platform.LINUX
    };
  }

  async buildForPlatform(platform, arch = 'x64') {
    console.log(`Building for ${platform} (${arch})...`);

    const config = this.getBuildConfig(platform, arch);

    try {
      const result = await builder.build({
        targets: builder.createTargets([this.platforms[platform]], null, arch),
        config
      });

      console.log(`Build completed for ${platform}:`, result);
      return result;
    } catch (error) {
      console.error(`Build failed for ${platform}:`, error);
      throw error;
    }
  }

  getBuildConfig(platform, arch) {
    const baseConfig = require('../package.json').build;

    // å¹³å°ç‰¹å®šé…ç½®
    const platformConfig = {
      win: {
        ...baseConfig.win,
        target: [{ target: 'nsis', arch }]
      },
      mac: {
        ...baseConfig.mac,
        target: [{ target: 'dmg', arch }]
      },
      linux: {
        ...baseConfig.linux,
        target: [{ target: 'AppImage', arch }]
      }
    };

    return {
      ...baseConfig,
      [platform]: platformConfig[platform]
    };
  }

  async buildAll() {
    const platforms = ['win', 'mac', 'linux'];
    const results = [];

    for (const platform of platforms) {
      try {
        const result = await this.buildForPlatform(platform);
        results.push({ platform, success: true, result });
      } catch (error) {
        results.push({ platform, success: false, error });
      }
    }

    return results;
  }

  async generateChecksums(outputDir) {
    const crypto = require('crypto');
    const files = fs.readdirSync(outputDir);
    const checksums = {};

    for (const file of files) {
      if (file.endsWith('.exe') || file.endsWith('.dmg') || file.endsWith('.AppImage')) {
        const filePath = path.join(outputDir, file);
        const fileBuffer = fs.readFileSync(filePath);
        const hash = crypto.createHash('sha256').update(fileBuffer).digest('hex');
        checksums[file] = hash;
      }
    }

    fs.writeFileSync(
      path.join(outputDir, 'checksums.json'),
      JSON.stringify(checksums, null, 2)
    );

    return checksums;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const buildManager = new BuildManager();

async function main() {
  const platform = process.argv[2];

  if (platform && ['win', 'mac', 'linux'].includes(platform)) {
    await buildManager.buildForPlatform(platform);
  } else {
    console.log('Building for all platforms...');
    const results = await buildManager.buildAll();
    console.log('Build results:', results);

    // ç”Ÿæˆæ ¡éªŒå’Œ
    await buildManager.generateChecksums('./dist-packages');
  }
}

main().catch(console.error);
```

### Tauriåº”ç”¨æ‰“åŒ…

```toml
# src-tauri/tauri.conf.json
{
  "package": {
    "productName": "My Tauri App",
    "version": "1.0.0"
  },
  "build": {
    "distDir": "../dist",
    "devPath": "http://localhost:3000",
    "beforeDevCommand": "npm run dev",
    "beforeBuildCommand": "npm run build"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "fs": {
        "all": false,
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "copyFile": true,
        "createDir": true,
        "removeDir": true,
        "removeFile": true,
        "renameFile": true
      },
      "dialog": {
        "all": false,
        "open": true,
        "save": true,
        "message": true,
        "ask": true,
        "confirm": true
      },
      "notification": {
        "all": true
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.example.myapp",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": ["assets/*"],
      "externalBin": [],
      "copyright": "Copyright Â© 2023 Your Company",
      "category": "DeveloperTool",
      "shortDescription": "A Tauri App",
      "longDescription": "A longer description of the Tauri app",
      "deb": {
        "depends": []
      },
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "10.13",
        "exceptionDomain": "",
        "signingIdentity": null,
        "providerShortName": null,
        "entitlements": null
      },
      "windows": {
        "certificateThumbprint": null,
        "digestAlgorithm": "sha256",
        "timestampUrl": ""
      }
    },
    "security": {
      "csp": "default-src 'self'; img-src 'self' asset: https://asset.localhost"
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 600,
        "resizable": true,
        "title": "My Tauri App",
        "width": 800,
        "minWidth": 400,
        "minHeight": 300
      }
    ]
  }
}
```

```bash
# Tauriæ„å»ºè„šæœ¬
#!/bin/bash

# build.sh
set -e

echo "Building Tauri application..."

# æ¸…ç†ä¹‹å‰çš„æ„å»º
rm -rf src-tauri/target/release/bundle

# æ„å»ºå‰ç«¯
echo "Building frontend..."
npm run build

# æ„å»ºTauriåº”ç”¨
echo "Building Tauri app..."
cd src-tauri

# ä¸ºä¸åŒå¹³å°æ„å»º
if [[ "$1" == "windows" ]]; then
    cargo tauri build --target x86_64-pc-windows-msvc
elif [[ "$1" == "macos" ]]; then
    cargo tauri build --target x86_64-apple-darwin
    cargo tauri build --target aarch64-apple-darwin
elif [[ "$1" == "linux" ]]; then
    cargo tauri build --target x86_64-unknown-linux-gnu
else
    # é»˜è®¤æ„å»ºå½“å‰å¹³å°
    cargo tauri build
fi

echo "Build completed!"

# ç”Ÿæˆæ ¡éªŒå’Œ
echo "Generating checksums..."
cd target/release/bundle

for dir in */; do
    if [ -d "$dir" ]; then
        cd "$dir"
        for file in *; do
            if [ -f "$file" ]; then
                sha256sum "$file" >> ../checksums.txt
            fi
        done
        cd ..
    fi
done

echo "Checksums generated in target/release/bundle/checksums.txt"
```

### æŒç»­é›†æˆå’Œè‡ªåŠ¨å‘å¸ƒ

```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build frontend
      run: npm run build

    - name: Setup Rust (for Tauri)
      if: matrix.os != 'ubuntu-latest'
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable

    - name: Install Tauri dependencies (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y libgtk-3-dev webkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev patchelf

    - name: Build Tauri app
      run: npm run tauri build

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: app-${{ matrix.os }}
        path: |
          src-tauri/target/release/bundle/
          !src-tauri/target/release/bundle/**/deps/

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
    - uses: actions/checkout@v3

    - name: Download all artifacts
      uses: actions/download-artifact@v3

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          app-ubuntu-latest/**/*
          app-windows-latest/**/*
          app-macos-latest/**/*
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

---

<Callout type="success">
æ¡Œé¢åº”ç”¨å¼€å‘ä¸ºWebæŠ€æœ¯æä¾›äº†æ–°çš„åº”ç”¨åœºæ™¯ï¼Œé€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œå¯ä»¥åˆ›å»ºå‡ºåª²ç¾åŸç”Ÿåº”ç”¨çš„æ¡Œé¢è½¯ä»¶ã€‚
</Callout>

---

## ğŸ“š å‚è€ƒå­¦ä¹ èµ„æ–™

### ğŸ“– å®˜æ–¹æ–‡æ¡£
- [Electron å®˜æ–¹æ–‡æ¡£](https://www.electronjs.org/) - Electronæƒå¨å­¦ä¹ èµ„æº
- [Tauri å®˜æ–¹æ–‡æ¡£](https://tauri.app/) - Tauriç°ä»£æ¡Œé¢åº”ç”¨æ¡†æ¶
- [Electron Builder](https://www.electron.build/) - Electronåº”ç”¨æ‰“åŒ…å·¥å…·
- [Electron Forge](https://www.electronforge.io/) - Electronå¼€å‘å·¥å…·é“¾

### ğŸ“ ä¼˜è´¨æ•™ç¨‹
- [Electron å®˜æ–¹æ•™ç¨‹](https://www.electronjs.org/docs/latest/tutorial/tutorial-prerequisites) - å®˜æ–¹å…¥é—¨æ•™ç¨‹
- [Tauri æŒ‡å—](https://tauri.app/v1/guides/) - Tauriå¼€å‘æŒ‡å—
- [Desktop App Development](https://www.udemy.com/course/electron-react/) - æ¡Œé¢åº”ç”¨å¼€å‘è¯¾ç¨‹

### ğŸ› ï¸ å®è·µé¡¹ç›®
- [Electron Apps](https://www.electronjs.org/apps) - Electronåº”ç”¨å±•ç¤º
- [Awesome Electron](https://github.com/sindresorhus/awesome-electron) - Electronèµ„æºé›†åˆ
- [Tauri Examples](https://github.com/tauri-apps/tauri/tree/dev/examples) - Tauriå®˜æ–¹ç¤ºä¾‹

### ğŸ”§ å¼€å‘å·¥å…·
- [Electron DevTools](https://www.electronjs.org/docs/latest/tutorial/devtools-extension) - Electronè°ƒè¯•å·¥å…·
- [Electron Packager](https://github.com/electron/electron-packager) - åº”ç”¨æ‰“åŒ…å·¥å…·
- [Tauri CLI](https://tauri.app/v1/guides/getting-started/setup/) - Tauriå‘½ä»¤è¡Œå·¥å…·
- [Electron Updater](https://github.com/electron-userland/electron-updater) - è‡ªåŠ¨æ›´æ–°å·¥å…·

### ğŸ“ æ·±å…¥é˜…è¯»
- [Electron Security](https://www.electronjs.org/docs/latest/tutorial/security) - Electronå®‰å…¨æœ€ä½³å®è·µ
- [Desktop App Performance](https://blog.logrocket.com/electron-performance-optimization/) - æ¡Œé¢åº”ç”¨æ€§èƒ½ä¼˜åŒ–
- [Cross-Platform Development](https://tauri.app/v1/guides/building/cross-platform/) - è·¨å¹³å°å¼€å‘æŒ‡å—

<Callout type="tip">
ğŸ’¡ **å­¦ä¹ å»ºè®®**ï¼šå»ºè®®ä»Electronå¼€å§‹å­¦ä¹ æ¡Œé¢åº”ç”¨å¼€å‘åŸºç¡€ï¼Œç„¶åæ¢ç´¢Tauriç­‰ç°ä»£åŒ–æ–¹æ¡ˆï¼Œé‡ç‚¹å…³æ³¨å®‰å…¨æ€§å’Œæ€§èƒ½ä¼˜åŒ–ã€‚
</Callout>

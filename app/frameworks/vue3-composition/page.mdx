import { Callout } from 'nextra/components'

# 08. Vue3深入和组合式API

## 📋 目录

- [Vue3架构革新](#vue3架构革新)
- [响应式系统原理](#响应式系统原理)
- [Composition API深入](#composition-api深入)
- [组件通信和状态管理](#组件通信和状态管理)
- [Vue3性能优化](#vue3性能优化)
- [Vue3生态系统](#vue3生态系统)

## Vue3架构革新

<Callout type="info">
[Vue3](https://vuejs.org/)带来了全新的架构设计，包括[Composition API](https://vuejs.org/guide/extras/composition-api-faq.html)、更好的[TypeScript](https://www.typescriptlang.org/)支持、Tree-shaking友好的设计等重大改进。
</Callout>

### Vue3 vs Vue2 核心差异

```javascript
// Vue2 Options API
export default {
  data() {
    return {
      count: 0,
      user: null
    }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    }
  },
  methods: {
    increment() {
      this.count++
    },
    async fetchUser() {
      this.user = await api.getUser()
    }
  },
  mounted() {
    this.fetchUser()
  }
}

// Vue3 Composition API
import { ref, computed, onMounted } from 'vue'

export default {
  setup() {
    const count = ref(0)
    const user = ref(null)
    
    const doubleCount = computed(() => count.value * 2)
    
    const increment = () => {
      count.value++
    }
    
    const fetchUser = async () => {
      user.value = await api.getUser()
    }
    
    onMounted(() => {
      fetchUser()
    })
    
    return {
      count,
      user,
      doubleCount,
      increment,
      fetchUser
    }
  }
}
```

### Vue3新特性概览

```vue
<!-- Vue3 新特性示例 -->
<template>
  <!-- 1. Fragment - 多个根节点 -->
  <header>头部内容</header>
  <main>主要内容</main>
  <footer>底部内容</footer>
  
  <!-- 2. Teleport - 传送门 -->
  <Teleport to="body">
    <div class="modal">模态框内容</div>
  </Teleport>
  
  <!-- 3. Suspense - 异步组件 -->
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <div>加载中...</div>
    </template>
  </Suspense>
</template>

<script setup>
// 4. <script setup> 语法糖
import { ref, computed, watch, onMounted } from 'vue'
import AsyncComponent from './AsyncComponent.vue'

// 响应式数据
const count = ref(0)
const message = ref('Hello Vue3!')

// 计算属性
const doubleCount = computed(() => count.value * 2)

// 侦听器
watch(count, (newVal, oldVal) => {
  console.log(`count changed from ${oldVal} to ${newVal}`)
})

// 生命周期
onMounted(() => {
  console.log('组件已挂载')
})

// 方法
const increment = () => {
  count.value++
}

// 自动暴露给模板
defineExpose({
  increment,
  count
})
</script>
```

## 响应式系统原理

### Proxy vs Object.defineProperty

<Callout type="warning">
Vue3使用Proxy替代了Vue2的Object.defineProperty，解决了数组和对象属性动态添加的响应式问题。
</Callout>

```javascript
// Vue2 响应式实现（简化版）
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      // 依赖收集
      if (Dep.target) {
        dep.depend()
      }
      return val
    },
    set(newVal) {
      if (newVal === val) return
      val = newVal
      // 通知更新
      dep.notify()
    }
  })
}

// Vue3 响应式实现（简化版）
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver)
      
      // 依赖收集
      track(target, key)
      
      // 如果是对象，递归代理
      if (typeof result === 'object' && result !== null) {
        return reactive(result)
      }
      
      return result
    },
    
    set(target, key, value, receiver) {
      const oldValue = target[key]
      const result = Reflect.set(target, key, value, receiver)
      
      // 触发更新
      if (oldValue !== value) {
        trigger(target, key)
      }
      
      return result
    },
    
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key)
      const result = Reflect.deleteProperty(target, key)
      
      if (result && hadKey) {
        trigger(target, key)
      }
      
      return result
    }
  })
}

// 依赖收集和触发更新
let activeEffect = null
const targetMap = new WeakMap()

function track(target, key) {
  if (!activeEffect) return
  
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  
  dep.add(activeEffect)
}

function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  
  const dep = depsMap.get(key)
  if (dep) {
    dep.forEach(effect => effect())
  }
}

function effect(fn) {
  activeEffect = fn
  fn()
  activeEffect = null
}
```

### 响应式API详解

```javascript
// 1. ref - 基本类型响应式
import { ref, isRef, unref, toRef, toRefs } from 'vue'

const count = ref(0)
const message = ref('hello')

console.log(count.value) // 0
count.value++ // 触发响应式更新

// ref 判断和解包
console.log(isRef(count)) // true
console.log(unref(count)) // 1，等同于 count.value

// 2. reactive - 对象响应式
import { reactive, isReactive, toRaw, markRaw } from 'vue'

const state = reactive({
  count: 0,
  nested: {
    message: 'hello'
  }
})

// 深度响应式
state.nested.message = 'world' // 触发更新

// 响应式判断
console.log(isReactive(state)) // true
console.log(isReactive(state.nested)) // true

// 获取原始对象
const raw = toRaw(state)
console.log(raw === state) // false

// 标记为非响应式
const nonReactive = markRaw({ foo: 'bar' })
const reactiveObj = reactive({ nonReactive })
console.log(isReactive(reactiveObj.nonReactive)) // false

// 3. computed - 计算属性
import { computed } from 'vue'

const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2
count.value++
console.log(plusOne.value) // 3

// 可写计算属性
const writableComputed = computed({
  get: () => count.value + 1,
  set: (val) => {
    count.value = val - 1
  }
})

writableComputed.value = 10
console.log(count.value) // 9

// 4. watch 和 watchEffect
import { watch, watchEffect } from 'vue'

const state = reactive({ count: 0 })

// 侦听单个源
watch(() => state.count, (newVal, oldVal) => {
  console.log(`count: ${oldVal} -> ${newVal}`)
})

// 侦听多个源
watch([() => state.count, () => state.name], ([newCount, newName], [oldCount, oldName]) => {
  console.log('多个值发生变化')
})

// 立即执行的侦听器
watchEffect(() => {
  console.log(`count is ${state.count}`)
})

// 停止侦听
const stop = watchEffect(() => {
  console.log('这个侦听器可以被停止')
})

// 停止侦听
stop()
```

## Composition API深入

### 组合式函数（Composables）

<Callout type="info">
组合式函数是Vue3的核心特性，它允许我们将相关的逻辑组合在一起，提高代码的复用性和可维护性。
</Callout>

```javascript
// 1. useCounter - 计数器组合式函数
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  const count = ref(initialValue)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = initialValue
  
  const isEven = computed(() => count.value % 2 === 0)
  const isPositive = computed(() => count.value > 0)
  
  return {
    count: readonly(count), // 只读，防止外部直接修改
    increment,
    decrement,
    reset,
    isEven,
    isPositive
  }
}

// 2. useFetch - 数据获取组合式函数
import { ref, watchEffect } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(false)
  
  const fetchData = async () => {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch(url.value || url)
      data.value = await response.json()
    } catch (err) {
      error.value = err
    } finally {
      loading.value = false
    }
  }
  
  // 如果url是响应式的，自动重新获取
  if (isRef(url)) {
    watchEffect(fetchData)
  } else {
    fetchData()
  }
  
  return {
    data: readonly(data),
    error: readonly(error),
    loading: readonly(loading),
    refetch: fetchData
  }
}

// 3. useLocalStorage - 本地存储组合式函数
import { ref, watch } from 'vue'

export function useLocalStorage(key, defaultValue) {
  const storedValue = localStorage.getItem(key)
  const initialValue = storedValue ? JSON.parse(storedValue) : defaultValue
  
  const value = ref(initialValue)
  
  // 监听值的变化，同步到localStorage
  watch(value, (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue))
  }, { deep: true })
  
  // 监听localStorage的变化（其他标签页修改）
  window.addEventListener('storage', (e) => {
    if (e.key === key && e.newValue) {
      value.value = JSON.parse(e.newValue)
    }
  })
  
  return value
}

// 4. useEventListener - 事件监听组合式函数
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, handler, options) {
  onMounted(() => {
    target.addEventListener(event, handler, options)
  })
  
  onUnmounted(() => {
    target.removeEventListener(event, handler, options)
  })
}

// 5. useIntersectionObserver - 交叉观察器组合式函数
import { ref, onMounted, onUnmounted } from 'vue'

export function useIntersectionObserver(target, options = {}) {
  const isIntersecting = ref(false)
  const entries = ref([])
  
  let observer = null
  
  onMounted(() => {
    observer = new IntersectionObserver((observerEntries) => {
      entries.value = observerEntries
      isIntersecting.value = observerEntries.some(entry => entry.isIntersecting)
    }, options)
    
    if (target.value) {
      observer.observe(target.value)
    }
  })
  
  onUnmounted(() => {
    if (observer) {
      observer.disconnect()
    }
  })
  
  return {
    isIntersecting: readonly(isIntersecting),
    entries: readonly(entries)
  }
}

// 使用示例
export default {
  setup() {
    // 使用计数器
    const { count, increment, decrement, isEven } = useCounter(10)
    
    // 使用数据获取
    const { data: users, loading, error } = useFetch('/api/users')
    
    // 使用本地存储
    const theme = useLocalStorage('theme', 'light')
    
    // 使用事件监听
    useEventListener(window, 'resize', () => {
      console.log('窗口大小改变')
    })
    
    return {
      count,
      increment,
      decrement,
      isEven,
      users,
      loading,
      error,
      theme
    }
  }
}
```

### 高级组合模式

```javascript
// 1. 状态机组合式函数
export function useStateMachine(initialState, transitions) {
  const state = ref(initialState)
  
  const transition = (action) => {
    const currentTransitions = transitions[state.value]
    if (currentTransitions && currentTransitions[action]) {
      state.value = currentTransitions[action]
    }
  }
  
  const can = (action) => {
    const currentTransitions = transitions[state.value]
    return currentTransitions && currentTransitions[action] !== undefined
  }
  
  return {
    state: readonly(state),
    transition,
    can
  }
}

// 使用状态机
const { state, transition, can } = useStateMachine('idle', {
  idle: { start: 'loading' },
  loading: { success: 'success', error: 'error' },
  success: { reset: 'idle' },
  error: { retry: 'loading', reset: 'idle' }
})

// 2. 表单验证组合式函数
export function useFormValidation(rules) {
  const errors = ref({})
  const isValid = computed(() => Object.keys(errors.value).length === 0)
  
  const validate = (field, value) => {
    const fieldRules = rules[field]
    if (!fieldRules) return true
    
    for (const rule of fieldRules) {
      const result = rule.validator(value)
      if (!result) {
        errors.value[field] = rule.message
        return false
      }
    }
    
    delete errors.value[field]
    return true
  }
  
  const validateAll = (values) => {
    let allValid = true
    for (const [field, value] of Object.entries(values)) {
      if (!validate(field, value)) {
        allValid = false
      }
    }
    return allValid
  }
  
  const clearErrors = () => {
    errors.value = {}
  }
  
  return {
    errors: readonly(errors),
    isValid,
    validate,
    validateAll,
    clearErrors
  }
}

// 3. 无限滚动组合式函数
export function useInfiniteScroll(fetchMore, options = {}) {
  const {
    distance = 100,
    disabled = false
  } = options
  
  const loading = ref(false)
  const finished = ref(false)
  
  const checkScroll = () => {
    if (loading.value || finished.value || disabled) return
    
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement
    
    if (scrollTop + clientHeight >= scrollHeight - distance) {
      loading.value = true
      
      fetchMore()
        .then((hasMore) => {
          if (!hasMore) {
            finished.value = true
          }
        })
        .finally(() => {
          loading.value = false
        })
    }
  }
  
  useEventListener(window, 'scroll', checkScroll)
  
  return {
    loading: readonly(loading),
    finished: readonly(finished)
  }
}
```

## 组件通信和状态管理

### 组件通信方式

```vue
<!-- 1. Props 和 Emits -->
<!-- 父组件 -->
<template>
  <ChildComponent 
    :message="parentMessage"
    :count="count"
    @update:count="handleCountUpdate"
    @custom-event="handleCustomEvent"
  />
</template>

<script setup>
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentMessage = ref('来自父组件的消息')
const count = ref(0)

const handleCountUpdate = (newCount) => {
  count.value = newCount
}

const handleCustomEvent = (data) => {
  console.log('收到自定义事件:', data)
}
</script>

<!-- 子组件 -->
<template>
  <div>
    <p>{{ message }}</p>
    <p>Count: {{ count }}</p>
    <button @click="updateCount">更新计数</button>
    <button @click="emitCustomEvent">发送自定义事件</button>
  </div>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue'

// 定义props
const props = defineProps({
  message: {
    type: String,
    required: true
  },
  count: {
    type: Number,
    default: 0
  }
})

// 定义emits
const emit = defineEmits(['update:count', 'custom-event'])

const updateCount = () => {
  emit('update:count', props.count + 1)
}

const emitCustomEvent = () => {
  emit('custom-event', { timestamp: Date.now() })
}
</script>

<!-- 2. Provide/Inject -->
<!-- 祖先组件 -->
<script setup>
import { provide, ref } from 'vue'

const theme = ref('dark')
const user = ref({ name: 'John', role: 'admin' })

// 提供数据
provide('theme', theme)
provide('user', readonly(user))

// 提供方法
provide('updateTheme', (newTheme) => {
  theme.value = newTheme
})
</script>

<!-- 后代组件 -->
<script setup>
import { inject } from 'vue'

// 注入数据
const theme = inject('theme')
const user = inject('user')
const updateTheme = inject('updateTheme')

// 使用默认值
const config = inject('config', { api: '/api' })
</script>

<!-- 3. 模板引用 -->
<template>
  <ChildComponent ref="childRef" />
  <button @click="callChildMethod">调用子组件方法</button>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const childRef = ref()

const callChildMethod = () => {
  childRef.value.someMethod()
}

onMounted(() => {
  console.log(childRef.value) // 子组件实例
})
</script>
```

### Pinia状态管理

```javascript
// stores/counter.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// Option Store
export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
    name: 'Eduardo'
  }),
  
  getters: {
    doubleCount: (state) => state.count * 2,
    doubleCountPlusOne() {
      return this.doubleCount + 1
    }
  },
  
  actions: {
    increment() {
      this.count++
    },
    
    async fetchUserData() {
      const userData = await api.getUser()
      this.name = userData.name
    }
  }
})

// Composition Store
export const useCounterStore = defineStore('counter', () => {
  // state
  const count = ref(0)
  const name = ref('Eduardo')
  
  // getters
  const doubleCount = computed(() => count.value * 2)
  
  // actions
  function increment() {
    count.value++
  }
  
  async function fetchUserData() {
    const userData = await api.getUser()
    name.value = userData.name
  }
  
  return {
    count,
    name,
    doubleCount,
    increment,
    fetchUserData
  }
})

// 在组件中使用
<script setup>
import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'

const store = useCounterStore()

// 解构响应式数据
const { count, name, doubleCount } = storeToRefs(store)

// 解构actions（不需要storeToRefs）
const { increment, fetchUserData } = store

// 直接使用
store.count++
store.$patch({ count: store.count + 1 })
store.$patch((state) => {
  state.count++
  state.name = 'New Name'
})
</script>
```

## Vue3性能优化

<Callout type="info">
Vue3在性能方面有显著提升，包括更小的包体积、更快的渲染速度和更好的Tree-shaking支持。
</Callout>

### 编译时优化

```vue
<template>
  <!-- 静态提升 - 静态元素会被提升到渲染函数外部 -->
  <div class="static-class">
    <h1>静态标题</h1>
    <!-- 动态内容 -->
    <p>{{ message }}</p>

    <!-- 补丁标记 - Vue3会标记动态内容 -->
    <div :class="dynamicClass">{{ count }}</div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const message = ref('Hello Vue3')
const count = ref(0)
const dynamicClass = computed(() => count.value > 10 ? 'large' : 'small')
</script>
```

### 响应式优化

```javascript
// 使用shallowRef减少深度响应式开销
import { shallowRef, triggerRef } from 'vue'

const state = shallowRef({
  count: 0,
  nested: {
    value: 'hello'
  }
})

// 手动触发更新
function updateNested() {
  state.value.nested.value = 'world'
  triggerRef(state) // 手动触发响应式更新
}

// 使用markRaw避免响应式转换
import { markRaw, reactive } from 'vue'

const state = reactive({
  foo: markRaw({
    // 这个对象不会被转换为响应式
    nestedProperty: 'value'
  })
})
```

### 组件优化

```vue
<!-- 使用v-memo缓存子树 -->
<template>
  <div v-for="item in list" :key="item.id" v-memo="[item.id, item.selected]">
    <p>{{ item.name }}</p>
    <p>{{ item.description }}</p>
  </div>
</template>

<script setup>
// 使用defineAsyncComponent异步加载组件
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
})
</script>
```

## Vue3生态系统

<Callout type="info">
Vue3拥有丰富的生态系统，包括官方工具、第三方库和开发工具。
</Callout>

### 官方工具链

```bash
# Vite - 官方构建工具
npm create vue@latest my-vue-app
cd my-vue-app
npm install
npm run dev

# Vue CLI (传统方式)
npm install -g @vue/cli
vue create my-project
```

### 路由管理

```javascript
// Vue Router 4
import { createRouter, createWebHistory } from 'vue-router'
import { defineAsyncComponent } from 'vue'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      name: 'Home',
      component: () => import('./views/Home.vue')
    },
    {
      path: '/about',
      name: 'About',
      component: defineAsyncComponent(() => import('./views/About.vue'))
    },
    {
      path: '/user/:id',
      name: 'User',
      component: () => import('./views/User.vue'),
      props: true
    }
  ]
})

export default router
```

### 状态管理

```javascript
// Pinia - 官方状态管理库
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
    name: 'Eduardo'
  }),

  getters: {
    doubleCount: (state) => state.count * 2
  },

  actions: {
    increment() {
      this.count++
    },

    async fetchUserData(userId) {
      try {
        const userData = await api.getUser(userId)
        this.name = userData.name
      } catch (error) {
        console.error('Failed to fetch user:', error)
      }
    }
  }
})

// 在组件中使用
import { useCounterStore } from '@/stores/counter'

const counter = useCounterStore()
counter.increment()
```

### UI组件库

```javascript
// Element Plus
import { createApp } from 'vue'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)
app.use(ElementPlus)

// Ant Design Vue
import { createApp } from 'vue'
import Antd from 'ant-design-vue'
import 'ant-design-vue/dist/antd.css'

const app = createApp(App)
app.use(Antd)

// Vuetify 3
import { createApp } from 'vue'
import { createVuetify } from 'vuetify'
import 'vuetify/styles'

const vuetify = createVuetify()
const app = createApp(App)
app.use(vuetify)
```

### 开发工具

```javascript
// Vue DevTools
// 浏览器扩展，支持Vue3的Composition API调试

// Volar - VS Code扩展
// 提供Vue3和TypeScript的完整支持

// 测试工具
import { mount } from '@vue/test-utils'
import { describe, it, expect } from 'vitest'
import MyComponent from './MyComponent.vue'

describe('MyComponent', () => {
  it('renders properly', () => {
    const wrapper = mount(MyComponent, {
      props: { msg: 'Hello Vitest' }
    })
    expect(wrapper.text()).toContain('Hello Vitest')
  })
})
```

---

<Callout type="success">
Vue3的Composition API和响应式系统为我们提供了更灵活、更强大的开发体验。通过合理使用组合式函数，我们可以构建更加模块化和可复用的代码。
</Callout>

---

## 📚 参考学习资料

### 📖 官方文档
- [Vue3 官方文档](https://vuejs.org/) - Vue3权威学习资源
- [Vue3 API 参考](https://vuejs.org/api/) - 完整API文档
- [Vue Router 4](https://router.vuejs.org/) - 官方路由管理
- [Pinia](https://pinia.vuejs.org/) - 官方状态管理库

### 🎓 优质教程
- [Vue3 官方教程](https://vuejs.org/tutorial/) - 官方交互式教程
- [Vue Mastery](https://www.vuemastery.com/) - Vue专业课程平台
- [Vue School](https://vueschool.io/) - Vue在线学习平台

### 🛠️ 实践项目
- [Vue3 示例项目](https://github.com/vuejs/petite-vue) - 官方示例
- [Awesome Vue](https://github.com/vuejs/awesome-vue) - Vue资源集合
- [Vue3 最佳实践](https://github.com/vuejs/vue-next) - 官方仓库

### 🔧 开发工具
- [Vite](https://vitejs.dev/) - 官方构建工具
- [Vue CLI](https://cli.vuejs.org/) - 传统脚手架工具
- [Vue DevTools](https://devtools.vuejs.org/) - 官方调试工具
- [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) - VS Code扩展

### 📝 深入阅读
- [Vue3 设计理念](https://vuejs.org/guide/extras/composition-api-faq.html) - Composition API设计思路
- [Vue3 响应式原理](https://vuejs.org/guide/extras/reactivity-in-depth.html) - 响应式系统深入
- [Vue3 性能优化](https://vuejs.org/guide/best-practices/performance.html) - 官方性能指南

<Callout type="tip">
💡 **学习建议**：建议从官方文档开始，通过Vite创建项目实践，然后深入学习Composition API和响应式系统，最后了解Vue3生态系统。
</Callout>

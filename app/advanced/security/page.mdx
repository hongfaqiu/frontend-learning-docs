import { Callout } from 'nextra/components'

# 17. å‰ç«¯å®‰å…¨å’Œæœ€ä½³å®è·µ

## ğŸ“‹ ç›®å½•

- [å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ](#å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ)
- [XSSæ”»å‡»é˜²æŠ¤](#xssæ”»å‡»é˜²æŠ¤)
- [CSRFæ”»å‡»é˜²æŠ¤](#csrfæ”»å‡»é˜²æŠ¤)
- [å†…å®¹å®‰å…¨ç­–ç•¥CSP](#å†…å®¹å®‰å…¨ç­–ç•¥csp)
- [æ•°æ®ä¼ è¾“å®‰å…¨](#æ•°æ®ä¼ è¾“å®‰å…¨)
- [å®‰å…¨å¼€å‘æœ€ä½³å®è·µ](#å®‰å…¨å¼€å‘æœ€ä½³å®è·µ)

## å‰ç«¯å®‰å…¨å¨èƒæ¦‚è§ˆ

<Callout type="warning">
å‰ç«¯å®‰å…¨æ˜¯[Web](https://developer.mozilla.org/en-US/docs/Web)åº”ç”¨å®‰å…¨çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œäº†è§£å¸¸è§å¨èƒå’Œé˜²æŠ¤æªæ–½å¯¹äºæ„å»ºå®‰å…¨çš„Webåº”ç”¨è‡³å…³é‡è¦ã€‚
</Callout>

### å¸¸è§å®‰å…¨å¨èƒåˆ†ç±»

```javascript
// å‰ç«¯å®‰å…¨å¨èƒåˆ†ç±»å’Œé˜²æŠ¤ç­–ç•¥
const securityThreats = {
  // 1. æ³¨å…¥æ”»å‡»
  injection: {
    types: ['XSS', 'SQLæ³¨å…¥', 'NoSQLæ³¨å…¥', 'LDAPæ³¨å…¥'],
    description: 'æ¶æ„ä»£ç æ³¨å…¥åˆ°åº”ç”¨ä¸­æ‰§è¡Œ',
    impact: 'æ•°æ®æ³„éœ²ã€ä¼šè¯åŠ«æŒã€æ¶æ„æ“ä½œ',
    prevention: [
      'è¾“å…¥éªŒè¯å’Œè¿‡æ»¤',
      'è¾“å‡ºç¼–ç ',
      'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢',
      'å†…å®¹å®‰å…¨ç­–ç•¥'
    ]
  },
  
  // 2. èº«ä»½è®¤è¯ç¼ºé™·
  authentication: {
    types: ['å¼±å¯†ç ', 'ä¼šè¯ç®¡ç†ç¼ºé™·', 'æš´åŠ›ç ´è§£'],
    description: 'èº«ä»½éªŒè¯æœºåˆ¶å­˜åœ¨æ¼æ´',
    impact: 'è´¦æˆ·è¢«ç›—ã€æœªæˆæƒè®¿é—®',
    prevention: [
      'å¼ºå¯†ç ç­–ç•¥',
      'å¤šå› ç´ è®¤è¯',
      'ä¼šè¯è¶…æ—¶',
      'è´¦æˆ·é”å®šæœºåˆ¶'
    ]
  },
  
  // 3. æ•æ„Ÿæ•°æ®æš´éœ²
  dataExposure: {
    types: ['æ˜æ–‡ä¼ è¾“', 'ä¸å½“å­˜å‚¨', 'ç¼“å­˜æ³„éœ²'],
    description: 'æ•æ„Ÿæ•°æ®æœªå¾—åˆ°é€‚å½“ä¿æŠ¤',
    impact: 'éšç§æ³„éœ²ã€åˆè§„é£é™©',
    prevention: [
      'HTTPSä¼ è¾“',
      'æ•°æ®åŠ å¯†',
      'å®‰å…¨å­˜å‚¨',
      'è®¿é—®æ§åˆ¶'
    ]
  },
  
  // 4. è·¨ç«™è¯·æ±‚ä¼ªé€ 
  csrf: {
    types: ['GETå‹CSRF', 'POSTå‹CSRF', 'JSON CSRF'],
    description: 'è¯±å¯¼ç”¨æˆ·æ‰§è¡Œéé¢„æœŸæ“ä½œ',
    impact: 'æ¶æ„æ“ä½œã€æ•°æ®ç¯¡æ”¹',
    prevention: [
      'CSRF Token',
      'SameSite Cookie',
      'éªŒè¯Referer',
      'åŒé‡æäº¤Cookie'
    ]
  },
  
  // 5. å®‰å…¨é…ç½®é”™è¯¯
  misconfiguration: {
    types: ['é»˜è®¤é…ç½®', 'é”™è¯¯æƒé™', 'è°ƒè¯•ä¿¡æ¯æ³„éœ²'],
    description: 'å®‰å…¨é…ç½®ä¸å½“å¯¼è‡´çš„æ¼æ´',
    impact: 'ç³»ç»Ÿæš´éœ²ã€ä¿¡æ¯æ³„éœ²',
    prevention: [
      'å®‰å…¨é…ç½®æ£€æŸ¥',
      'æœ€å°æƒé™åŸåˆ™',
      'å®šæœŸå®‰å…¨å®¡è®¡',
      'é”™è¯¯å¤„ç†ä¼˜åŒ–'
    ]
  }
};

// å®‰å…¨è¯„ä¼°å·¥å…·
class SecurityAssessment {
  constructor() {
    this.vulnerabilities = [];
    this.securityScore = 0;
  }
  
  // æ‰§è¡Œå®‰å…¨è¯„ä¼°
  async performAssessment() {
    console.log('å¼€å§‹å®‰å…¨è¯„ä¼°...');
    
    await this.checkXSSVulnerabilities();
    await this.checkCSRFProtection();
    await this.checkHTTPSUsage();
    await this.checkContentSecurityPolicy();
    await this.checkCookieSecurity();
    await this.checkDependencyVulnerabilities();
    
    this.calculateSecurityScore();
    return this.generateReport();
  }
  
  async checkXSSVulnerabilities() {
    // æ£€æŸ¥æ½œåœ¨çš„XSSæ¼æ´
    const inputs = document.querySelectorAll('input, textarea');
    const outputs = document.querySelectorAll('[data-user-content]');
    
    inputs.forEach(input => {
      if (!input.hasAttribute('data-sanitized')) {
        this.vulnerabilities.push({
          type: 'XSS',
          severity: 'high',
          element: input,
          description: 'ç”¨æˆ·è¾“å…¥æœªè¿›è¡Œé€‚å½“çš„éªŒè¯å’Œè¿‡æ»¤'
        });
      }
    });
    
    outputs.forEach(output => {
      if (output.innerHTML.includes('<script>')) {
        this.vulnerabilities.push({
          type: 'XSS',
          severity: 'critical',
          element: output,
          description: 'æ£€æµ‹åˆ°å¯èƒ½çš„è„šæœ¬æ³¨å…¥'
        });
      }
    });
  }
  
  async checkCSRFProtection() {
    // æ£€æŸ¥CSRFä¿æŠ¤
    const forms = document.querySelectorAll('form');
    
    forms.forEach(form => {
      const csrfToken = form.querySelector('input[name="csrf_token"], input[name="_token"]');
      if (!csrfToken && form.method.toLowerCase() === 'post') {
        this.vulnerabilities.push({
          type: 'CSRF',
          severity: 'medium',
          element: form,
          description: 'POSTè¡¨å•ç¼ºå°‘CSRFä»¤ç‰Œä¿æŠ¤'
        });
      }
    });
  }
  
  async checkHTTPSUsage() {
    // æ£€æŸ¥HTTPSä½¿ç”¨æƒ…å†µ
    if (location.protocol !== 'https:') {
      this.vulnerabilities.push({
        type: 'Transport Security',
        severity: 'high',
        description: 'ç½‘ç«™æœªä½¿ç”¨HTTPSåŠ å¯†ä¼ è¾“'
      });
    }
    
    // æ£€æŸ¥æ··åˆå†…å®¹
    const resources = performance.getEntriesByType('resource');
    resources.forEach(resource => {
      if (resource.name.startsWith('http://')) {
        this.vulnerabilities.push({
          type: 'Mixed Content',
          severity: 'medium',
          description: `æ£€æµ‹åˆ°HTTPèµ„æº: ${resource.name}`
        });
      }
    });
  }
  
  async checkContentSecurityPolicy() {
    // æ£€æŸ¥CSPé…ç½®
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = this.getResponseHeader('Content-Security-Policy');
    
    if (!cspMeta && !cspHeader) {
      this.vulnerabilities.push({
        type: 'CSP',
        severity: 'medium',
        description: 'æœªé…ç½®å†…å®¹å®‰å…¨ç­–ç•¥(CSP)'
      });
    }
  }
  
  async checkCookieSecurity() {
    // æ£€æŸ¥Cookieå®‰å…¨å±æ€§
    const cookies = document.cookie.split(';');
    
    cookies.forEach(cookie => {
      const [name] = cookie.trim().split('=');
      
      // è¿™é‡Œç®€åŒ–æ£€æŸ¥ï¼Œå®é™…åº”è¯¥æ£€æŸ¥Set-Cookieå¤´
      if (name && !cookie.includes('Secure')) {
        this.vulnerabilities.push({
          type: 'Cookie Security',
          severity: 'low',
          description: `Cookie ${name} ç¼ºå°‘Secureå±æ€§`
        });
      }
      
      if (name && !cookie.includes('HttpOnly')) {
        this.vulnerabilities.push({
          type: 'Cookie Security',
          severity: 'medium',
          description: `Cookie ${name} ç¼ºå°‘HttpOnlyå±æ€§`
        });
      }
    });
  }
  
  async checkDependencyVulnerabilities() {
    // æ£€æŸ¥å·²çŸ¥çš„ä¾èµ–æ¼æ´ï¼ˆéœ€è¦åç«¯æ”¯æŒï¼‰
    try {
      const response = await fetch('/api/security/check-dependencies');
      const vulnerabilities = await response.json();
      
      vulnerabilities.forEach(vuln => {
        this.vulnerabilities.push({
          type: 'Dependency',
          severity: vuln.severity,
          description: `ä¾èµ– ${vuln.package} å­˜åœ¨å·²çŸ¥æ¼æ´: ${vuln.title}`
        });
      });
    } catch (error) {
      console.warn('æ— æ³•æ£€æŸ¥ä¾èµ–æ¼æ´:', error);
    }
  }
  
  calculateSecurityScore() {
    const severityWeights = {
      critical: 10,
      high: 7,
      medium: 4,
      low: 1
    };
    
    const totalDeductions = this.vulnerabilities.reduce((sum, vuln) => {
      return sum + (severityWeights[vuln.severity] || 0);
    }, 0);
    
    this.securityScore = Math.max(0, 100 - totalDeductions);
  }
  
  generateReport() {
    return {
      score: this.securityScore,
      grade: this.getSecurityGrade(),
      vulnerabilities: this.vulnerabilities,
      summary: {
        total: this.vulnerabilities.length,
        critical: this.vulnerabilities.filter(v => v.severity === 'critical').length,
        high: this.vulnerabilities.filter(v => v.severity === 'high').length,
        medium: this.vulnerabilities.filter(v => v.severity === 'medium').length,
        low: this.vulnerabilities.filter(v => v.severity === 'low').length
      },
      recommendations: this.getRecommendations()
    };
  }
  
  getSecurityGrade() {
    if (this.securityScore >= 90) return 'A';
    if (this.securityScore >= 80) return 'B';
    if (this.securityScore >= 70) return 'C';
    if (this.securityScore >= 60) return 'D';
    return 'F';
  }
  
  getRecommendations() {
    const recommendations = [];
    
    if (this.vulnerabilities.some(v => v.type === 'XSS')) {
      recommendations.push('å®æ–½è¾“å…¥éªŒè¯å’Œè¾“å‡ºç¼–ç ');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'CSRF')) {
      recommendations.push('æ·»åŠ CSRFä»¤ç‰Œä¿æŠ¤');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'Transport Security')) {
      recommendations.push('å¯ç”¨HTTPSå¹¶é…ç½®HSTS');
    }
    
    if (this.vulnerabilities.some(v => v.type === 'CSP')) {
      recommendations.push('é…ç½®å†…å®¹å®‰å…¨ç­–ç•¥(CSP)');
    }
    
    return recommendations;
  }
  
  getResponseHeader(name) {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä»å“åº”å¤´è·å–
    return null;
  }
}
```

## XSSæ”»å‡»é˜²æŠ¤

### XSSé˜²æŠ¤å®ç°

```javascript
// 1. XSSé˜²æŠ¤å·¥å…·ç±»
class XSSProtection {
  constructor() {
    this.htmlEntities = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    
    this.setupGlobalProtection();
  }
  
  // è®¾ç½®å…¨å±€XSSé˜²æŠ¤
  setupGlobalProtection() {
    // é‡å†™innerHTML setter
    this.protectInnerHTML();
    
    // ç›‘æ§åŠ¨æ€å†…å®¹æ’å…¥
    this.monitorDOMChanges();
    
    // ä¿æŠ¤äº‹ä»¶å¤„ç†å™¨
    this.protectEventHandlers();
  }
  
  protectInnerHTML() {
    const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
    
    Object.defineProperty(Element.prototype, 'innerHTML', {
      set: function(value) {
        // æ£€æŸ¥æ˜¯å¦åŒ…å«æ½œåœ¨çš„XSSä»£ç 
        if (typeof value === 'string' && this.containsXSS(value)) {
          console.warn('æ£€æµ‹åˆ°æ½œåœ¨XSSæ”»å‡»ï¼Œå†…å®¹å·²è¢«è¿‡æ»¤');
          value = this.sanitizeHTML(value);
        }
        
        originalInnerHTML.set.call(this, value);
      }.bind(this),
      get: originalInnerHTML.get
    });
  }
  
  containsXSS(html) {
    const xssPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi,
      /<iframe\b[^>]*>/gi,
      /<object\b[^>]*>/gi,
      /<embed\b[^>]*>/gi,
      /<link\b[^>]*>/gi,
      /<meta\b[^>]*>/gi
    ];
    
    return xssPatterns.some(pattern => pattern.test(html));
  }
  
  // HTMLå†…å®¹æ¸…ç†
  sanitizeHTML(html) {
    // ç§»é™¤å±é™©æ ‡ç­¾
    const dangerousTags = [
      'script', 'iframe', 'object', 'embed', 'link', 'meta',
      'form', 'input', 'button', 'textarea', 'select'
    ];
    
    let sanitized = html;
    
    dangerousTags.forEach(tag => {
      const regex = new RegExp(`<${tag}\\b[^>]*>.*?<\\/${tag}>`, 'gi');
      sanitized = sanitized.replace(regex, '');
      
      const selfClosingRegex = new RegExp(`<${tag}\\b[^>]*\\/?>`, 'gi');
      sanitized = sanitized.replace(selfClosingRegex, '');
    });
    
    // ç§»é™¤å±é™©å±æ€§
    sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
    sanitized = sanitized.replace(/javascript:/gi, '');
    
    // HTMLå®ä½“ç¼–ç 
    return this.escapeHTML(sanitized);
  }
  
  // HTMLå®ä½“ç¼–ç 
  escapeHTML(text) {
    return String(text).replace(/[&<>"'\/]/g, (char) => {
      return this.htmlEntities[char] || char;
    });
  }
  
  // è§£ç HTMLå®ä½“
  unescapeHTML(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }
  
  // å®‰å…¨çš„DOMæ“ä½œ
  safeSetTextContent(element, text) {
    element.textContent = text;
  }
  
  safeSetHTML(element, html) {
    element.innerHTML = this.sanitizeHTML(html);
  }
  
  // åˆ›å»ºå®‰å…¨çš„å…ƒç´ 
  createSafeElement(tagName, attributes = {}, textContent = '') {
    const element = document.createElement(tagName);
    
    // å®‰å…¨è®¾ç½®å±æ€§
    Object.entries(attributes).forEach(([key, value]) => {
      if (this.isSafeAttribute(key, value)) {
        element.setAttribute(key, value);
      }
    });
    
    // å®‰å…¨è®¾ç½®æ–‡æœ¬å†…å®¹
    if (textContent) {
      element.textContent = textContent;
    }
    
    return element;
  }
  
  isSafeAttribute(name, value) {
    // å±é™©å±æ€§é»‘åå•
    const dangerousAttributes = [
      'onclick', 'onload', 'onerror', 'onmouseover',
      'onfocus', 'onblur', 'onchange', 'onsubmit'
    ];
    
    if (dangerousAttributes.includes(name.toLowerCase())) {
      return false;
    }
    
    // æ£€æŸ¥å±æ€§å€¼
    if (typeof value === 'string') {
      if (value.toLowerCase().includes('javascript:')) {
        return false;
      }
      
      if (value.toLowerCase().includes('data:text/html')) {
        return false;
      }
    }
    
    return true;
  }
  
  monitorDOMChanges() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.scanElementForXSS(node);
          }
        });
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  scanElementForXSS(element) {
    // æ£€æŸ¥å…ƒç´ çš„innerHTML
    if (element.innerHTML && this.containsXSS(element.innerHTML)) {
      console.warn('æ£€æµ‹åˆ°åŠ¨æ€æ’å…¥çš„XSSå†…å®¹:', element);
      element.innerHTML = this.sanitizeHTML(element.innerHTML);
    }
    
    // æ£€æŸ¥å±æ€§
    Array.from(element.attributes).forEach(attr => {
      if (!this.isSafeAttribute(attr.name, attr.value)) {
        console.warn('ç§»é™¤å±é™©å±æ€§:', attr.name, attr.value);
        element.removeAttribute(attr.name);
      }
    });
  }
  
  protectEventHandlers() {
    // é‡å†™addEventListener
    const originalAddEventListener = EventTarget.prototype.addEventListener;
    
    EventTarget.prototype.addEventListener = function(type, listener, options) {
      // æ£€æŸ¥äº‹ä»¶å¤„ç†å™¨æ˜¯å¦å®‰å…¨
      if (typeof listener === 'string') {
        console.warn('é˜»æ­¢å­—ç¬¦ä¸²å½¢å¼çš„äº‹ä»¶å¤„ç†å™¨:', listener);
        return;
      }
      
      return originalAddEventListener.call(this, type, listener, options);
    };
  }
}

// 2. å†…å®¹å®‰å…¨ç­–ç•¥(CSP)åŠ©æ‰‹
class CSPHelper {
  constructor() {
    this.policy = {
      'default-src': ["'self'"],
      'script-src': ["'self'"],
      'style-src': ["'self'", "'unsafe-inline'"],
      'img-src': ["'self'", 'data:', 'https:'],
      'font-src': ["'self'"],
      'connect-src': ["'self'"],
      'frame-src': ["'none'"],
      'object-src': ["'none'"],
      'base-uri': ["'self'"],
      'form-action': ["'self'"]
    };
  }
  
  // ç”ŸæˆCSPå­—ç¬¦ä¸²
  generateCSP() {
    return Object.entries(this.policy)
      .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
      .join('; ');
  }
  
  // æ·»åŠ å…è®¸çš„æº
  addSource(directive, source) {
    if (this.policy[directive]) {
      if (!this.policy[directive].includes(source)) {
        this.policy[directive].push(source);
      }
    }
  }
  
  // ç§»é™¤æº
  removeSource(directive, source) {
    if (this.policy[directive]) {
      this.policy[directive] = this.policy[directive].filter(s => s !== source);
    }
  }
  
  // åº”ç”¨CSP
  applyCSP() {
    const csp = this.generateCSP();
    
    // é€šè¿‡metaæ ‡ç­¾åº”ç”¨
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = csp;
    document.head.appendChild(meta);
    
    console.log('åº”ç”¨CSP:', csp);
  }
  
  // ç›‘å¬CSPè¿è§„
  monitorViolations() {
    document.addEventListener('securitypolicyviolation', (event) => {
      console.error('CSPè¿è§„:', {
        directive: event.violatedDirective,
        blockedURI: event.blockedURI,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber
      });
      
      // å‘é€è¿è§„æŠ¥å‘Š
      this.reportViolation(event);
    });
  }
  
  reportViolation(event) {
    fetch('/api/security/csp-violation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        directive: event.violatedDirective,
        blockedURI: event.blockedURI,
        sourceFile: event.sourceFile,
        lineNumber: event.lineNumber,
        timestamp: Date.now(),
        userAgent: navigator.userAgent
      })
    }).catch(console.error);
  }
}

// 3. å®‰å…¨çš„æ¨¡æ¿æ¸²æŸ“
class SecureTemplateRenderer {
  constructor() {
    this.xssProtection = new XSSProtection();
  }
  
  // å®‰å…¨æ¸²æŸ“æ¨¡æ¿
  render(template, data) {
    let rendered = template;
    
    // æ›¿æ¢å˜é‡
    Object.entries(data).forEach(([key, value]) => {
      const placeholder = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
      const escapedValue = this.xssProtection.escapeHTML(String(value));
      rendered = rendered.replace(placeholder, escapedValue);
    });
    
    // å¤„ç†åŸå§‹HTMLï¼ˆéœ€è¦ç‰¹æ®Šæ ‡è®°ï¼‰
    rendered = rendered.replace(/{{{(\w+)}}}/g, (match, key) => {
      const value = data[key];
      if (value) {
        return this.xssProtection.sanitizeHTML(String(value));
      }
      return '';
    });
    
    return rendered;
  }
  
  // åˆ›å»ºå®‰å…¨çš„æ¨¡æ¿å‡½æ•°
  compile(template) {
    return (data) => this.render(template, data);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const xssProtection = new XSSProtection();
const cspHelper = new CSPHelper();
const templateRenderer = new SecureTemplateRenderer();

// åº”ç”¨å®‰å…¨ç­–ç•¥
cspHelper.applyCSP();
cspHelper.monitorViolations();

// å®‰å…¨æ¸²æŸ“ç”¨æˆ·å†…å®¹
const userContent = '<script>alert("XSS")</script>Hello World';
const safeContent = xssProtection.sanitizeHTML(userContent);
console.log('å®‰å…¨å†…å®¹:', safeContent); // Hello World

// å®‰å…¨æ¨¡æ¿æ¸²æŸ“
const template = '<div>Hello {{name}}, your message: {{message}}</div>';
const rendered = templateRenderer.render(template, {
  name: '<script>alert("XSS")</script>John',
  message: 'Welcome to our site!'
});
console.log('æ¸²æŸ“ç»“æœ:', rendered);
```

## CSRFæ”»å‡»é˜²æŠ¤

<Callout type="warning">
CSRFï¼ˆè·¨ç«™è¯·æ±‚ä¼ªé€ ï¼‰æ”»å‡»åˆ©ç”¨ç”¨æˆ·çš„èº«ä»½æ‰§è¡Œæœªæˆæƒçš„æ“ä½œï¼Œéœ€è¦é€šè¿‡å¤šç§æ‰‹æ®µè¿›è¡Œé˜²æŠ¤ã€‚
</Callout>

### CSRFé˜²æŠ¤å®ç°

```javascript
// 1. CSRF Tokenç®¡ç†
class CSRFProtection {
  constructor() {
    this.token = null;
    this.tokenExpiry = null;
    this.init();
  }

  init() {
    this.generateToken();
    this.setupTokenRefresh();
  }

  generateToken() {
    // ç”Ÿæˆéšæœºtoken
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    this.token = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    this.tokenExpiry = Date.now() + (30 * 60 * 1000); // 30åˆ†é’Ÿè¿‡æœŸ

    // å­˜å‚¨åˆ°metaæ ‡ç­¾
    this.updateMetaToken();
  }

  updateMetaToken() {
    let metaTag = document.querySelector('meta[name="csrf-token"]');
    if (!metaTag) {
      metaTag = document.createElement('meta');
      metaTag.name = 'csrf-token';
      document.head.appendChild(metaTag);
    }
    metaTag.content = this.token;
  }

  getToken() {
    if (this.isTokenExpired()) {
      this.generateToken();
    }
    return this.token;
  }

  isTokenExpired() {
    return Date.now() > this.tokenExpiry;
  }

  async refreshToken() {
    try {
      const response = await fetch('/api/csrf/refresh', {
        method: 'POST',
        credentials: 'same-origin'
      });

      if (response.ok) {
        const data = await response.json();
        this.token = data.token;
        this.tokenExpiry = Date.now() + (30 * 60 * 1000);
        this.updateMetaToken();
      }
    } catch (error) {
      console.error('Failed to refresh CSRF token:', error);
    }
  }
}

// 2. å®‰å…¨çš„HTTPå®¢æˆ·ç«¯
class SecureHttpClient {
  constructor() {
    this.csrfProtection = new CSRFProtection();
    this.setupInterceptors();
  }

  setupInterceptors() {
    // æ‹¦æˆªæ‰€æœ‰fetchè¯·æ±‚
    const originalFetch = window.fetch;
    window.fetch = (url, options = {}) => {
      return this.secureRequest(url, options, originalFetch);
    };
  }

  async secureRequest(url, options, originalFetch) {
    // åªå¯¹åŒæºè¯·æ±‚æ·»åŠ CSRFä¿æŠ¤
    if (this.isSameOrigin(url)) {
      options.headers = {
        ...options.headers,
        'X-CSRF-Token': this.csrfProtection.getToken(),
        'X-Requested-With': 'XMLHttpRequest'
      };

      options.credentials = options.credentials || 'same-origin';
    }

    const response = await originalFetch(url, options);

    if (response.status === 403 && response.headers.get('X-CSRF-Error')) {
      await this.csrfProtection.refreshToken();
      options.headers['X-CSRF-Token'] = this.csrfProtection.getToken();
      return originalFetch(url, options);
    }

    return response;
  }

  isSameOrigin(url) {
    try {
      const requestUrl = new URL(url, window.location.origin);
      return requestUrl.origin === window.location.origin;
    } catch {
      return true;
    }
  }
}
```

## å†…å®¹å®‰å…¨ç­–ç•¥CSP

<Callout type="info">
CSPï¼ˆContent Security Policyï¼‰æ˜¯ä¸€ä¸ªé‡è¦çš„å®‰å…¨å±‚ï¼Œå¸®åŠ©æ£€æµ‹å’Œç¼“è§£æŸäº›ç±»å‹çš„æ”»å‡»ã€‚
</Callout>

### CSPé…ç½®å’Œå®ç°

```javascript
// 1. CSPç­–ç•¥ç”Ÿæˆå™¨
class CSPPolicyBuilder {
  constructor() {
    this.directives = new Map();
    this.reportUri = null;
    this.reportOnly = false;
  }

  // è®¾ç½®é»˜è®¤æº
  defaultSrc(...sources) {
    this.directives.set('default-src', sources);
    return this;
  }

  // è®¾ç½®è„šæœ¬æº
  scriptSrc(...sources) {
    this.directives.set('script-src', sources);
    return this;
  }

  // è®¾ç½®æ ·å¼æº
  styleSrc(...sources) {
    this.directives.set('style-src', sources);
    return this;
  }

  // è®¾ç½®å›¾ç‰‡æº
  imgSrc(...sources) {
    this.directives.set('img-src', sources);
    return this;
  }

  // è®¾ç½®è¿æ¥æº
  connectSrc(...sources) {
    this.directives.set('connect-src', sources);
    return this;
  }

  // è®¾ç½®å­—ä½“æº
  fontSrc(...sources) {
    this.directives.set('font-src', sources);
    return this;
  }

  // è®¾ç½®å¯¹è±¡æº
  objectSrc(...sources) {
    this.directives.set('object-src', sources);
    return this;
  }

  // è®¾ç½®åª’ä½“æº
  mediaSrc(...sources) {
    this.directives.set('media-src', sources);
    return this;
  }

  // è®¾ç½®æ¡†æ¶æº
  frameSrc(...sources) {
    this.directives.set('frame-src', sources);
    return this;
  }

  // è®¾ç½®æŠ¥å‘ŠURI
  setReportUri(uri) {
    this.reportUri = uri;
    return this;
  }

  // è®¾ç½®ä¸ºä»…æŠ¥å‘Šæ¨¡å¼
  setReportOnly(reportOnly = true) {
    this.reportOnly = reportOnly;
    return this;
  }

  // ç”ŸæˆCSPå­—ç¬¦ä¸²
  build() {
    const policies = [];

    for (const [directive, sources] of this.directives) {
      policies.push(`${directive} ${sources.join(' ')}`);
    }

    if (this.reportUri) {
      policies.push(`report-uri ${this.reportUri}`);
    }

    return policies.join('; ');
  }

  // åº”ç”¨åˆ°é¡µé¢
  apply() {
    const policy = this.build();
    const headerName = this.reportOnly ?
      'Content-Security-Policy-Report-Only' :
      'Content-Security-Policy';

    // åˆ›å»ºmetaæ ‡ç­¾
    const meta = document.createElement('meta');
    meta.httpEquiv = headerName;
    meta.content = policy;
    document.head.appendChild(meta);

    return policy;
  }
}

// 2. CSPè¿è§„æŠ¥å‘Šå¤„ç†
class CSPReportHandler {
  constructor(reportEndpoint) {
    this.reportEndpoint = reportEndpoint;
    this.setupReportListener();
  }

  setupReportListener() {
    // ç›‘å¬CSPè¿è§„äº‹ä»¶
    document.addEventListener('securitypolicyviolation', (event) => {
      this.handleViolation(event);
    });
  }

  handleViolation(event) {
    const report = {
      'document-uri': event.documentURI,
      'referrer': event.referrer,
      'violated-directive': event.violatedDirective,
      'effective-directive': event.effectiveDirective,
      'original-policy': event.originalPolicy,
      'blocked-uri': event.blockedURI,
      'line-number': event.lineNumber,
      'column-number': event.columnNumber,
      'source-file': event.sourceFile,
      'status-code': event.statusCode,
      'timestamp': new Date().toISOString(),
      'user-agent': navigator.userAgent
    };

    this.sendReport(report);
  }

  async sendReport(report) {
    try {
      await fetch(this.reportEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/csp-report'
        },
        body: JSON.stringify({ 'csp-report': report })
      });
    } catch (error) {
      console.error('Failed to send CSP report:', error);
    }
  }
}

// 3. åŠ¨æ€CSPç®¡ç†
class DynamicCSP {
  constructor() {
    this.nonces = new Set();
    this.hashes = new Set();
  }

  // ç”Ÿæˆéšæœºnonce
  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    const nonce = btoa(String.fromCharCode.apply(null, array));
    this.nonces.add(nonce);
    return nonce;
  }

  // è®¡ç®—è„šæœ¬hash
  calculateHash(script, algorithm = 'sha256') {
    return crypto.subtle.digest(algorithm, new TextEncoder().encode(script))
      .then(hashBuffer => {
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        const hash = `${algorithm}-${btoa(hashHex)}`;
        this.hashes.add(hash);
        return hash;
      });
  }

  // å®‰å…¨åœ°æ·»åŠ å†…è”è„šæœ¬
  addInlineScript(scriptContent, parent = document.head) {
    const script = document.createElement('script');
    const nonce = this.generateNonce();

    script.nonce = nonce;
    script.textContent = scriptContent;
    parent.appendChild(script);

    return nonce;
  }

  // å®‰å…¨åœ°æ·»åŠ å†…è”æ ·å¼
  addInlineStyle(styleContent, parent = document.head) {
    const style = document.createElement('style');
    const nonce = this.generateNonce();

    style.nonce = nonce;
    style.textContent = styleContent;
    parent.appendChild(style);

    return nonce;
  }

  // æ›´æ–°CSPç­–ç•¥
  updateCSP() {
    const nonceList = Array.from(this.nonces).map(nonce => `'nonce-${nonce}'`);
    const hashList = Array.from(this.hashes).map(hash => `'${hash}'`);

    const csp = new CSPPolicyBuilder()
      .defaultSrc("'self'")
      .scriptSrc("'self'", ...nonceList, ...hashList)
      .styleSrc("'self'", "'unsafe-inline'", ...nonceList)
      .imgSrc("'self'", "data:", "https:")
      .connectSrc("'self'")
      .fontSrc("'self'", "https://fonts.gstatic.com")
      .objectSrc("'none'")
      .frameSrc("'none'")
      .setReportUri('/api/csp-report');

    return csp.apply();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const csp = new CSPPolicyBuilder()
  .defaultSrc("'self'")
  .scriptSrc("'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net")
  .styleSrc("'self'", "'unsafe-inline'", "https://fonts.googleapis.com")
  .imgSrc("'self'", "data:", "https:")
  .connectSrc("'self'", "https://api.example.com")
  .fontSrc("'self'", "https://fonts.gstatic.com")
  .objectSrc("'none'")
  .frameSrc("'none'")
  .setReportUri('/api/csp-report')
  .apply();

// è®¾ç½®CSPæŠ¥å‘Šå¤„ç†
const reportHandler = new CSPReportHandler('/api/csp-report');

// åŠ¨æ€CSPç®¡ç†
const dynamicCSP = new DynamicCSP();
```

## æ•°æ®ä¼ è¾“å®‰å…¨

<Callout type="warning">
æ•°æ®ä¼ è¾“å®‰å…¨ç¡®ä¿æ•æ„Ÿä¿¡æ¯åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´å®‰å…¨ä¼ è¾“ï¼Œé˜²æ­¢æ•°æ®æ³„éœ²å’Œç¯¡æ”¹ã€‚
</Callout>

### HTTPSå’ŒåŠ å¯†ä¼ è¾“

```javascript
// 1. å¼ºåˆ¶HTTPSé‡å®šå‘
class HTTPSEnforcer {
  static enforceHTTPS() {
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      location.replace(`https:${location.href.substring(location.protocol.length)}`);
    }
  }

  static setupHSTS() {
    // é€šè¿‡metaæ ‡ç­¾è®¾ç½®HSTSï¼ˆå®é™…åº”è¯¥åœ¨æœåŠ¡å™¨ç«¯è®¾ç½®ï¼‰
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Strict-Transport-Security';
    meta.content = 'max-age=31536000; includeSubDomains; preload';
    document.head.appendChild(meta);
  }

  static checkMixedContent() {
    // æ£€æŸ¥æ··åˆå†…å®¹
    const insecureResources = [];

    document.querySelectorAll('img, script, link, iframe').forEach(element => {
      const src = element.src || element.href;
      if (src && src.startsWith('http://')) {
        insecureResources.push({
          element: element.tagName,
          url: src
        });
      }
    });

    if (insecureResources.length > 0) {
      console.warn('Mixed content detected:', insecureResources);
    }

    return insecureResources;
  }
}

// 2. å®¢æˆ·ç«¯åŠ å¯†
class ClientSideEncryption {
  constructor() {
    this.keyPair = null;
    this.init();
  }

  async init() {
    // ç”ŸæˆRSAå¯†é’¥å¯¹
    this.keyPair = await crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
      },
      true,
      ['encrypt', 'decrypt']
    );
  }

  async encryptData(data) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);

    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'RSA-OAEP'
      },
      this.keyPair.publicKey,
      encodedData
    );

    return btoa(String.fromCharCode.apply(null, new Uint8Array(encrypted)));
  }

  async decryptData(encryptedData) {
    const binaryString = atob(encryptedData);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }

    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'RSA-OAEP'
      },
      this.keyPair.privateKey,
      bytes
    );

    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
  }

  async exportPublicKey() {
    const exported = await crypto.subtle.exportKey('spki', this.keyPair.publicKey);
    const exportedAsString = String.fromCharCode.apply(null, new Uint8Array(exported));
    return btoa(exportedAsString);
  }
}

// 3. å®‰å…¨çš„æ•°æ®å­˜å‚¨
class SecureStorage {
  constructor(password) {
    this.password = password;
    this.salt = new Uint8Array(16);
    crypto.getRandomValues(this.salt);
  }

  async deriveKey() {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.password),
      { name: 'PBKDF2' },
      false,
      ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: this.salt,
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      true,
      ['encrypt', 'decrypt']
    );
  }

  async encryptAndStore(key, data) {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(JSON.stringify(data));

    const derivedKey = await this.deriveKey();
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      derivedKey,
      encodedData
    );

    const encryptedData = {
      data: Array.from(new Uint8Array(encrypted)),
      iv: Array.from(iv),
      salt: Array.from(this.salt)
    };

    localStorage.setItem(key, JSON.stringify(encryptedData));
  }

  async decryptAndRetrieve(key) {
    const stored = localStorage.getItem(key);
    if (!stored) return null;

    const { data, iv, salt } = JSON.parse(stored);
    this.salt = new Uint8Array(salt);

    const derivedKey = await this.deriveKey();

    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(iv)
      },
      derivedKey,
      new Uint8Array(data)
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  }
}

// 4. APIè¯·æ±‚ç­¾å
class APIRequestSigner {
  constructor(secretKey) {
    this.secretKey = secretKey;
  }

  async signRequest(method, url, body = '', timestamp = Date.now()) {
    const message = `${method}\n${url}\n${body}\n${timestamp}`;
    const encoder = new TextEncoder();
    const data = encoder.encode(message);

    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.secretKey),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );

    const signature = await crypto.subtle.sign('HMAC', key, data);
    return btoa(String.fromCharCode.apply(null, new Uint8Array(signature)));
  }

  async makeSignedRequest(url, options = {}) {
    const timestamp = Date.now();
    const method = options.method || 'GET';
    const body = options.body || '';

    const signature = await this.signRequest(method, url, body, timestamp);

    const headers = {
      ...options.headers,
      'X-Timestamp': timestamp.toString(),
      'X-Signature': signature
    };

    return fetch(url, {
      ...options,
      headers
    });
  }
}
```

## å®‰å…¨å¼€å‘æœ€ä½³å®è·µ

<Callout type="info">
å®‰å…¨å¼€å‘æœ€ä½³å®è·µå¸®åŠ©å¼€å‘å›¢é˜Ÿåœ¨æ•´ä¸ªå¼€å‘ç”Ÿå‘½å‘¨æœŸä¸­ä¿æŒå®‰å…¨æ„è¯†ï¼Œæ„å»ºæ›´å®‰å…¨çš„åº”ç”¨ã€‚
</Callout>

### å®‰å…¨å¼€å‘æµç¨‹

```javascript
// 1. å®‰å…¨ä»£ç å®¡æŸ¥æ¸…å•
class SecurityCodeReview {
  static getChecklist() {
    return {
      inputValidation: [
        'æ‰€æœ‰ç”¨æˆ·è¾“å…¥éƒ½ç»è¿‡éªŒè¯',
        'ä½¿ç”¨ç™½åå•è€Œä¸æ˜¯é»‘åå•éªŒè¯',
        'å¯¹æ–‡ä»¶ä¸Šä¼ è¿›è¡Œç±»å‹å’Œå¤§å°é™åˆ¶',
        'éªŒè¯URLå’Œé‡å®šå‘ç›®æ ‡'
      ],
      outputEncoding: [
        'æ‰€æœ‰è¾“å‡ºéƒ½ç»è¿‡é€‚å½“ç¼–ç ',
        'ä½¿ç”¨æ¨¡æ¿å¼•æ“çš„è‡ªåŠ¨è½¬ä¹‰',
        'é¿å…ä½¿ç”¨innerHTMLç­‰å±é™©API',
        'æ­£ç¡®å¤„ç†JSONè¾“å‡º'
      ],
      authentication: [
        'å®ç°å¼ºå¯†ç ç­–ç•¥',
        'ä½¿ç”¨å¤šå› ç´ è®¤è¯',
        'æ­£ç¡®å¤„ç†ä¼šè¯ç®¡ç†',
        'å®ç°è´¦æˆ·é”å®šæœºåˆ¶'
      ],
      authorization: [
        'å®ç°æœ€å°æƒé™åŸåˆ™',
        'éªŒè¯ç”¨æˆ·æƒé™',
        'é¿å…ç›´æ¥å¯¹è±¡å¼•ç”¨',
        'å®ç°RBACæˆ–ABAC'
      ],
      dataProtection: [
        'æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨',
        'ä½¿ç”¨HTTPSä¼ è¾“',
        'å®ç°æ•°æ®è„±æ•',
        'å®šæœŸå¤‡ä»½å’Œæ¢å¤æµ‹è¯•'
      ],
      errorHandling: [
        'ä¸æ³„éœ²æ•æ„Ÿä¿¡æ¯',
        'è®°å½•å®‰å…¨äº‹ä»¶',
        'å®ç°ä¼˜é›…é™çº§',
        'æä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯'
      ]
    };
  }

  static reviewCode(codeSnippet, category) {
    const checklist = this.getChecklist()[category] || [];
    const issues = [];

    // ç®€å•çš„é™æ€åˆ†æç¤ºä¾‹
    if (category === 'inputValidation') {
      if (codeSnippet.includes('innerHTML') && !codeSnippet.includes('sanitize')) {
        issues.push('å¯èƒ½å­˜åœ¨XSSé£é™©ï¼šä½¿ç”¨innerHTMLä½†æœªè¿›è¡Œæ¸…ç†');
      }

      if (codeSnippet.includes('eval(') || codeSnippet.includes('Function(')) {
        issues.push('ä»£ç æ³¨å…¥é£é™©ï¼šä½¿ç”¨evalæˆ–Functionæ„é€ å™¨');
      }
    }

    if (category === 'dataProtection') {
      if (codeSnippet.includes('localStorage') && codeSnippet.includes('password')) {
        issues.push('æ•æ„Ÿæ•°æ®é£é™©ï¼šå¯†ç å­˜å‚¨åœ¨localStorageä¸­');
      }
    }

    return {
      category,
      checklist,
      issues,
      passed: issues.length === 0
    };
  }
}

// 2. å®‰å…¨æµ‹è¯•è‡ªåŠ¨åŒ–
class SecurityTestSuite {
  constructor() {
    this.tests = [];
  }

  addTest(name, testFunction) {
    this.tests.push({ name, test: testFunction });
  }

  async runAllTests() {
    const results = [];

    for (const { name, test } of this.tests) {
      try {
        const result = await test();
        results.push({
          name,
          passed: result.passed,
          message: result.message,
          details: result.details
        });
      } catch (error) {
        results.push({
          name,
          passed: false,
          message: error.message,
          error: true
        });
      }
    }

    return results;
  }

  // XSSæµ‹è¯•
  testXSSProtection() {
    return new Promise((resolve) => {
      const testPayloads = [
        '<script>alert("xss")</script>',
        'javascript:alert("xss")',
        '<img src="x" onerror="alert(\'xss\')">'
      ];

      const vulnerabilities = [];

      testPayloads.forEach(payload => {
        const div = document.createElement('div');
        div.innerHTML = payload;

        if (div.querySelector('script') || div.innerHTML.includes('javascript:')) {
          vulnerabilities.push(payload);
        }
      });

      resolve({
        passed: vulnerabilities.length === 0,
        message: vulnerabilities.length === 0 ?
          'XSS protection working' :
          `Found ${vulnerabilities.length} XSS vulnerabilities`,
        details: vulnerabilities
      });
    });
  }

  // CSRFæµ‹è¯•
  testCSRFProtection() {
    return new Promise((resolve) => {
      const hasCSRFToken = document.querySelector('meta[name="csrf-token"]') !== null;
      const hasCSRFHeader = fetch.toString().includes('X-CSRF-Token');

      resolve({
        passed: hasCSRFToken || hasCSRFHeader,
        message: hasCSRFToken || hasCSRFHeader ?
          'CSRF protection detected' :
          'No CSRF protection found',
        details: {
          metaToken: hasCSRFToken,
          headerProtection: hasCSRFHeader
        }
      });
    });
  }

  // HTTPSæµ‹è¯•
  testHTTPSEnforcement() {
    return new Promise((resolve) => {
      const isHTTPS = location.protocol === 'https:';
      const hasHSTS = document.querySelector('meta[http-equiv="Strict-Transport-Security"]') !== null;

      resolve({
        passed: isHTTPS,
        message: isHTTPS ?
          'HTTPS enforced' :
          'Not using HTTPS',
        details: {
          protocol: location.protocol,
          hasHSTS
        }
      });
    });
  }
}

// 3. å®‰å…¨ç›‘æ§å’Œå‘Šè­¦
class SecurityMonitor {
  constructor() {
    this.alerts = [];
    this.setupMonitoring();
  }

  setupMonitoring() {
    // ç›‘æ§å¯ç–‘æ´»åŠ¨
    this.monitorSuspiciousActivity();

    // ç›‘æ§å®‰å…¨å¤´
    this.monitorSecurityHeaders();

    // ç›‘æ§CSPè¿è§„
    this.monitorCSPViolations();
  }

  monitorSuspiciousActivity() {
    let failedAttempts = 0;
    const maxAttempts = 5;
    const timeWindow = 5 * 60 * 1000; // 5åˆ†é’Ÿ

    document.addEventListener('submit', (event) => {
      const form = event.target;
      if (form.action.includes('/login') || form.action.includes('/auth')) {
        // æ¨¡æ‹Ÿç™»å½•å¤±è´¥æ£€æµ‹
        setTimeout(() => {
          if (document.querySelector('.error')) {
            failedAttempts++;

            if (failedAttempts >= maxAttempts) {
              this.createAlert('security', 'Multiple failed login attempts detected', {
                attempts: failedAttempts,
                timeWindow: timeWindow,
                userAgent: navigator.userAgent,
                ip: 'client-side' // å®é™…åº”è¯¥ä»æœåŠ¡å™¨è·å–
              });
            }
          }
        }, 1000);
      }
    });

    // é‡ç½®è®¡æ•°å™¨
    setInterval(() => {
      failedAttempts = 0;
    }, timeWindow);
  }

  monitorSecurityHeaders() {
    const requiredHeaders = [
      'Content-Security-Policy',
      'X-Frame-Options',
      'X-Content-Type-Options',
      'Strict-Transport-Security'
    ];

    fetch(window.location.href, { method: 'HEAD' })
      .then(response => {
        const missingHeaders = requiredHeaders.filter(header =>
          !response.headers.has(header)
        );

        if (missingHeaders.length > 0) {
          this.createAlert('configuration', 'Missing security headers', {
            missingHeaders,
            url: window.location.href
          });
        }
      })
      .catch(error => {
        console.error('Failed to check security headers:', error);
      });
  }

  monitorCSPViolations() {
    document.addEventListener('securitypolicyviolation', (event) => {
      this.createAlert('csp', 'CSP violation detected', {
        violatedDirective: event.violatedDirective,
        blockedURI: event.blockedURI,
        documentURI: event.documentURI,
        lineNumber: event.lineNumber
      });
    });
  }

  createAlert(type, message, details = {}) {
    const alert = {
      id: Math.random().toString(36).substr(2, 9),
      type,
      message,
      details,
      timestamp: new Date().toISOString(),
      severity: this.calculateSeverity(type, details)
    };

    this.alerts.push(alert);
    this.sendAlert(alert);

    return alert;
  }

  calculateSeverity(type, details) {
    switch (type) {
      case 'security':
        return details.attempts >= 10 ? 'critical' : 'high';
      case 'csp':
        return 'medium';
      case 'configuration':
        return 'low';
      default:
        return 'info';
    }
  }

  async sendAlert(alert) {
    try {
      await fetch('/api/security/alerts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(alert)
      });
    } catch (error) {
      console.error('Failed to send security alert:', error);
    }
  }

  getAlerts(type = null) {
    return type ?
      this.alerts.filter(alert => alert.type === type) :
      this.alerts;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// åˆå§‹åŒ–å®‰å…¨ç›‘æ§
const securityMonitor = new SecurityMonitor();

// è¿è¡Œå®‰å…¨æµ‹è¯•
const testSuite = new SecurityTestSuite();
testSuite.addTest('XSS Protection', () => testSuite.testXSSProtection());
testSuite.addTest('CSRF Protection', () => testSuite.testCSRFProtection());
testSuite.addTest('HTTPS Enforcement', () => testSuite.testHTTPSEnforcement());

testSuite.runAllTests().then(results => {
  console.log('Security test results:', results);
});

// ä»£ç å®¡æŸ¥
const codeSnippet = `
  const userInput = document.getElementById('input').value;
  document.getElementById('output').innerHTML = userInput;
`;

const reviewResult = SecurityCodeReview.reviewCode(codeSnippet, 'inputValidation');
console.log('Code review result:', reviewResult);
```

---

<Callout type="success">
å‰ç«¯å®‰å…¨éœ€è¦å¤šå±‚é˜²æŠ¤ï¼ŒåŒ…æ‹¬è¾“å…¥éªŒè¯ã€è¾“å‡ºç¼–ç ã€CSPé…ç½®ç­‰ã€‚å®‰å…¨æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦å®šæœŸè¯„ä¼°å’Œæ›´æ–°é˜²æŠ¤æªæ–½ã€‚
</Callout>

---

## ğŸ“š å‚è€ƒå­¦ä¹ èµ„æ–™

### ğŸ“– å®˜æ–¹æ–‡æ¡£
- [OWASP Top 10](https://owasp.org/www-project-top-ten/) - Webåº”ç”¨å®‰å…¨é£é™©
- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security) - MDN Webå®‰å…¨æŒ‡å—
- [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) - CSPå®˜æ–¹æ–‡æ¡£
- [Web.dev Security](https://web.dev/secure/) - Google Webå®‰å…¨æŒ‡å—

### ğŸ“ ä¼˜è´¨æ•™ç¨‹
- [Frontend Security](https://frontendmasters.com/courses/web-security/) - Frontend Masterså®‰å…¨è¯¾ç¨‹
- [Web Security Academy](https://portswigger.net/web-security) - PortSwiggerå®‰å…¨å­¦é™¢
- [OWASP WebGoat](https://owasp.org/www-project-webgoat/) - Webå®‰å…¨å®è·µå¹³å°

### ğŸ› ï¸ å®è·µé¡¹ç›®
- [Security Headers](https://securityheaders.com/) - å®‰å…¨å¤´æ£€æµ‹å·¥å…·
- [OWASP ZAP](https://www.zaproxy.org/) - Webåº”ç”¨å®‰å…¨æµ‹è¯•å·¥å…·
- [Security Checklist](https://github.com/FallibleInc/security-guide-for-developers) - å¼€å‘è€…å®‰å…¨æŒ‡å—

### ğŸ”§ å¼€å‘å·¥å…·
- [ESLint Security](https://github.com/nodesecurity/eslint-plugin-security) - ESLintå®‰å…¨æ’ä»¶
- [Snyk](https://snyk.io/) - ä¾èµ–å®‰å…¨æ‰«æ
- [npm audit](https://docs.npmjs.com/cli/v8/commands/npm-audit) - npmå®‰å…¨å®¡è®¡
- [Helmet.js](https://helmetjs.github.io/) - Expresså®‰å…¨ä¸­é—´ä»¶

### ğŸ“ æ·±å…¥é˜…è¯»
- [Frontend Security Best Practices](https://blog.logrocket.com/frontend-security-best-practices/) - å‰ç«¯å®‰å…¨æœ€ä½³å®è·µ
- [XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) - XSSé˜²æŠ¤å¤‡å¿˜å•
- [CSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) - CSRFé˜²æŠ¤æŒ‡å—

<Callout type="tip">
ğŸ’¡ **å­¦ä¹ å»ºè®®**ï¼šå»ºè®®ä»OWASP Top 10å¼€å§‹äº†è§£å¸¸è§å®‰å…¨å¨èƒï¼Œå­¦ä¹ XSSå’ŒCSRFé˜²æŠ¤æŠ€æœ¯ï¼Œç„¶åæŒæ¡CSPé…ç½®ï¼Œæœ€åå»ºç«‹å®Œæ•´çš„å®‰å…¨å¼€å‘æµç¨‹ã€‚
</Callout>

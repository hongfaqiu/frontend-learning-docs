import { Callout } from 'nextra/components'

# 05. æµè§ˆå™¨åŸç†å’ŒWeb API

## ğŸ“‹ ç›®å½•

- [æµè§ˆå™¨æ¶æ„æ·±å…¥](#æµè§ˆå™¨æ¶æ„æ·±å…¥)
- [æ¸²æŸ“å¼•æ“å·¥ä½œåŸç†](#æ¸²æŸ“å¼•æ“å·¥ä½œåŸç†)
- [JavaScriptå¼•æ“å’Œäº‹ä»¶å¾ªç¯](#javascriptå¼•æ“å’Œäº‹ä»¶å¾ªç¯)
- [ç°ä»£Web APIè¯¦è§£](#ç°ä»£web-apiè¯¦è§£)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [æµè§ˆå™¨å®‰å…¨æœºåˆ¶](#æµè§ˆå™¨å®‰å…¨æœºåˆ¶)

## ğŸ—ï¸ æµè§ˆå™¨æ¶æ„æ·±å…¥

<Callout type="info">
ç°ä»£æµè§ˆå™¨é‡‡ç”¨å¤šè¿›ç¨‹æ¶æ„ï¼Œç†è§£å…¶å·¥ä½œåŸç†æœ‰åŠ©äºæˆ‘ä»¬ç¼–å†™æ›´é«˜æ•ˆçš„Webåº”ç”¨ã€‚
</Callout>

### å¤šè¿›ç¨‹æ¶æ„

```javascript
// æµè§ˆå™¨è¿›ç¨‹æ¶æ„ç¤ºæ„
/*
1. æµè§ˆå™¨è¿›ç¨‹ï¼ˆBrowser Processï¼‰
   - è´Ÿè´£æµè§ˆå™¨ç•Œé¢æ˜¾ç¤º
   - ç®¡ç†å…¶ä»–è¿›ç¨‹
   - å¤„ç†ç½‘ç»œè¯·æ±‚
   - æ–‡ä»¶è®¿é—®ç­‰

2. æ¸²æŸ“è¿›ç¨‹ï¼ˆRenderer Processï¼‰
   - æ¯ä¸ªæ ‡ç­¾é¡µä¸€ä¸ªè¿›ç¨‹
   - è´Ÿè´£é¡µé¢æ¸²æŸ“
   - JavaScriptæ‰§è¡Œ
   - DOMæ“ä½œ

3. GPUè¿›ç¨‹ï¼ˆGPU Processï¼‰
   - å¤„ç†GPUä»»åŠ¡
   - 3D CSSå˜æ¢
   - è§†é¢‘è§£ç 

4. ç½‘ç»œè¿›ç¨‹ï¼ˆNetwork Processï¼‰
   - å¤„ç†ç½‘ç»œè¯·æ±‚
   - å®‰å…¨æ£€æŸ¥
   - ç¼“å­˜ç®¡ç†

5. å­˜å‚¨è¿›ç¨‹ï¼ˆStorage Processï¼‰
   - ç®¡ç†æœ¬åœ°å­˜å‚¨
   - IndexedDB
   - Cache API
*/

// è¿›ç¨‹é—´é€šä¿¡ç¤ºä¾‹
// ä¸»è¿›ç¨‹å‘æ¸²æŸ“è¿›ç¨‹å‘é€æ¶ˆæ¯
if (window.electronAPI) {
  window.electronAPI.sendMessage('main-process', {
    type: 'GET_USER_DATA',
    userId: 123
  });
  
  window.electronAPI.onMessage('renderer-process', (data) => {
    console.log('æ”¶åˆ°ä¸»è¿›ç¨‹æ¶ˆæ¯:', data);
  });
}

// Web Workerè¿›ç¨‹é—´é€šä¿¡
const worker = new Worker('/worker.js');

worker.postMessage({
  type: 'CALCULATE',
  data: [1, 2, 3, 4, 5]
});

worker.onmessage = function(e) {
  console.log('Workerè®¡ç®—ç»“æœ:', e.data);
};

// worker.js
self.onmessage = function(e) {
  const { type, data } = e.data;
  
  if (type === 'CALCULATE') {
    const result = data.reduce((sum, num) => sum + num, 0);
    self.postMessage(result);
  }
};
```

### æµè§ˆå™¨å†…æ ¸å¯¹æ¯”

| æµè§ˆå™¨ | å†…æ ¸ | JavaScriptå¼•æ“ | ç‰¹ç‚¹ |
|--------|------|----------------|------|
| **Chrome** | Blink | V8 | æ€§èƒ½ä¼˜ç§€ï¼Œæ ‡å‡†æ”¯æŒå¥½ |
| **Firefox** | Gecko | SpiderMonkey | éšç§ä¿æŠ¤ï¼Œå¼€å‘è€…å‹å¥½ |
| **Safari** | WebKit | JavaScriptCore | èƒ½è€—ä¼˜åŒ–ï¼Œè‹¹æœç”Ÿæ€ |
| **Edge** | Blink | V8 | é›†æˆWindowsï¼Œä¼ä¸šå‹å¥½ |

## ğŸ¨ æ¸²æŸ“å¼•æ“å·¥ä½œåŸç†

### å…³é”®æ¸²æŸ“è·¯å¾„

<Callout type="warning">
ç†è§£å…³é”®æ¸²æŸ“è·¯å¾„æ˜¯å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„åŸºç¡€ï¼Œæ¯ä¸ªæ­¥éª¤éƒ½å¯èƒ½æˆä¸ºæ€§èƒ½ç“¶é¢ˆã€‚
</Callout>

```javascript
// å…³é”®æ¸²æŸ“è·¯å¾„çš„5ä¸ªæ­¥éª¤
/*
1. æ„å»ºDOMæ ‘ï¼ˆDOM Treeï¼‰
2. æ„å»ºCSSOMæ ‘ï¼ˆCSS Object Modelï¼‰
3. åˆå¹¶ç”Ÿæˆæ¸²æŸ“æ ‘ï¼ˆRender Treeï¼‰
4. å¸ƒå±€è®¡ç®—ï¼ˆLayout/Reflowï¼‰
5. ç»˜åˆ¶æ¸²æŸ“ï¼ˆPaint/Rasterizationï¼‰
*/

// 1. DOMè§£æè¿‡ç¨‹
const htmlParser = {
  parseHTML(html) {
    // è¯æ³•åˆ†æï¼šHTML -> Tokens
    const tokens = this.tokenize(html);
    
    // è¯­æ³•åˆ†æï¼šTokens -> DOM Tree
    const domTree = this.buildDOMTree(tokens);
    
    return domTree;
  },
  
  tokenize(html) {
    // ç®€åŒ–çš„HTMLè¯æ³•åˆ†æ
    const tokens = [];
    let i = 0;
    
    while (i < html.length) {
      if (html[i] === '<') {
        // è§£ææ ‡ç­¾
        const tagEnd = html.indexOf('>', i);
        const tagContent = html.slice(i + 1, tagEnd);
        
        if (tagContent.startsWith('/')) {
          tokens.push({ type: 'EndTag', name: tagContent.slice(1) });
        } else {
          tokens.push({ type: 'StartTag', name: tagContent });
        }
        
        i = tagEnd + 1;
      } else {
        // è§£ææ–‡æœ¬
        const nextTag = html.indexOf('<', i);
        const text = html.slice(i, nextTag === -1 ? html.length : nextTag);
        
        if (text.trim()) {
          tokens.push({ type: 'Text', content: text.trim() });
        }
        
        i = nextTag === -1 ? html.length : nextTag;
      }
    }
    
    return tokens;
  }
};

// 2. CSSOMæ„å»º
const cssParser = {
  parseCSS(css) {
    // CSSè§£æï¼šCSS -> CSSOM
    const rules = [];
    
    // ç®€åŒ–çš„CSSè§£æé€»è¾‘
    const ruleRegex = /([^{]+)\{([^}]+)\}/g;
    let match;
    
    while ((match = ruleRegex.exec(css)) !== null) {
      const selector = match[1].trim();
      const declarations = this.parseDeclarations(match[2]);
      
      rules.push({
        selector,
        declarations
      });
    }
    
    return rules;
  },
  
  parseDeclarations(declarationsText) {
    const declarations = {};
    const pairs = declarationsText.split(';');
    
    pairs.forEach(pair => {
      const [property, value] = pair.split(':').map(s => s.trim());
      if (property && value) {
        declarations[property] = value;
      }
    });
    
    return declarations;
  }
};

// 3. æ¸²æŸ“æ ‘æ„å»º
const renderTreeBuilder = {
  buildRenderTree(domTree, cssom) {
    const renderTree = [];
    
    this.traverseDOM(domTree, cssom, renderTree);
    
    return renderTree;
  },
  
  traverseDOM(node, cssom, renderTree) {
    // è·³è¿‡ä¸å¯è§å…ƒç´ 
    if (this.isHidden(node, cssom)) {
      return;
    }
    
    // åˆ›å»ºæ¸²æŸ“èŠ‚ç‚¹
    const renderNode = {
      element: node,
      styles: this.computeStyles(node, cssom),
      children: []
    };
    
    // é€’å½’å¤„ç†å­èŠ‚ç‚¹
    if (node.children) {
      node.children.forEach(child => {
        this.traverseDOM(child, cssom, renderNode.children);
      });
    }
    
    renderTree.push(renderNode);
  },
  
  isHidden(node, cssom) {
    const styles = this.computeStyles(node, cssom);
    return styles.display === 'none' || styles.visibility === 'hidden';
  },
  
  computeStyles(node, cssom) {
    // æ ·å¼è®¡ç®—ï¼šç»§æ‰¿ã€å±‚å ã€ç‰¹å¼‚æ€§
    let computedStyles = {};
    
    // åº”ç”¨é»˜è®¤æ ·å¼
    computedStyles = { ...this.getDefaultStyles(node.tagName) };
    
    // åº”ç”¨CSSè§„åˆ™
    cssom.forEach(rule => {
      if (this.matchesSelector(node, rule.selector)) {
        computedStyles = { ...computedStyles, ...rule.declarations };
      }
    });
    
    return computedStyles;
  }
};

// 4. å¸ƒå±€è®¡ç®—
const layoutEngine = {
  calculateLayout(renderTree, viewport) {
    renderTree.forEach(node => {
      this.calculateNodeLayout(node, viewport);
    });
  },
  
  calculateNodeLayout(node, container) {
    const styles = node.styles;
    
    // è®¡ç®—ç›’æ¨¡å‹
    const box = {
      content: this.calculateContentBox(styles, container),
      padding: this.calculatePadding(styles),
      border: this.calculateBorder(styles),
      margin: this.calculateMargin(styles)
    };
    
    // è®¡ç®—æœ€ç»ˆä½ç½®å’Œå°ºå¯¸
    node.layout = {
      x: box.margin.left + box.border.left + box.padding.left,
      y: box.margin.top + box.border.top + box.padding.top,
      width: box.content.width,
      height: box.content.height,
      box
    };
    
    // é€’å½’è®¡ç®—å­å…ƒç´ 
    if (node.children) {
      node.children.forEach(child => {
        this.calculateNodeLayout(child, node.layout);
      });
    }
  }
};

// 5. ç»˜åˆ¶æ¸²æŸ“
const paintEngine = {
  paint(renderTree, canvas) {
    const ctx = canvas.getContext('2d');
    
    renderTree.forEach(node => {
      this.paintNode(ctx, node);
    });
  },
  
  paintNode(ctx, node) {
    const { layout, styles } = node;
    
    // ç»˜åˆ¶èƒŒæ™¯
    if (styles.backgroundColor) {
      ctx.fillStyle = styles.backgroundColor;
      ctx.fillRect(layout.x, layout.y, layout.width, layout.height);
    }
    
    // ç»˜åˆ¶è¾¹æ¡†
    if (styles.border) {
      ctx.strokeStyle = styles.borderColor || '#000';
      ctx.lineWidth = parseInt(styles.borderWidth) || 1;
      ctx.strokeRect(layout.x, layout.y, layout.width, layout.height);
    }
    
    // ç»˜åˆ¶æ–‡æœ¬
    if (node.element.textContent) {
      ctx.fillStyle = styles.color || '#000';
      ctx.font = `${styles.fontSize || '16px'} ${styles.fontFamily || 'Arial'}`;
      ctx.fillText(node.element.textContent, layout.x, layout.y + layout.height / 2);
    }
    
    // é€’å½’ç»˜åˆ¶å­å…ƒç´ 
    if (node.children) {
      node.children.forEach(child => {
        this.paintNode(ctx, child);
      });
    }
  }
};
```

### é‡æ’å’Œé‡ç»˜ä¼˜åŒ–

```javascript
// é‡æ’ï¼ˆReflowï¼‰å’Œé‡ç»˜ï¼ˆRepaintï¼‰ä¼˜åŒ–ç­–ç•¥

// 1. æ‰¹é‡DOMæ“ä½œ
function inefficientDOMUpdate() {
  const element = document.getElementById('container');
  
  // æ¯æ¬¡æ“ä½œéƒ½ä¼šè§¦å‘é‡æ’
  element.style.width = '200px';    // é‡æ’
  element.style.height = '200px';   // é‡æ’
  element.style.margin = '10px';    // é‡æ’
}

function efficientDOMUpdate() {
  const element = document.getElementById('container');
  
  // æ–¹æ³•1ï¼šä½¿ç”¨cssTextä¸€æ¬¡æ€§è®¾ç½®
  element.style.cssText = 'width: 200px; height: 200px; margin: 10px;';
  
  // æ–¹æ³•2ï¼šä½¿ç”¨CSSç±»
  element.className = 'optimized-style';
  
  // æ–¹æ³•3ï¼šä½¿ç”¨DocumentFragment
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  element.appendChild(fragment); // åªè§¦å‘ä¸€æ¬¡é‡æ’
}

// 2. è¯»å†™åˆ†ç¦»
function inefficientReadWrite() {
  const element = document.getElementById('box');
  
  element.style.width = '100px';
  const width1 = element.offsetWidth; // å¼ºåˆ¶é‡æ’
  
  element.style.height = '100px';
  const height1 = element.offsetHeight; // å¼ºåˆ¶é‡æ’
}

function efficientReadWrite() {
  const element = document.getElementById('box');
  
  // å…ˆè¯»å–æ‰€æœ‰éœ€è¦çš„å€¼
  const width1 = element.offsetWidth;
  const height1 = element.offsetHeight;
  
  // å†è¿›è¡Œæ‰€æœ‰å†™æ“ä½œ
  element.style.width = '100px';
  element.style.height = '100px';
}

// 3. ä½¿ç”¨transformå’Œopacityè¿›è¡ŒåŠ¨ç”»
function inefficientAnimation() {
  const element = document.getElementById('animated');
  
  // ä¼šè§¦å‘é‡æ’çš„å±æ€§
  element.animate([
    { left: '0px', top: '0px' },
    { left: '100px', top: '100px' }
  ], {
    duration: 1000,
    easing: 'ease-in-out'
  });
}

function efficientAnimation() {
  const element = document.getElementById('animated');
  
  // åªè§¦å‘é‡ç»˜çš„å±æ€§
  element.animate([
    { transform: 'translate(0px, 0px)', opacity: 1 },
    { transform: 'translate(100px, 100px)', opacity: 0.5 }
  ], {
    duration: 1000,
    easing: 'ease-in-out'
  });
}

// 4. è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–
class VirtualScrollList {
  constructor(container, itemHeight, totalItems) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;
    this.scrollTop = 0;
    
    this.init();
  }
  
  init() {
    // åˆ›å»ºå®¹å™¨
    this.viewport = document.createElement('div');
    this.viewport.style.height = `${this.totalItems * this.itemHeight}px`;
    this.viewport.style.position = 'relative';
    
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.top = '0';
    this.content.style.width = '100%';
    
    this.viewport.appendChild(this.content);
    this.container.appendChild(this.viewport);
    
    // ç›‘å¬æ»šåŠ¨
    this.container.addEventListener('scroll', () => {
      this.handleScroll();
    });
    
    this.render();
  }
  
  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.render();
  }
  
  render() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + this.visibleItems, this.totalItems);
    
    // æ¸…ç©ºç°æœ‰å†…å®¹
    this.content.innerHTML = '';
    
    // è®¾ç½®åç§»
    this.content.style.transform = `translateY(${startIndex * this.itemHeight}px)`;
    
    // æ¸²æŸ“å¯è§é¡¹
    for (let i = startIndex; i < endIndex; i++) {
      const item = document.createElement('div');
      item.style.height = `${this.itemHeight}px`;
      item.textContent = `Item ${i}`;
      this.content.appendChild(item);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const container = document.getElementById('scroll-container');
const virtualList = new VirtualScrollList(container, 50, 10000);
```

## âš¡ JavaScriptå¼•æ“å’Œäº‹ä»¶å¾ªç¯

### äº‹ä»¶å¾ªç¯æœºåˆ¶

<Callout type="info">
äº‹ä»¶å¾ªç¯æ˜¯JavaScriptå¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒæœºåˆ¶ï¼Œç†è§£å®ƒå¯¹äºç¼–å†™é«˜æ€§èƒ½çš„å¼‚æ­¥ä»£ç è‡³å…³é‡è¦ã€‚
</Callout>

```javascript
// äº‹ä»¶å¾ªç¯è¯¦è§£
/*
è°ƒç”¨æ ˆï¼ˆCall Stackï¼‰
  â†“
Web APIsï¼ˆæµè§ˆå™¨æä¾›çš„APIï¼‰
  â†“
ä»»åŠ¡é˜Ÿåˆ—ï¼ˆTask Queueï¼‰
  â†“
å¾®ä»»åŠ¡é˜Ÿåˆ—ï¼ˆMicrotask Queueï¼‰
  â†“
äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰
*/

// å®ä»»åŠ¡å’Œå¾®ä»»åŠ¡æ‰§è¡Œé¡ºåº
console.log('1'); // åŒæ­¥ä»»åŠ¡

setTimeout(() => {
  console.log('2'); // å®ä»»åŠ¡
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // å¾®ä»»åŠ¡
});

console.log('4'); // åŒæ­¥ä»»åŠ¡

// è¾“å‡ºé¡ºåºï¼š1, 4, 3, 2

// å¤æ‚çš„äº‹ä»¶å¾ªç¯ç¤ºä¾‹
async function complexEventLoop() {
  console.log('start');
  
  setTimeout(() => console.log('timeout1'), 0);
  
  Promise.resolve().then(() => {
    console.log('promise1');
    return Promise.resolve();
  }).then(() => {
    console.log('promise2');
  });
  
  await new Promise(resolve => {
    console.log('async1');
    resolve();
  });
  
  console.log('async2');
  
  setTimeout(() => console.log('timeout2'), 0);
  
  console.log('end');
}

complexEventLoop();
// è¾“å‡ºï¼šstart, async1, async2, end, promise1, promise2, timeout1, timeout2

// æ‰‹åŠ¨å®ç°ç®€åŒ–çš„äº‹ä»¶å¾ªç¯
class SimpleEventLoop {
  constructor() {
    this.callStack = [];
    this.macroTaskQueue = [];
    this.microTaskQueue = [];
    this.isRunning = false;
  }
  
  // æ·»åŠ å®ä»»åŠ¡
  addMacroTask(task) {
    this.macroTaskQueue.push(task);
    if (!this.isRunning) {
      this.run();
    }
  }
  
  // æ·»åŠ å¾®ä»»åŠ¡
  addMicroTask(task) {
    this.microTaskQueue.push(task);
  }
  
  // æ‰§è¡Œäº‹ä»¶å¾ªç¯
  run() {
    this.isRunning = true;
    
    while (this.macroTaskQueue.length > 0 || this.microTaskQueue.length > 0) {
      // æ‰§è¡Œä¸€ä¸ªå®ä»»åŠ¡
      if (this.macroTaskQueue.length > 0) {
        const macroTask = this.macroTaskQueue.shift();
        this.executeTask(macroTask);
      }
      
      // æ‰§è¡Œæ‰€æœ‰å¾®ä»»åŠ¡
      while (this.microTaskQueue.length > 0) {
        const microTask = this.microTaskQueue.shift();
        this.executeTask(microTask);
      }
    }
    
    this.isRunning = false;
  }
  
  executeTask(task) {
    try {
      task();
    } catch (error) {
      console.error('Task execution error:', error);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const eventLoop = new SimpleEventLoop();

eventLoop.addMacroTask(() => console.log('Macro 1'));
eventLoop.addMicroTask(() => console.log('Micro 1'));
eventLoop.addMacroTask(() => console.log('Macro 2'));
eventLoop.addMicroTask(() => console.log('Micro 2'));
```

### Web Workerså’Œå¤šçº¿ç¨‹

```javascript
// ä¸»çº¿ç¨‹ä»£ç 
class WorkerManager {
  constructor() {
    this.workers = new Map();
    this.taskId = 0;
  }
  
  // åˆ›å»ºWorker
  createWorker(name, scriptPath) {
    const worker = new Worker(scriptPath);
    
    worker.onmessage = (e) => {
      this.handleWorkerMessage(name, e.data);
    };
    
    worker.onerror = (error) => {
      console.error(`Worker ${name} error:`, error);
    };
    
    this.workers.set(name, worker);
    return worker;
  }
  
  // å‘é€ä»»åŠ¡åˆ°Worker
  sendTask(workerName, task) {
    const worker = this.workers.get(workerName);
    if (!worker) {
      throw new Error(`Worker ${workerName} not found`);
    }
    
    const taskId = ++this.taskId;
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Task timeout'));
      }, 10000);
      
      const handleMessage = (e) => {
        if (e.data.taskId === taskId) {
          clearTimeout(timeout);
          worker.removeEventListener('message', handleMessage);
          
          if (e.data.error) {
            reject(new Error(e.data.error));
          } else {
            resolve(e.data.result);
          }
        }
      };
      
      worker.addEventListener('message', handleMessage);
      
      worker.postMessage({
        taskId,
        type: task.type,
        data: task.data
      });
    });
  }
  
  handleWorkerMessage(workerName, data) {
    console.log(`Message from ${workerName}:`, data);
  }
  
  // ç»ˆæ­¢Worker
  terminateWorker(name) {
    const worker = this.workers.get(name);
    if (worker) {
      worker.terminate();
      this.workers.delete(name);
    }
  }
  
  // ç»ˆæ­¢æ‰€æœ‰Worker
  terminateAll() {
    for (const [name, worker] of this.workers) {
      worker.terminate();
    }
    this.workers.clear();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const workerManager = new WorkerManager();

// åˆ›å»ºè®¡ç®—Worker
workerManager.createWorker('calculator', '/workers/calculator.js');

// å‘é€è®¡ç®—ä»»åŠ¡
workerManager.sendTask('calculator', {
  type: 'FIBONACCI',
  data: { n: 40 }
}).then(result => {
  console.log('æ–æ³¢é‚£å¥‘è®¡ç®—ç»“æœ:', result);
}).catch(error => {
  console.error('è®¡ç®—é”™è¯¯:', error);
});

// Workeræ–‡ä»¶ï¼š/workers/calculator.js
self.onmessage = function(e) {
  const { taskId, type, data } = e.data;
  
  try {
    let result;
    
    switch (type) {
      case 'FIBONACCI':
        result = fibonacci(data.n);
        break;
      case 'PRIME_CHECK':
        result = isPrime(data.number);
        break;
      case 'SORT':
        result = data.array.sort((a, b) => a - b);
        break;
      default:
        throw new Error(`Unknown task type: ${type}`);
    }
    
    self.postMessage({
      taskId,
      result
    });
  } catch (error) {
    self.postMessage({
      taskId,
      error: error.message
    });
  }
};

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

function isPrime(num) {
  if (num <= 1) return false;
  if (num <= 3) return true;
  if (num % 2 === 0 || num % 3 === 0) return false;
  
  for (let i = 5; i * i <= num; i += 6) {
    if (num % i === 0 || num % (i + 2) === 0) return false;
  }
  
  return true;
}
```

## ğŸŒ ç°ä»£Web APIè¯¦è§£

### Fetch APIå’Œç½‘ç»œè¯·æ±‚

```javascript
// ç°ä»£åŒ–çš„ç½‘ç»œè¯·æ±‚å¤„ç†
class ApiClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.defaultOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    };
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...this.defaultOptions,
      ...options,
      headers: {
        ...this.defaultOptions.headers,
        ...options.headers
      }
    };

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const contentType = response.headers.get('content-type');

      if (contentType && contentType.includes('application/json')) {
        return await response.json();
      } else if (contentType && contentType.includes('text/')) {
        return await response.text();
      } else {
        return await response.blob();
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Request was aborted');
      } else if (error.name === 'TypeError') {
        throw new Error('Network error: Please check your connection');
      }
      throw error;
    }
  }

  // å¸¦è¶…æ—¶çš„è¯·æ±‚
  async requestWithTimeout(endpoint, options = {}, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await this.request(endpoint, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }

  // å¹¶å‘è¯·æ±‚æ§åˆ¶
  async requestConcurrent(requests, maxConcurrency = 3) {
    const results = [];
    const executing = [];

    for (const request of requests) {
      const promise = this.request(request.endpoint, request.options)
        .then(result => ({ status: 'fulfilled', value: result }))
        .catch(error => ({ status: 'rejected', reason: error }));

      results.push(promise);

      if (requests.length >= maxConcurrency) {
        executing.push(promise);

        if (executing.length >= maxConcurrency) {
          await Promise.race(executing);
          executing.splice(executing.findIndex(p => p === promise), 1);
        }
      }
    }

    return Promise.all(results);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const api = new ApiClient('https://api.example.com');

// åŸºç¡€è¯·æ±‚
const userData = await api.request('/users/123');

// å¸¦è¶…æ—¶çš„è¯·æ±‚
const timeoutData = await api.requestWithTimeout('/slow-endpoint', {}, 3000);

// å¹¶å‘è¯·æ±‚
const concurrentResults = await api.requestConcurrent([
  { endpoint: '/users/1' },
  { endpoint: '/users/2' },
  { endpoint: '/users/3' }
], 2);
```

### Intersection Observer API

```javascript
// äº¤å‰è§‚å¯Ÿå™¨çš„é«˜çº§åº”ç”¨
class IntersectionManager {
  constructor() {
    this.observers = new Map();
  }

  // æ‡’åŠ è½½å›¾ç‰‡
  createLazyImageObserver() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const src = img.dataset.src;

          if (src) {
            img.src = src;
            img.removeAttribute('data-src');
            observer.unobserve(img);
          }
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.1
    });

    this.observers.set('lazyImage', observer);
    return observer;
  }

  // æ— é™æ»šåŠ¨
  createInfiniteScrollObserver(callback) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          callback();
        }
      });
    }, {
      rootMargin: '100px 0px',
      threshold: 0.1
    });

    this.observers.set('infiniteScroll', observer);
    return observer;
  }

  // å…ƒç´ å¯è§æ€§ç»Ÿè®¡
  createVisibilityTracker(callback) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const element = entry.target;
        const visibilityRatio = entry.intersectionRatio;

        callback({
          element,
          isVisible: entry.isIntersecting,
          visibilityRatio,
          boundingRect: entry.boundingClientRect,
          timestamp: entry.time
        });
      });
    }, {
      threshold: [0, 0.25, 0.5, 0.75, 1.0]
    });

    this.observers.set('visibility', observer);
    return observer;
  }

  // åŠ¨ç”»è§¦å‘å™¨
  createAnimationTrigger() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const element = entry.target;

        if (entry.isIntersecting) {
          element.classList.add('animate-in');
          element.classList.remove('animate-out');
        } else {
          element.classList.add('animate-out');
          element.classList.remove('animate-in');
        }
      });
    }, {
      threshold: 0.2
    });

    this.observers.set('animation', observer);
    return observer;
  }

  // æ¸…ç†è§‚å¯Ÿå™¨
  cleanup() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    this.observers.clear();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const intersectionManager = new IntersectionManager();

// æ‡’åŠ è½½å›¾ç‰‡
const lazyImageObserver = intersectionManager.createLazyImageObserver();
document.querySelectorAll('img[data-src]').forEach(img => {
  lazyImageObserver.observe(img);
});

// æ— é™æ»šåŠ¨
const infiniteScrollObserver = intersectionManager.createInfiniteScrollObserver(() => {
  console.log('åŠ è½½æ›´å¤šå†…å®¹...');
  loadMoreContent();
});

const sentinel = document.querySelector('.scroll-sentinel');
if (sentinel) {
  infiniteScrollObserver.observe(sentinel);
}
```

### Web Storageå’Œç¼“å­˜ç­–ç•¥

```javascript
// ç°ä»£åŒ–çš„å­˜å‚¨ç®¡ç†
class StorageManager {
  constructor() {
    this.storage = {
      local: localStorage,
      session: sessionStorage
    };
  }

  // å¸¦è¿‡æœŸæ—¶é—´çš„å­˜å‚¨
  setWithExpiry(key, value, ttl, storageType = 'local') {
    const now = new Date();
    const item = {
      value: value,
      expiry: now.getTime() + ttl
    };

    this.storage[storageType].setItem(key, JSON.stringify(item));
  }

  getWithExpiry(key, storageType = 'local') {
    const itemStr = this.storage[storageType].getItem(key);

    if (!itemStr) {
      return null;
    }

    try {
      const item = JSON.parse(itemStr);
      const now = new Date();

      if (now.getTime() > item.expiry) {
        this.storage[storageType].removeItem(key);
        return null;
      }

      return item.value;
    } catch (error) {
      console.error('Error parsing stored item:', error);
      return null;
    }
  }

  // å­˜å‚¨ç©ºé—´ç®¡ç†
  getStorageInfo(storageType = 'local') {
    const storage = this.storage[storageType];
    let totalSize = 0;
    const items = {};

    for (let key in storage) {
      if (storage.hasOwnProperty(key)) {
        const value = storage[key];
        const size = new Blob([value]).size;
        items[key] = { size, value };
        totalSize += size;
      }
    }

    return {
      totalSize,
      itemCount: Object.keys(items).length,
      items,
      quota: this.getStorageQuota()
    };
  }

  async getStorageQuota() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return {
        quota: estimate.quota,
        usage: estimate.usage,
        available: estimate.quota - estimate.usage
      };
    }
    return null;
  }

  // æ¸…ç†è¿‡æœŸæ•°æ®
  cleanExpired(storageType = 'local') {
    const storage = this.storage[storageType];
    const keysToRemove = [];

    for (let key in storage) {
      if (storage.hasOwnProperty(key)) {
        try {
          const item = JSON.parse(storage[key]);
          if (item.expiry && new Date().getTime() > item.expiry) {
            keysToRemove.push(key);
          }
        } catch (error) {
          // å¿½ç•¥è§£æé”™è¯¯
        }
      }
    }

    keysToRemove.forEach(key => storage.removeItem(key));
    return keysToRemove.length;
  }
}

// IndexedDBå°è£…
class IndexedDBManager {
  constructor(dbName, version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }

  async init(stores = []) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        stores.forEach(store => {
          if (!db.objectStoreNames.contains(store.name)) {
            const objectStore = db.createObjectStore(store.name, store.options);

            if (store.indexes) {
              store.indexes.forEach(index => {
                objectStore.createIndex(index.name, index.keyPath, index.options);
              });
            }
          }
        });
      };
    });
  }

  async add(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.add(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async get(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async getAll(storeName, query = null) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.getAll(query);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async update(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.put(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async delete(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const storageManager = new StorageManager();

// è®¾ç½®å¸¦è¿‡æœŸæ—¶é—´çš„æ•°æ®
storageManager.setWithExpiry('user-token', 'abc123', 3600000); // 1å°æ—¶åè¿‡æœŸ

// è·å–æ•°æ®
const token = storageManager.getWithExpiry('user-token');

// IndexedDBä½¿ç”¨
const dbManager = new IndexedDBManager('MyApp', 1);

await dbManager.init([
  {
    name: 'users',
    options: { keyPath: 'id', autoIncrement: true },
    indexes: [
      { name: 'email', keyPath: 'email', options: { unique: true } }
    ]
  }
]);

await dbManager.add('users', { name: 'John', email: 'john@example.com' });
const users = await dbManager.getAll('users');
```

---

<Callout type="success">
æ·±å…¥ç†è§£æµè§ˆå™¨åŸç†èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬ç¼–å†™æ›´é«˜æ•ˆçš„Webåº”ç”¨ï¼Œä¼˜åŒ–ç”¨æˆ·ä½“éªŒï¼Œå¹¶è§£å†³å¤æ‚çš„æ€§èƒ½é—®é¢˜ã€‚
</Callout>
